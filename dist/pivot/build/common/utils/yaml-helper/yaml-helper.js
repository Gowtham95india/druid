"use strict";var yaml=require("js-yaml");var index_1=require("../../../common/models/index");var labels_1=require("../../../common/models/labels");function spaces(e){return new Array(e+1).join(" ")}function extend(e,t){for(var a in e){t[a]=e[a]}return t}function yamlObject(e,t){if(t===void 0){t=2}var a=spaces(t);return e.map(function(e,t){if(e==="")return"";return a+(t?"  ":"- ")+e})}function yamlPropAdder(e,t,a){var s=a.object,i=a.propName,n=a.defaultValue,o=a.comment;var r=s[i];if(r==null){if(t&&typeof n!=="undefined"){e.push("","# "+o,"#"+i+": "+n+" # <- default")}}else{if(t)e.push("","# "+o);e.push(i+": "+r)}}function getYamlPropAdder(e,t,a,s){if(s===void 0){s=false}var i=function(n,o){var r=t[n];var u;if(!r){console.warn("No labels for "+n+", please fix this in 'common/models/labels.ts'");u=""}else{u=r.description}var l={object:e,propName:n,comment:u};if(o)l=extend(o,l);yamlPropAdder(a,s,l);return{add:i}};return{add:i}}function clusterToYAML(e,t){var a=["name: "+e.name];var s=getYamlPropAdder(e,labels_1.CLUSTER,a,t);s.add("type").add("host").add("version").add("timeout",{defaultValue:index_1.Cluster.DEFAULT_TIMEOUT}).add("sourceListScan",{defaultValue:index_1.Cluster.DEFAULT_SOURCE_LIST_SCAN});if(t){a.push("","# Database specific ("+e.type+") ===============")}switch(e.type){case"druid":s.add("introspectionStrategy",{defaultValue:index_1.Cluster.DEFAULT_INTROSPECTION_STRATEGY}).add("requestDecorator");break;case"postgres":case"mysql":s.add("database").add("user").add("password");break}a.push("");return yamlObject(a)}exports.clusterToYAML=clusterToYAML;function collectionToYAML(e,t){var a=["name: "+e.name];var s=getYamlPropAdder(e,labels_1.COLLECTION,a,t);s.add("title").add("description");a.push("tiles:");a=a.concat.apply(a,e.tiles.map(CollectionTileToYAML));a.push("");return yamlObject(a)}exports.collectionToYAML=collectionToYAML;function CollectionTileToYAML(e){var t=["name: "+e.name];var a=getYamlPropAdder(e,labels_1.COLLECTION_ITEM,t);a.add("title").add("description").add("group").add("dataCube");t.push("essence:");t.push(yaml.safeDump(e.essence.toJSON()));t.push("");return yamlObject(t)}exports.CollectionTileToYAML=CollectionTileToYAML;function attributeToYAML(e){var t=["name: "+e.name,"type: "+e.type];if(e.special){t.push("special: "+e.special)}t.push("");return yamlObject(t)}exports.attributeToYAML=attributeToYAML;function dimensionToYAML(e){var t=["name: "+e.name,"title: "+e.title];if(e.kind!=="string"){t.push("kind: "+e.kind)}t.push("");return yamlObject(t)}exports.dimensionToYAML=dimensionToYAML;function measureToYAML(e){var t=["name: "+e.name,"title: "+e.title];if(e.units){t.push("units: "+e.units)}t.push("formula: "+e.formula);var a=e.format;if(!!a){t.push("format: "+a)}t.push("");return yamlObject(t)}exports.measureToYAML=measureToYAML;function dataCubeToYAML(e,t){var a=["name: "+e.name,"title: "+e.title,"clusterName: "+e.clusterName,"source: "+e.source];var s=e.specialTimeDimension;if(s){if(t){a.push("# The special time attribute of the data refers to the attribute that must always be filtered on");a.push("# This is particularly useful for Druid data cubes as they must always have a time filter.")}a.push("specialTimeDimension: "+s,"")}var i=e.refreshRule;if(i){if(t){a.push("# The refresh rule describes how often the data cube looks for new data. Default: 'query'/PT1M (every minute)")}a.push("refreshRule:");a.push("  rule: "+i.rule);if(i.time){a.push("  time: "+i.time.toISOString())}a.push("")}var n=getYamlPropAdder(e,labels_1.DATA_CUBE,a,t);n.add("defaultTimezone",{defaultValue:index_1.DataCube.DEFAULT_DEFAULT_TIMEZONE}).add("defaultDuration",{defaultValue:index_1.DataCube.DEFAULT_DEFAULT_DURATION}).add("defaultSortMeasure",{defaultValue:e.getDefaultSortMeasure()});var o=e.defaultSelectedMeasures;if(t){a.push("","# The names of measures that are selected by default")}if(o){a.push("defaultSelectedMeasures: "+JSON.stringify(o))}else if(t){a.push("#defaultSelectedMeasures: []")}var r=e.defaultPinnedDimensions;if(t){a.push("","# The names of dimensions that are pinned by default (in order that they will appear in the pin bar)")}if(r){a.push("","defaultPinnedDimensions: "+JSON.stringify(r))}else if(t){a.push("","#defaultPinnedDimensions: []")}var u=e.getIntrospection();if(t){a.push("","# How the dataset should be introspected","# possible options are:","# * none - Do not do any introspection, take what is written in the config as the rule of law.","# * no-autofill - Introspect the datasource but do not automatically generate dimensions or measures","# * autofill-dimensions-only - Introspect the datasource, automatically generate dimensions only","# * autofill-measures-only - Introspect the datasource, automatically generate measures only","# * autofill-all - (default) Introspect the datasource, automatically generate dimensions and measures")}a.push("introspection: "+u);var l=e.dimensions;if(t){a.push("","# The list of dimensions defined in the UI. The order here will be reflected in the UI")}a.push("dimensions:");if(t){a.push("  # A general dimension looks like so:","  #","  # name: channel","  # ^ the name of the dimension as used in the URL (you should try not to change these)","  #","  # title: The Channel","  # ^ (optional) the human readable title. If not set a title is generated from the 'name'","  #","  # kind: string","  # ^ (optional) the kind of the dimension. Can be 'string', 'time', 'number', or 'boolean'. Defaults to 'string'","  #","  # formula: $channel","  # ^ (optional) the Plywood bucketing expression for this dimension. Defaults to '$name'","  #   if, say, channel was called 'cnl' in the data you would put '$cnl' here","  #   See also the expressions API reference: https://plywood.imply.io/expressions","  #","  # url: string","  # ^ (optional) a url (including protocol) associated with the dimension, with optional token '%s'","  #   that is replaced by the dimension value to generate links specific to each value.","")}a=a.concat.apply(a,l.map(dimensionToYAML));if(t){a.push("  # This is the place where you might want to add derived dimensions.","  #","  # Here are some examples of possible derived dimensions:","  #","  # - name: is_usa","  #   title: Is USA?","  #   formula: $country == 'United States'","  #","  # - name: file_version","  #   formula: $filename.extract('(\\d+\\.\\d+\\.\\d+)')","")}var d=e.measures;if(t){a.push("","# The list of measures defined in the UI. The order here will be reflected in the UI")}a.push("measures:");if(t){a.push("  # A general measure looks like so:","  #","  # name: avg_revenue","  # ^ the name of the dimension as used in the URL (you should try not to change these)","  #","  # title: Average Revenue","  # ^ (optional) the human readable title. If not set a title is generated from the 'name'","  #","  # formula: $main.sum($revenue) / $main.sum($volume) * 10","  # ^ (optional) the Plywood bucketing expression for this dimension.","  #   Usually defaults to '$main.sum($name)' but if the name contains 'min' or 'max' will use that as the aggregate instead of sum.","  #   this is the place to define your fancy formulas","")}a=a.concat.apply(a,d.map(measureToYAML));if(t){a.push("  # This is the place where you might want to add derived measures (a.k.a Post Aggregators).","  #","  # Here are some examples of possible derived measures:","  #","  # - name: ecpm","  #   title: eCPM","  #   formula: $main.sum($revenue) / $main.sum($impressions) * 1000","  #","  # - name: usa_revenue","  #   title: USA Revenue","  #   formula: $main.filter($country == 'United States').sum($revenue)","")}a.push("");return yamlObject(a)}exports.dataCubeToYAML=dataCubeToYAML;function appSettingsToYAML(e,t,a){if(a===void 0){a={}}var s=e.dataCubes,i=e.clusters,n=e.collections;if(!s.length)throw new Error("Could not find any data cubes, please verify network connectivity");var o=[];if(a.header&&a.version){o.push("# generated by Pivot version "+a.version,"# for a more detailed walk-through go to: http://pivot.imply.io/configuration","")}if(a.verbose){if(t){o.push("# Run Pivot in verbose mode so it prints out the queries that it issues")}o.push("verbose: true","")}if(a.port){if(t){o.push("# The port on which the Pivot server will listen on")}o.push("port: "+a.port,"")}if(i.length){o.push("clusters:");o=o.concat.apply(o,i.map(function(e){return clusterToYAML(e,t)}))}o.push("dataCubes:");o=o.concat.apply(o,s.map(function(e){return dataCubeToYAML(e,t)}));return o.join("\n")}exports.appSettingsToYAML=appSettingsToYAML;