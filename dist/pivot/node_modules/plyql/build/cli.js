"use strict";
var fs = require('fs');
var path = require("path");
var Q = require('q');
var nopt = require("nopt");
var table_1 = require('table');
var chronoshift_1 = require("chronoshift");
var plywood_1 = require("plywood");
var requester_1 = require("./requester");
var plyql_executor_1 = require("./plyql-executor");
var variables_1 = require('./variables');
var status_1 = require('./status');
var schema_1 = require('./schema');
function formatNull(v) {
    if (v == null)
        return 'NULL';
    return v;
}
function printUsage() {
    console.log("\nUsage: plyql [options]\n\nExamples:\n  plyql -h 10.20.30.40 -q 'SHOW TABLES'\n\n  plyql -h 10.20.30.40 -q 'DESCRIBE twitterstream'\n\n  plyql -h 10.20.30.40 -q 'SELECT MAX(__time) AS maxTime FROM twitterstream'\n\n  plyql -h 10.20.30.40 -s twitterstream -i P5D -q \\\n    'SELECT SUM(tweet_length) as TotalTweetLength WHERE first_hashtag = \"#imply\"'\n\nArguments:\n\n      --help         print this help message\n      --version      display the version number\n  -v, --verbose      display the queries that are being made\n  -h, --host         the host to connect to\n  -s, --source       use this source for the query (supersedes FROM clause)\n  -i, --interval     add (AND) a __time filter between NOW-INTERVAL and NOW\n  -Z, --timezone     the default timezone\n  -o, --output       the output format. Possible values: table (default), json, csv, tsv, flat\n  -t, --timeout      the time before a query is timed out in ms (default: 180000)\n  -r, --retry        the number of tries a query should be attempted on error, 0 = unlimited, (default: 2)\n  -c, --concurrent   the limit of concurrent queries that could be made simultaneously, 0 = unlimited, (default: 2)\n      --rollup       use rollup mode [COUNT() -> SUM(count)]\n\n  -q, --query        the query to run\n      --json-server  the port on which to start the json server\n      --experimental-mysql-gateway [Experimental] the port on which to start the MySQL gateway server\n\n      --druid-version            Assume this is the Druid version and do not query it\n      --druid-context            A JSON string representing the Druid context to use\n      --skip-cache               disable Druid caching\n      --introspection-strategy   Druid introspection strategy\n          Possible values:\n          * segment-metadata-fallback - (default) use the segmentMetadata and fallback to GET route\n          * segment-metadata-only     - only use the segmentMetadata query\n          * datasource-get            - only use GET /druid/v2/datasources/DATASOURCE route\n\n      --force-time       force a column to be interpreted as a time column\n      --force-boolean    force a column to be interpreted as a boolean\n      --force-number     force a column to be interpreted as a number\n      --force-unique     force a column to be interpreted as a hyperLogLog uniques\n      --force-theta      force a column to be interpreted as a theta sketch\n      --force-histogram  force a column to be interpreted as an approximate histogram\n");
}
function printVersion() {
    var cliPackageFilename = path.join(__dirname, '..', 'package.json');
    var cliPackage;
    try {
        cliPackage = JSON.parse(fs.readFileSync(cliPackageFilename, 'utf8'));
    }
    catch (e) {
        console.log("could not read cli package", e.message);
        return;
    }
    console.log("plyql version " + cliPackage.version + " (plywood version " + plywood_1.version + ")");
}
function parseArguments() {
    return nopt({
        "host": String,
        "druid": String,
        "source": String,
        "data-source": String,
        "help": Boolean,
        "query": String,
        "json-server": Number,
        "experimental-mysql-gateway": Number,
        "interval": String,
        "timezone": String,
        "version": Boolean,
        "verbose": Boolean,
        "timeout": Number,
        "retry": Number,
        "concurrent": Number,
        "output": String,
        "force-time": [String, Array],
        "force-boolean": [String, Array],
        "force-number": [String, Array],
        "force-unique": [String, Array],
        "force-theta": [String, Array],
        "force-histogram": [String, Array],
        "druid-version": String,
        "druid-context": String,
        "druid-time-attribute": String,
        "rollup": Boolean,
        "skip-cache": Boolean,
        "introspection-strategy": String
    }, {
        "v": ["--verbose"],
        "h": ["--host"],
        "s": ["--source"],
        "i": ["--interval"],
        "Z": ["--timezone"],
        "o": ["--output"],
        "t": ["--timeout"],
        "r": ["--retry"],
        "c": ["--concurrent"],
        "q": ["--query"]
    }, process.argv);
}
exports.parseArguments = parseArguments;
function run(parsed) {
    return Q.fcall(function () {
        if (parsed.argv.original.length === 0 || parsed.help) {
            printUsage();
            return null;
        }
        if (parsed['version']) {
            printVersion();
            return null;
        }
        var verbose = parsed['verbose'];
        if (verbose)
            printVersion();
        var attributeOverrides = [];
        var forceTime = parsed['force-time'] || [];
        for (var _i = 0, forceTime_1 = forceTime; _i < forceTime_1.length; _i++) {
            var attributeName = forceTime_1[_i];
            attributeOverrides.push({ name: attributeName, type: 'TIME' });
        }
        var forceBoolean = parsed['force-boolean'] || [];
        for (var _a = 0, forceBoolean_1 = forceBoolean; _a < forceBoolean_1.length; _a++) {
            var attributeName = forceBoolean_1[_a];
            attributeOverrides.push({ name: attributeName, type: 'BOOLEAN' });
        }
        var forceNumber = parsed['force-number'] || [];
        for (var _b = 0, forceNumber_1 = forceNumber; _b < forceNumber_1.length; _b++) {
            var attributeName = forceNumber_1[_b];
            attributeOverrides.push({ name: attributeName, type: 'NUMBER' });
        }
        var forceUnique = parsed['force-unique'] || [];
        for (var _c = 0, forceUnique_1 = forceUnique; _c < forceUnique_1.length; _c++) {
            var attributeName = forceUnique_1[_c];
            attributeOverrides.push({ name: attributeName, special: 'unique' });
        }
        var forceTheta = parsed['force-theta'] || [];
        for (var _d = 0, forceTheta_1 = forceTheta; _d < forceTheta_1.length; _d++) {
            var attributeName = forceTheta_1[_d];
            attributeOverrides.push({ name: attributeName, special: 'theta' });
        }
        var forceHistogram = parsed['force-histogram'] || [];
        for (var _e = 0, forceHistogram_1 = forceHistogram; _e < forceHistogram_1.length; _e++) {
            var attributeName = forceHistogram_1[_e];
            attributeOverrides.push({ name: attributeName, special: 'histogram' });
        }
        var output = (parsed['output'] || 'table').toLowerCase();
        if (output !== 'table' && output !== 'json' && output !== 'csv' && output !== 'tsv' && output !== 'flat') {
            throw new Error("output must be one of table, json, csv, tsv, or flat (is " + output + ")");
        }
        var host = parsed['druid'] || parsed['host'];
        if (!host) {
            throw new Error("must have a host");
        }
        var explicitDruidVersion = parsed['druid-version'];
        var timezone = chronoshift_1.Timezone.UTC;
        if (parsed['timezone']) {
            timezone = chronoshift_1.Timezone.fromJS(parsed['timezone']);
        }
        var timeout = parsed.hasOwnProperty('timeout') ? parsed['timeout'] : 180000;
        var retry = parsed.hasOwnProperty('retry') ? parsed['retry'] : 2;
        var concurrent = parsed.hasOwnProperty('concurrent') ? parsed['concurrent'] : 2;
        var druidContext = {};
        if (parsed.hasOwnProperty('druid-context')) {
            try {
                druidContext = JSON.parse(parsed['druid-context']);
            }
            catch (e) {
                throw new Error("can not parse druid-context as JSON " + parsed['druid-context'] + ")");
            }
        }
        druidContext.timeout = timeout;
        if (parsed['skip-cache']) {
            druidContext.useCache = false;
            druidContext.populateCache = false;
        }
        var timeAttribute = parsed['druid-time-attribute'] || '__time';
        var filter = null;
        var intervalString = parsed['interval'];
        if (intervalString) {
            var interval = void 0;
            try {
                var _f = chronoshift_1.parseInterval(intervalString, timezone), computedStart = _f.computedStart, computedEnd = _f.computedEnd;
                interval = plywood_1.TimeRange.fromJS({ start: computedStart, end: computedEnd });
            }
            catch (e) {
                throw new Error("Could not parse interval: " + intervalString);
            }
            filter = plywood_1.$(timeAttribute).in(interval);
        }
        var masterSource = parsed['source'] || parsed['data-source'] || null;
        if (Number(!!parsed['query']) + Number(!!parsed['json-server']) + Number(!!parsed['experimental-mysql-gateway']) > 1) {
            throw new Error("must set exactly one of --query (-q), --json-server, or --experimental-mysql-gateway");
        }
        var mode;
        var sqlParse;
        var serverPort;
        if (parsed['query']) {
            mode = 'query';
            var query = parsed['query'];
            if (verbose) {
                console.log('Received query:');
                console.log(query);
                console.log('---------------------------');
            }
            try {
                sqlParse = plywood_1.Expression.parseSQL(query, timezone);
            }
            catch (e) {
                throw new Error("Could not parse query: " + e.message);
            }
            if (sqlParse.verb && sqlParse.verb !== 'SELECT') {
                throw new Error("Unsupported SQL verb " + sqlParse.verb + " must be SELECT, DESCRIBE, SHOW, or a raw expression");
            }
            if (verbose && sqlParse.expression) {
                console.log('Parsed query as the following plywood expression (as JSON):');
                console.log(JSON.stringify(sqlParse.expression, null, 2));
                console.log('---------------------------');
            }
        }
        else if (parsed['json-server']) {
            mode = 'server';
            serverPort = parsed['json-server'];
        }
        else if (parsed['experimental-mysql-gateway']) {
            mode = 'gateway';
            serverPort = parsed['experimental-mysql-gateway'];
        }
        else {
            throw new Error("must set one of --query (-q), --json-server, or --experimental-mysql-gateway");
        }
        var requester = requester_1.properDruidRequesterFactory({
            druidHost: host,
            retry: retry,
            timeout: timeout,
            verbose: verbose,
            concurrentLimit: concurrent
        });
        var contextPromise = (explicitDruidVersion ? Q(explicitDruidVersion) : plywood_1.DruidExternal.getVersion(requester))
            .then(function (druidVersion) {
            var onlyDataSource = masterSource || (sqlParse ? sqlParse.table : null);
            var sourceList = onlyDataSource ? Q([onlyDataSource]) : plywood_1.DruidExternal.getSourceList(requester);
            return sourceList.then(function (sources) {
                if (verbose && !onlyDataSource) {
                    console.log("Found sources [" + sources.join(',') + "]");
                }
                var context = {};
                if (mode === 'gateway') {
                    var variablesDataset = variables_1.getVariablesDataset();
                    context['GLOBAL_VARIABLES'] = variablesDataset;
                    context['SESSION_VARIABLES'] = variablesDataset;
                    var statusDataset = status_1.getStatusDataset();
                    context['GLOBAL_STATUS'] = statusDataset;
                    context['SESSION_STATUS'] = statusDataset;
                }
                return Q.all(sources.map(function (source) {
                    return plywood_1.External.fromJS({
                        engine: 'druid',
                        version: druidVersion,
                        source: source,
                        rollup: parsed['rollup'],
                        timeAttribute: timeAttribute,
                        allowEternity: true,
                        allowSelectQueries: true,
                        introspectionStrategy: parsed['introspection-strategy'],
                        context: druidContext,
                        filter: filter,
                        attributeOverrides: attributeOverrides
                    }, requester)
                        .introspect();
                }))
                    .then(function (introspectedExternals) {
                    introspectedExternals.forEach(function (introspectedExternal) {
                        var source = introspectedExternal.source;
                        context[source] = introspectedExternal;
                        schema_1.addExternal(source, introspectedExternal, mode === 'gateway');
                    });
                    context['SCHEMATA'] = schema_1.getSchemataDataset();
                    context['TABLES'] = schema_1.getTablesDataset();
                    context['COLUMNS'] = schema_1.getColumnsDataset();
                    if (mode === 'query' && masterSource && !sqlParse.table && !sqlParse.rewrite) {
                        context['data'] = context[masterSource];
                    }
                    if (verbose)
                        console.log("introspection complete");
                    return context;
                });
            });
        });
        return contextPromise.then(function (context) {
            switch (mode) {
                case 'query':
                    return plyql_executor_1.executeSQLParse(sqlParse, context, timezone)
                        .then(function (data) {
                        var outputStr = '';
                        if (plywood_1.Dataset.isDataset(data)) {
                            var dataset = data;
                            switch (output) {
                                case 'table':
                                    var columns = dataset.getColumns();
                                    var flatData = dataset.flatten();
                                    var columnNames_1 = columns.map(function (c) { return c.name; });
                                    if (columnNames_1.length) {
                                        var tableData = [columnNames_1].concat(flatData.map(function (flatDatum) { return columnNames_1.map(function (cn) { return formatNull(flatDatum[cn]); }); }));
                                        outputStr = table_1["default"](tableData, {
                                            border: table_1.getBorderCharacters('norc'),
                                            drawHorizontalLine: function (index, size) { return index <= 1 || index === size; }
                                        });
                                    }
                                    break;
                                case 'json':
                                    outputStr = JSON.stringify(dataset, null, 2);
                                    break;
                                case 'csv':
                                    outputStr = dataset.toCSV({ finalLineBreak: 'include' });
                                    break;
                                case 'tsv':
                                    outputStr = dataset.toTSV({ finalLineBreak: 'include' });
                                    break;
                                case 'flat':
                                    outputStr = JSON.stringify(dataset.flatten(), null, 2);
                                    break;
                                default:
                                    outputStr = 'Unknown output type';
                                    break;
                            }
                        }
                        else {
                            outputStr = String(data);
                        }
                        console.log(outputStr);
                    })
                        .catch(function (err) {
                        throw new Error("There was an error getting the data: " + err.message);
                    });
                case 'gateway':
                    require('./plyql-mysql-gateway').plyqlMySQLGateway(serverPort, context, timezone, null);
                    return null;
                case 'server':
                    require('./plyql-json-server').plyqlJSONServer(serverPort, context, timezone, null);
                    return null;
                default:
                    throw new Error("unsupported mode " + mode);
            }
        });
    });
}
exports.run = run;
