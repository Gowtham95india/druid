'use strict';

var Q = require('q');

var immutableClass = require('immutable-class');
var generalEqual = immutableClass.generalEqual;
var isImmutableClass = immutableClass.isImmutableClass;
var immutableEqual = immutableClass.immutableEqual;
var immutableArraysEqual = immutableClass.immutableArraysEqual;
var immutableLookupsEqual = immutableClass.immutableLookupsEqual;
var SimpleArray = immutableClass.SimpleArray;
var NamedArray = immutableClass.NamedArray;

var Chronoshift = require('chronoshift');
var Timezone = Chronoshift.Timezone;
var Duration = Chronoshift.Duration;
var moment = Chronoshift.moment;
var isDate = Chronoshift.isDate;
var parseISODate = Chronoshift.parseISODate;

var dummyObject = {};

var version = exports.version = '0.15.4';

var promiseWhile = exports.promiseWhile = function(condition, action) {
    var loop = function () {
        if (!condition())
            return Q(null);
        return Q(action()).then(loop);
    };
    return Q(null).then(loop);
}
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var objectHasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwnProperty = exports.hasOwnProperty = function(obj, key) {
    return objectHasOwnProperty.call(obj, key);
}
var repeat = exports.repeat = function(str, times) {
    return new Array(times + 1).join(str);
}
var indentBy = exports.indentBy = function(str, indent) {
    var spaces = repeat(' ', indent);
    return str.split('\n').map(function (x) { return spaces + x; }).join('\n');
}
var dictEqual = exports.dictEqual = function(dictA, dictB) {
    if (dictA === dictB)
        return true;
    if (!dictA !== !dictB)
        return false;
    var keys = Object.keys(dictA);
    if (keys.length !== Object.keys(dictB).length)
        return false;
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (dictA[key] !== dictB[key])
            return false;
    }
    return true;
}
var shallowCopy = exports.shallowCopy = function(thing) {
    var newThing = {};
    for (var k in thing) {
        if (hasOwnProperty(thing, k))
            newThing[k] = thing[k];
    }
    return newThing;
}
var deduplicateSort = exports.deduplicateSort = function(a) {
    a = a.sort();
    var newA = [];
    var last = null;
    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
        var v = a_1[_i];
        if (v !== last)
            newA.push(v);
        last = v;
    }
    return newA;
}
var mapLookup = exports.mapLookup = function(thing, fn) {
    var newThing = Object.create(null);
    for (var k in thing) {
        if (hasOwnProperty(thing, k))
            newThing[k] = fn(thing[k]);
    }
    return newThing;
}
var emptyLookup = exports.emptyLookup = function(lookup) {
    for (var k in lookup) {
        if (hasOwnProperty(lookup, k))
            return false;
    }
    return true;
}
var nonEmptyLookup = exports.nonEmptyLookup = function(lookup) {
    return !emptyLookup(lookup);
}
var safeAdd = exports.safeAdd = function(num, delta) {
    var stringDelta = String(delta);
    var dotIndex = stringDelta.indexOf(".");
    if (dotIndex === -1 || stringDelta.length === 18) {
        return num + delta;
    }
    else {
        var scale = Math.pow(10, stringDelta.length - dotIndex - 1);
        return (num * scale + delta * scale) / scale;
    }
}
var continuousFloorExpression = exports.continuousFloorExpression = function(variable, floorFn, size, offset) {
    var expr = variable;
    if (offset !== 0) {
        expr = expr + " - " + offset;
    }
    if (offset !== 0 && size !== 1) {
        expr = "(" + expr + ")";
    }
    if (size !== 1) {
        expr = expr + " / " + size;
    }
    expr = floorFn + "(" + expr + ")";
    if (size !== 1) {
        expr = expr + " * " + size;
    }
    if (offset !== 0) {
        expr = expr + " + " + offset;
    }
    return expr;
}
var ExtendableError = exports.ExtendableError = (function (_super) {
    __extends(ExtendableError, _super);
    function ExtendableError(message) {
        _super.call(this, message);
        this.name = this.constructor.name;
        this.message = message;
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, this.constructor);
        }
        else {
            this.stack = (new Error(message)).stack;
        }
    }
    return ExtendableError;
}(Error));










var getValueType = exports.getValueType = function(value) {
    var typeofValue = typeof value;
    if (typeofValue === 'object') {
        if (value === null) {
            return 'NULL';
        }
        else if (isDate(value)) {
            return 'TIME';
        }
        else if (hasOwnProperty(value, 'start') && hasOwnProperty(value, 'end')) {
            if (isDate(value.start) || isDate(value.end))
                return 'TIME_RANGE';
            if (typeof value.start === 'number' || typeof value.end === 'number')
                return 'NUMBER_RANGE';
            if (typeof value.start === 'string' || typeof value.end === 'string')
                return 'STRING_RANGE';
            throw new Error("unrecognizable range");
        }
        else {
            var ctrType = value.constructor.type;
            if (!ctrType) {
                if (value instanceof Expression) {
                    throw new Error("expression used as datum value " + value);
                }
                else {
                    throw new Error("can not have an object without a type: " + JSON.stringify(value));
                }
            }
            if (ctrType === 'SET')
                ctrType += '/' + value.setType;
            return ctrType;
        }
    }
    else {
        if (typeofValue !== 'boolean' && typeofValue !== 'number' && typeofValue !== 'string') {
            throw new TypeError('unsupported JS type ' + typeofValue);
        }
        return typeofValue.toUpperCase();
    }
}
var getFullType = exports.getFullType = function(value) {
    var myType = getValueType(value);
    return myType === 'DATASET' ? value.getFullType() : { type: myType };
}
var getFullTypeFromDatum = exports.getFullTypeFromDatum = function(datum) {
    var datasetType = {};
    for (var k in datum) {
        if (!hasOwnProperty(datum, k))
            continue;
        datasetType[k] = getFullType(datum[k]);
    }
    return {
        type: 'DATASET',
        datasetType: datasetType
    };
}
var valueFromJS = exports.valueFromJS = function(v, typeOverride) {
    if (typeOverride === void 0) { typeOverride = null; }
    if (v == null) {
        return null;
    }
    else if (Array.isArray(v)) {
        if (v.length && typeof v[0] !== 'object') {
            return Set.fromJS(v);
        }
        else {
            return Dataset.fromJS(v);
        }
    }
    else if (typeof v === 'object') {
        switch (typeOverride || v.type) {
            case 'NUMBER':
                var n = Number(v.value);
                if (isNaN(n))
                    throw new Error("bad number value '" + v.value + "'");
                return n;
            case 'NUMBER_RANGE':
                return NumberRange.fromJS(v);
            case 'STRING_RANGE':
                return StringRange.fromJS(v);
            case 'TIME':
                return typeOverride ? v : new Date(v.value);
            case 'TIME_RANGE':
                return TimeRange.fromJS(v);
            case 'SET':
                return Set.fromJS(v);
            default:
                if (v.toISOString) {
                    return v;
                }
                else {
                    throw new Error('can not have an object without a `type` as a datum value');
                }
        }
    }
    else if (typeof v === 'string' && typeOverride === 'TIME') {
        return new Date(v);
    }
    return v;
}
var valueToJS = exports.valueToJS = function(v) {
    if (v == null) {
        return null;
    }
    else {
        var typeofV = typeof v;
        if (typeofV === 'object') {
            if (v.toISOString) {
                return v;
            }
            else {
                return v.toJS();
            }
        }
        else if (typeofV === 'number' && !isFinite(v)) {
            return String(v);
        }
    }
    return v;
}
var valueToJSInlineType = exports.valueToJSInlineType = function(v) {
    if (v == null) {
        return null;
    }
    else {
        var typeofV = typeof v;
        if (typeofV === 'object') {
            if (v.toISOString) {
                return { type: 'TIME', value: v };
            }
            else {
                var js = v.toJS();
                if (!Array.isArray(js)) {
                    js.type = v.constructor.type || 'EXPRESSION';
                }
                return js;
            }
        }
        else if (typeofV === 'number' && !isFinite(v)) {
            return { type: 'NUMBER', value: String(v) };
        }
    }
    return v;
}
var datumHasExternal = exports.datumHasExternal = function(datum) {
    for (var name in datum) {
        var value = datum[name];
        if (value instanceof External)
            return true;
        if (value instanceof Dataset && value.hasExternal())
            return true;
    }
    return false;
}
var introspectDatum = exports.introspectDatum = function(datum) {
    var promises = [];
    var newDatum = Object.create(null);
    Object.keys(datum)
        .forEach(function (name) {
        var v = datum[name];
        if (v instanceof External && v.needsIntrospect()) {
            promises.push(v.introspect().then(function (introspectedExternal) {
                newDatum[name] = introspectedExternal;
            }));
        }
        else {
            newDatum[name] = v;
        }
    });
    return Q.all(promises).then(function () { return newDatum; });
}
var failIfIntrospectNeededInDatum = exports.failIfIntrospectNeededInDatum = function(datum) {
    Object.keys(datum)
        .forEach(function (name) {
        var v = datum[name];
        if (v instanceof External && v.needsIntrospect()) {
            throw new Error('Can not have un-introspected external');
        }
    });
}
var isSetType = exports.isSetType = function(type) {
    return type && type.indexOf('SET/') === 0;
}
var wrapSetType = exports.wrapSetType = function(type) {
    if (!type)
        return null;
    return isSetType(type) ? type : ('SET/' + type);
}
var unwrapSetType = exports.unwrapSetType = function(type) {
    if (!type)
        return null;
    return isSetType(type) ? type.substr(4) : type;
}
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var check;
var AttributeInfo = exports.AttributeInfo = (function () {
    function AttributeInfo(parameters) {
        this.special = parameters.special;
        if (typeof parameters.name !== "string") {
            throw new Error("name must be a string");
        }
        this.name = parameters.name;
        this.type = parameters.type || 'STRING';
        if (!RefExpression.validType(this.type))
            throw new Error("invalid type: " + this.type);
        this.datasetType = parameters.datasetType;
        this.unsplitable = Boolean(parameters.unsplitable);
        this.maker = parameters.maker;
    }
    AttributeInfo.isAttributeInfo = function (candidate) {
        return candidate instanceof AttributeInfo;
    };
    AttributeInfo.jsToValue = function (parameters) {
        var value = {
            special: parameters.special,
            name: parameters.name
        };
        if (parameters.type)
            value.type = parameters.type;
        if (parameters.datasetType)
            value.datasetType = parameters.datasetType;
        if (parameters.unsplitable)
            value.unsplitable = true;
        var maker = parameters.maker || parameters.makerAction;
        if (maker)
            value.maker = Expression.fromJS(maker);
        return value;
    };
    AttributeInfo.register = function (ex) {
        var special = ex.special.replace(/^\w/, function (s) { return s.toLowerCase(); });
        AttributeInfo.classMap[special] = ex;
    };
    AttributeInfo.getConstructorFor = function (special) {
        var classFn = AttributeInfo.classMap[special];
        if (!classFn)
            return AttributeInfo;
        return classFn;
    };
    AttributeInfo.fromJS = function (parameters) {
        if (typeof parameters !== "object") {
            throw new Error("unrecognizable attributeMeta");
        }
        if (!hasOwnProperty(parameters, 'special')) {
            return new AttributeInfo(AttributeInfo.jsToValue(parameters));
        }
        if (parameters.special === 'range') {
            throw new Error("'range' attribute info is no longer supported, you should apply the .extract('^\\d+') function instead");
        }
        var Class = AttributeInfo.getConstructorFor(parameters.special || '');
        if (!Class) {
            throw new Error("unsupported special attributeInfo '" + parameters.special + "'");
        }
        return Class.fromJS(parameters);
    };
    AttributeInfo.fromJSs = function (attributeJSs) {
        if (!Array.isArray(attributeJSs))
            throw new TypeError("invalid attributeJSs");
        return attributeJSs.map(function (attributeJS) { return AttributeInfo.fromJS(attributeJS); });
    };
    AttributeInfo.toJSs = function (attributes) {
        return attributes.map(function (attribute) { return attribute.toJS(); });
    };
    AttributeInfo.override = function (attributes, attributeOverrides) {
        return NamedArray.overridesByName(attributes, attributeOverrides);
    };
    AttributeInfo.fromValue = function (parameters) {
        var special = parameters.special;
        var ClassFn = AttributeInfo.getConstructorFor(special || '');
        return new ClassFn(parameters);
    };
    AttributeInfo.prototype._ensureSpecial = function (special) {
        if (!this.special) {
            this.special = special;
            return;
        }
        if (this.special !== special) {
            throw new TypeError("incorrect attributeInfo special '" + this.special + "' (needs to be: '" + special + "')");
        }
    };
    AttributeInfo.prototype.toString = function () {
        var special = this.special ? "[" + this.special + "]" : '';
        return this.name + "::" + this.type + special;
    };
    AttributeInfo.prototype.valueOf = function () {
        return {
            name: this.name,
            type: this.type,
            unsplitable: this.unsplitable,
            special: this.special,
            datasetType: this.datasetType,
            maker: this.maker
        };
    };
    AttributeInfo.prototype.toJS = function () {
        var js = {
            name: this.name,
            type: this.type
        };
        if (this.special) {
            js.special = this.special;
        }
        else {
            if (this.unsplitable)
                js.unsplitable = true;
        }
        if (this.datasetType)
            js.datasetType = this.datasetType;
        if (this.maker)
            js.maker = this.maker.toJS();
        return js;
    };
    AttributeInfo.prototype.toJSON = function () {
        return this.toJS();
    };
    AttributeInfo.prototype.equals = function (other) {
        return other instanceof AttributeInfo &&
            this.special === other.special &&
            this.name === other.name &&
            this.type === other.type &&
            this.unsplitable === other.unsplitable &&
            immutableEqual(this.maker, other.maker);
    };
    AttributeInfo.prototype.serialize = function (value) {
        return value;
    };
    AttributeInfo.prototype.change = function (propertyName, newValue) {
        var v = this.valueOf();
        if (!v.hasOwnProperty(propertyName)) {
            throw new Error("Unknown property: " + propertyName);
        }
        v[propertyName] = newValue;
        return AttributeInfo.fromValue(v);
    };
    AttributeInfo.prototype.getUnsplitable = function () {
        return this.unsplitable;
    };
    AttributeInfo.prototype.changeUnsplitable = function (unsplitable) {
        var value = this.valueOf();
        value.unsplitable = unsplitable;
        return AttributeInfo.fromValue(value);
    };
    AttributeInfo.classMap = {};
    return AttributeInfo;
}());
check = AttributeInfo;
var UniqueAttributeInfo = exports.UniqueAttributeInfo = (function (_super) {
    __extends(UniqueAttributeInfo, _super);
    function UniqueAttributeInfo(parameters) {
        _super.call(this, parameters);
        this._ensureSpecial("unique");
        this.type = 'STRING';
        this.unsplitable = true;
    }
    UniqueAttributeInfo.fromJS = function (parameters) {
        return new UniqueAttributeInfo(AttributeInfo.jsToValue(parameters));
    };
    UniqueAttributeInfo.prototype.serialize = function (value) {
        throw new Error("can not serialize an approximate unique value");
    };
    UniqueAttributeInfo.prototype.getUnsplitable = function () {
        return true;
    };
    UniqueAttributeInfo.special = 'unique';
    return UniqueAttributeInfo;
}(AttributeInfo));
AttributeInfo.register(UniqueAttributeInfo);
var ThetaAttributeInfo = exports.ThetaAttributeInfo = (function (_super) {
    __extends(ThetaAttributeInfo, _super);
    function ThetaAttributeInfo(parameters) {
        _super.call(this, parameters);
        this._ensureSpecial("theta");
        this.type = 'STRING';
        this.unsplitable = true;
    }
    ThetaAttributeInfo.fromJS = function (parameters) {
        return new ThetaAttributeInfo(AttributeInfo.jsToValue(parameters));
    };
    ThetaAttributeInfo.prototype.serialize = function (value) {
        throw new Error("can not serialize a theta value");
    };
    ThetaAttributeInfo.prototype.getUnsplitable = function () {
        return true;
    };
    ThetaAttributeInfo.special = 'theta';
    return ThetaAttributeInfo;
}(AttributeInfo));
AttributeInfo.register(ThetaAttributeInfo);
var HistogramAttributeInfo = exports.HistogramAttributeInfo = (function (_super) {
    __extends(HistogramAttributeInfo, _super);
    function HistogramAttributeInfo(parameters) {
        _super.call(this, parameters);
        this._ensureSpecial("histogram");
        this.type = 'NUMBER';
        this.unsplitable = true;
    }
    HistogramAttributeInfo.fromJS = function (parameters) {
        return new HistogramAttributeInfo(AttributeInfo.jsToValue(parameters));
    };
    HistogramAttributeInfo.prototype.serialize = function (value) {
        throw new Error("can not serialize a histogram value");
    };
    HistogramAttributeInfo.prototype.getUnsplitable = function () {
        return true;
    };
    HistogramAttributeInfo.special = 'histogram';
    return HistogramAttributeInfo;
}(AttributeInfo));
AttributeInfo.register(HistogramAttributeInfo);
var BOUNDS_REG_EXP = /^[\[(][\])]$/;
var Range = exports.Range = (function () {
    function Range(start, end, bounds) {
        if (bounds) {
            if (!BOUNDS_REG_EXP.test(bounds)) {
                throw new Error("invalid bounds " + bounds);
            }
        }
        else {
            bounds = Range.DEFAULT_BOUNDS;
        }
        if (start !== null && end !== null && this._endpointEqual(start, end)) {
            if (bounds !== '[]') {
                start = end = this._zeroEndpoint();
            }
            if (bounds === '(]' || bounds === '()')
                this.bounds = '[)';
        }
        else {
            if (start !== null && end !== null && end < start) {
                throw new Error('must have start <= end');
            }
            if (start === null && bounds[0] === '[') {
                bounds = '(' + bounds[1];
            }
            if (end === null && bounds[1] === ']') {
                bounds = bounds[0] + ')';
            }
        }
        this.start = start;
        this.end = end;
        this.bounds = bounds;
    }
    Range.isRange = function (candidate) {
        return candidate instanceof Range;
    };
    Range.register = function (ctr) {
        var rangeType = ctr.type.replace('_RANGE', '').toLowerCase();
        Range.classMap[rangeType] = ctr;
    };
    Range.fromJS = function (parameters) {
        var ctr;
        if (typeof parameters.start === 'number' || typeof parameters.end === 'number') {
            ctr = 'number';
        }
        else if (typeof parameters.start === 'string' || typeof parameters.end === 'string') {
            ctr = 'string';
        }
        else {
            ctr = 'time';
        }
        return Range.classMap[ctr].fromJS(parameters);
    };
    Range.prototype._zeroEndpoint = function () {
        return 0;
    };
    Range.prototype._endpointEqual = function (a, b) {
        return a === b;
    };
    Range.prototype._endpointToString = function (a) {
        return String(a);
    };
    Range.prototype._equalsHelper = function (other) {
        return Boolean(other) &&
            this.bounds === other.bounds &&
            this._endpointEqual(this.start, other.start) &&
            this._endpointEqual(this.end, other.end);
    };
    Range.prototype.toString = function () {
        var bounds = this.bounds;
        return '[' + (bounds[0] === '(' ? '~' : '') + this._endpointToString(this.start) + ',' + this._endpointToString(this.end) + (bounds[1] === ')' ? '' : '!') + ']';
    };
    Range.prototype.compare = function (other) {
        var myStart = this.start;
        var otherStart = other.start;
        return myStart < otherStart ? -1 : (otherStart < myStart ? 1 : 0);
    };
    Range.prototype.openStart = function () {
        return this.bounds[0] === '(';
    };
    Range.prototype.openEnd = function () {
        return this.bounds[1] === ')';
    };
    Range.prototype.empty = function () {
        return this._endpointEqual(this.start, this.end) && this.bounds === '[)';
    };
    Range.prototype.degenerate = function () {
        return this._endpointEqual(this.start, this.end) && this.bounds === '[]';
    };
    Range.prototype.contains = function (val) {
        if (val === null)
            return false;
        var start = this.start;
        var end = this.end;
        var bounds = this.bounds;
        if (bounds[0] === '[') {
            if (val < start)
                return false;
        }
        else {
            if (start !== null && val <= start)
                return false;
        }
        if (bounds[1] === ']') {
            if (end < val)
                return false;
        }
        else {
            if (end !== null && end <= val)
                return false;
        }
        return true;
    };
    Range.prototype.intersects = function (other) {
        return this.contains(other.start) || this.contains(other.end)
            || other.contains(this.start) || other.contains(this.end)
            || this._equalsHelper(other);
    };
    Range.prototype.adjacent = function (other) {
        return (this._endpointEqual(this.end, other.start) && this.openEnd() !== other.openStart())
            || (this._endpointEqual(this.start, other.end) && this.openStart() !== other.openEnd());
    };
    Range.prototype.mergeable = function (other) {
        return this.intersects(other) || this.adjacent(other);
    };
    Range.prototype.union = function (other) {
        if (!this.mergeable(other))
            return null;
        return this.extend(other);
    };
    Range.prototype.extent = function () {
        return this;
    };
    Range.prototype.extend = function (other) {
        var thisStart = this.start;
        var thisEnd = this.end;
        var otherStart = other.start;
        var otherEnd = other.end;
        var start;
        var startBound;
        if (thisStart === null || otherStart === null) {
            start = null;
            startBound = '(';
        }
        else if (thisStart < otherStart) {
            start = thisStart;
            startBound = this.bounds[0];
        }
        else {
            start = otherStart;
            startBound = other.bounds[0];
        }
        var end;
        var endBound;
        if (thisEnd === null || otherEnd === null) {
            end = null;
            endBound = ')';
        }
        else if (thisEnd < otherEnd) {
            end = otherEnd;
            endBound = other.bounds[1];
        }
        else {
            end = thisEnd;
            endBound = this.bounds[1];
        }
        return new this.constructor({ start: start, end: end, bounds: startBound + endBound });
    };
    Range.prototype.intersect = function (other) {
        if (!this.mergeable(other))
            return null;
        var thisStart = this.start;
        var thisEnd = this.end;
        var otherStart = other.start;
        var otherEnd = other.end;
        var start;
        var startBound;
        if (thisStart === null || otherStart === null) {
            if (otherStart === null) {
                start = thisStart;
                startBound = this.bounds[0];
            }
            else {
                start = otherStart;
                startBound = other.bounds[0];
            }
        }
        else if (otherStart < thisStart) {
            start = thisStart;
            startBound = this.bounds[0];
        }
        else {
            start = otherStart;
            startBound = other.bounds[0];
        }
        var end;
        var endBound;
        if (thisEnd === null || otherEnd === null) {
            if (thisEnd == null) {
                end = otherEnd;
                endBound = other.bounds[1];
            }
            else {
                end = thisEnd;
                endBound = this.bounds[1];
            }
        }
        else if (otherEnd < thisEnd) {
            end = otherEnd;
            endBound = other.bounds[1];
        }
        else {
            end = thisEnd;
            endBound = this.bounds[1];
        }
        return new this.constructor({ start: start, end: end, bounds: startBound + endBound });
    };
    Range.prototype.isFinite = function () {
        return this.start !== null && this.end !== null;
    };
    Range.DEFAULT_BOUNDS = '[)';
    Range.classMap = {};
    return Range;
}());
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

function finiteOrNull(n) {
    return (isNaN(n) || isFinite(n)) ? n : null;
}
var check;
var NumberRange = exports.NumberRange = (function (_super) {
    __extends(NumberRange, _super);
    function NumberRange(parameters) {
        if (isNaN(parameters.start))
            throw new TypeError('`start` must be a number');
        if (isNaN(parameters.end))
            throw new TypeError('`end` must be a number');
        _super.call(this, parameters.start, parameters.end, parameters.bounds);
    }
    NumberRange.isNumberRange = function (candidate) {
        return candidate instanceof NumberRange;
    };
    NumberRange.numberBucket = function (num, size, offset) {
        var start = Math.floor((num - offset) / size) * size + offset;
        return new NumberRange({
            start: start,
            end: start + size,
            bounds: Range.DEFAULT_BOUNDS
        });
    };
    NumberRange.fromNumber = function (n) {
        return new NumberRange({ start: n, end: n, bounds: '[]' });
    };
    NumberRange.fromJS = function (parameters) {
        if (typeof parameters !== "object") {
            throw new Error("unrecognizable numberRange");
        }
        var start = parameters.start;
        var end = parameters.end;
        return new NumberRange({
            start: start === null ? null : finiteOrNull(Number(start)),
            end: end === null ? null : finiteOrNull(Number(end)),
            bounds: parameters.bounds
        });
    };
    NumberRange.prototype.valueOf = function () {
        return {
            start: this.start,
            end: this.end,
            bounds: this.bounds
        };
    };
    NumberRange.prototype.toJS = function () {
        var js = {
            start: this.start,
            end: this.end
        };
        if (this.bounds !== Range.DEFAULT_BOUNDS)
            js.bounds = this.bounds;
        return js;
    };
    NumberRange.prototype.toJSON = function () {
        return this.toJS();
    };
    NumberRange.prototype.equals = function (other) {
        return other instanceof NumberRange && this._equalsHelper(other);
    };
    NumberRange.prototype.midpoint = function () {
        return (this.start + this.end) / 2;
    };
    NumberRange.type = 'NUMBER_RANGE';
    return NumberRange;
}(Range));
check = NumberRange;
Range.register(NumberRange);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



function toDate(date, name) {
    if (date === null)
        return null;
    if (typeof date === "undefined")
        throw new TypeError("timeRange must have a " + name);
    if (typeof date === 'string' || typeof date === 'number')
        date = parseISODate(date, Expression.defaultParserTimezone);
    if (!date.getDay)
        throw new TypeError("timeRange must have a " + name + " that is a Date");
    return date;
}
var START_OF_TIME = "1000";
var END_OF_TIME = "3000";
function dateToIntervalPart(date) {
    return date.toISOString()
        .replace('.000Z', 'Z')
        .replace(':00Z', 'Z')
        .replace(':00Z', 'Z');
}
var check;
var TimeRange = exports.TimeRange = (function (_super) {
    __extends(TimeRange, _super);
    function TimeRange(parameters) {
        _super.call(this, parameters.start, parameters.end, parameters.bounds);
    }
    TimeRange.isTimeRange = function (candidate) {
        return candidate instanceof TimeRange;
    };
    TimeRange.intervalFromDate = function (date) {
        return dateToIntervalPart(date) + '/' + dateToIntervalPart(new Date(date.valueOf() + 1));
    };
    TimeRange.timeBucket = function (date, duration, timezone) {
        if (!date)
            return null;
        var start = duration.floor(date, timezone);
        return new TimeRange({
            start: start,
            end: duration.shift(start, timezone, 1),
            bounds: Range.DEFAULT_BOUNDS
        });
    };
    TimeRange.fromTime = function (t) {
        return new TimeRange({ start: t, end: t, bounds: '[]' });
    };
    TimeRange.fromJS = function (parameters) {
        if (typeof parameters !== "object") {
            throw new Error("unrecognizable timeRange");
        }
        return new TimeRange({
            start: toDate(parameters.start, 'start'),
            end: toDate(parameters.end, 'end'),
            bounds: parameters.bounds
        });
    };
    TimeRange.prototype._zeroEndpoint = function () {
        return new Date(0);
    };
    TimeRange.prototype._endpointEqual = function (a, b) {
        if (a === null) {
            return b === null;
        }
        else {
            return b !== null && a.valueOf() === b.valueOf();
        }
    };
    TimeRange.prototype._endpointToString = function (a) {
        if (!a)
            return 'null';
        return a.toISOString();
    };
    TimeRange.prototype.valueOf = function () {
        return {
            start: this.start,
            end: this.end,
            bounds: this.bounds
        };
    };
    TimeRange.prototype.toJS = function () {
        var js = {
            start: this.start,
            end: this.end
        };
        if (this.bounds !== Range.DEFAULT_BOUNDS)
            js.bounds = this.bounds;
        return js;
    };
    TimeRange.prototype.toJSON = function () {
        return this.toJS();
    };
    TimeRange.prototype.equals = function (other) {
        return other instanceof TimeRange && this._equalsHelper(other);
    };
    TimeRange.prototype.toInterval = function () {
        var _a = this, start = _a.start, end = _a.end, bounds = _a.bounds;
        var interval = [START_OF_TIME, END_OF_TIME];
        if (start) {
            if (bounds[0] === '(')
                start = new Date(start.valueOf() + 1);
            interval[0] = dateToIntervalPart(start);
        }
        if (end) {
            if (bounds[1] === ']')
                end = new Date(end.valueOf() + 1);
            interval[1] = dateToIntervalPart(end);
        }
        return interval.join("/");
    };
    TimeRange.prototype.midpoint = function () {
        return new Date((this.start.valueOf() + this.end.valueOf()) / 2);
    };
    TimeRange.prototype.isAligned = function (duration, timezone) {
        var _a = this, start = _a.start, end = _a.end;
        return (!start || duration.isAligned(start, timezone)) && (!end || duration.isAligned(end, timezone));
    };
    TimeRange.type = 'TIME_RANGE';
    return TimeRange;
}(Range));
check = TimeRange;
Range.register(TimeRange);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var check;
var StringRange = exports.StringRange = (function (_super) {
    __extends(StringRange, _super);
    function StringRange(parameters) {
        var start = parameters.start, end = parameters.end;
        if (typeof start !== 'string' && start !== null)
            throw new TypeError('`start` must be a string');
        if (typeof end !== 'string' && end !== null)
            throw new TypeError('`end` must be a string');
        _super.call(this, start, end, parameters.bounds);
    }
    StringRange.isStringRange = function (candidate) {
        return candidate instanceof StringRange;
    };
    StringRange.fromString = function (s) {
        return new StringRange({ start: s, end: s, bounds: '[]' });
    };
    StringRange.fromJS = function (parameters) {
        if (typeof parameters !== "object") {
            throw new Error("unrecognizable StringRange");
        }
        var start = parameters.start;
        var end = parameters.end;
        var bounds = parameters.bounds;
        return new StringRange({
            start: start, end: end, bounds: bounds
        });
    };
    StringRange.prototype.valueOf = function () {
        return {
            start: this.start,
            end: this.end,
            bounds: this.bounds
        };
    };
    StringRange.prototype.toJS = function () {
        var js = {
            start: this.start,
            end: this.end
        };
        if (this.bounds !== Range.DEFAULT_BOUNDS)
            js.bounds = this.bounds;
        return js;
    };
    StringRange.prototype.toJSON = function () {
        return this.toJS();
    };
    StringRange.prototype.equals = function (other) {
        return other instanceof StringRange && this._equalsHelper(other);
    };
    StringRange.prototype.midpoint = function () {
        throw new Error("midpoint not supported in string range");
    };
    StringRange.prototype._zeroEndpoint = function () {
        return "";
    };
    StringRange.type = 'STRING_RANGE';
    return StringRange;
}(Range));
check = StringRange;
Range.register(StringRange);






function dateString(date) {
    return date.toISOString();
}
function arrayFromJS(xs, setType) {
    return xs.map(function (x) { return valueFromJS(x, setType); });
}
function unifyElements(elements) {
    var newElements = Object.create(null);
    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var accumulator = elements_1[_i];
        var newElementsKeys = Object.keys(newElements);
        for (var _a = 0, newElementsKeys_1 = newElementsKeys; _a < newElementsKeys_1.length; _a++) {
            var newElementsKey = newElementsKeys_1[_a];
            var newElement = newElements[newElementsKey];
            var unionElement = accumulator.union(newElement);
            if (unionElement) {
                accumulator = unionElement;
                delete newElements[newElementsKey];
            }
        }
        newElements[accumulator.toString()] = accumulator;
    }
    return Object.keys(newElements).map(function (k) { return newElements[k]; });
}
function intersectElements(elements1, elements2) {
    var newElements = [];
    for (var _i = 0, elements1_1 = elements1; _i < elements1_1.length; _i++) {
        var element1 = elements1_1[_i];
        for (var _a = 0, elements2_1 = elements2; _a < elements2_1.length; _a++) {
            var element2 = elements2_1[_a];
            var intersect = element1.intersect(element2);
            if (intersect)
                newElements.push(intersect);
        }
    }
    return newElements;
}
var typeUpgrades = {
    'NUMBER': 'NUMBER_RANGE',
    'TIME': 'TIME_RANGE',
    'STRING': 'STRING_RANGE'
};
var check;
var Set = exports.Set = (function () {
    function Set(parameters) {
        var setType = parameters.setType;
        this.setType = setType;
        var keyFn = setType === 'TIME' ? dateString : String;
        this.keyFn = keyFn;
        var elements = parameters.elements;
        var newElements = null;
        var hash = Object.create(null);
        for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            var key = keyFn(element);
            if (hash[key]) {
                if (!newElements)
                    newElements = elements.slice(0, i);
            }
            else {
                hash[key] = element;
                if (newElements)
                    newElements.push(element);
            }
        }
        if (newElements) {
            elements = newElements;
        }
        this.elements = elements;
        this.hash = hash;
    }
    Set.isSet = function (candidate) {
        return candidate instanceof Set;
    };
    Set.convertToSet = function (thing) {
        var thingType = getValueType(thing);
        if (isSetType(thingType))
            return thing;
        return Set.fromJS({ setType: thingType, elements: [thing] });
    };
    Set.generalUnion = function (a, b) {
        var aSet = Set.convertToSet(a);
        var bSet = Set.convertToSet(b);
        var aSetType = aSet.setType;
        var bSetType = bSet.setType;
        if (typeUpgrades[aSetType] === bSetType) {
            aSet = aSet.upgradeType();
        }
        else if (typeUpgrades[bSetType] === aSetType) {
            bSet = bSet.upgradeType();
        }
        else if (aSetType !== bSetType) {
            return null;
        }
        return aSet.union(bSet).simplify();
    };
    Set.generalIntersect = function (a, b) {
        var aSet = Set.convertToSet(a);
        var bSet = Set.convertToSet(b);
        var aSetType = aSet.setType;
        var bSetType = bSet.setType;
        if (typeUpgrades[aSetType] === bSetType) {
            aSet = aSet.upgradeType();
        }
        else if (typeUpgrades[bSetType] === aSetType) {
            bSet = bSet.upgradeType();
        }
        else if (aSetType !== bSetType) {
            return null;
        }
        return aSet.intersect(bSet).simplify();
    };
    Set.fromJS = function (parameters) {
        if (Array.isArray(parameters)) {
            parameters = { elements: parameters };
        }
        if (typeof parameters !== "object") {
            throw new Error("unrecognizable set");
        }
        var setType = parameters.setType;
        var elements = parameters.elements;
        if (!setType) {
            setType = getValueType(elements.length ? elements[0] : null);
        }
        return new Set({
            setType: setType,
            elements: arrayFromJS(elements, setType)
        });
    };
    Set.prototype.valueOf = function () {
        return {
            setType: this.setType,
            elements: this.elements
        };
    };
    Set.prototype.toJS = function () {
        return {
            setType: this.setType,
            elements: this.elements.map(valueToJS)
        };
    };
    Set.prototype.toJSON = function () {
        return this.toJS();
    };
    Set.prototype.toString = function () {
        if (this.setType === "NULL")
            return "null";
        return "" + this.elements.map(String).join(", ");
    };
    Set.prototype.equals = function (other) {
        return other instanceof Set &&
            this.setType === other.setType &&
            this.elements.length === other.elements.length &&
            this.elements.slice().sort().join('') === other.elements.slice().sort().join('');
    };
    Set.prototype.changeElements = function (elements) {
        var value = this.valueOf();
        value.elements = elements;
        return new Set(value);
    };
    Set.prototype.cardinality = function () {
        return this.size();
    };
    Set.prototype.size = function () {
        return this.elements.length;
    };
    Set.prototype.empty = function () {
        return this.elements.length === 0;
    };
    Set.prototype.isNullSet = function () {
        return this.setType === 'NULL';
    };
    Set.prototype.unifyElements = function () {
        var setType = this.setType;
        if (setType === 'NUMBER_RANGE' || setType === 'TIME_RANGE' || setType === 'STRING_RANGE') {
            var value = this.valueOf();
            value.elements = unifyElements(value.elements);
            return new Set(value);
        }
        return this;
    };
    Set.prototype.simplify = function () {
        var simpleSet = this.downgradeType();
        var simpleSetElements = simpleSet.elements;
        return simpleSetElements.length === 1 ? simpleSetElements[0] : simpleSet;
    };
    Set.prototype.getType = function () {
        return ('SET/' + this.setType);
    };
    Set.prototype.upgradeType = function () {
        if (this.setType === 'NUMBER') {
            return Set.fromJS({
                setType: 'NUMBER_RANGE',
                elements: this.elements.map(NumberRange.fromNumber)
            });
        }
        else if (this.setType === 'TIME') {
            return Set.fromJS({
                setType: 'TIME_RANGE',
                elements: this.elements.map(TimeRange.fromTime)
            });
        }
        else if (this.setType === 'STRING') {
            return Set.fromJS({
                setType: 'STRING_RANGE',
                elements: this.elements.map(StringRange.fromString)
            });
        }
        else {
            return this;
        }
    };
    Set.prototype.downgradeType = function () {
        if (this.setType === 'NUMBER_RANGE' || this.setType === 'TIME_RANGE' || this.setType === 'STRING_RANGE') {
            var elements = this.elements;
            var simpleElements = [];
            for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
                var element = elements_2[_i];
                if (element.degenerate()) {
                    simpleElements.push(element.start);
                }
                else {
                    return this;
                }
            }
            return Set.fromJS(simpleElements);
        }
        else {
            return this;
        }
    };
    Set.prototype.extent = function () {
        var setType = this.setType;
        if (hasOwnProperty(typeUpgrades, setType)) {
            return this.upgradeType().extent();
        }
        if (setType !== 'NUMBER_RANGE' && setType !== 'TIME_RANGE' && setType !== 'STRING_RANGE')
            return null;
        var elements = this.elements;
        var extent = elements[0] || null;
        for (var i = 1; i < elements.length; i++) {
            extent = extent.extend(elements[i]);
        }
        return extent;
    };
    Set.prototype.union = function (other) {
        if (this.empty())
            return other;
        if (other.empty())
            return this;
        if (this.setType !== other.setType) {
            throw new TypeError("can not union sets of different types");
        }
        var newElements = this.elements.slice();
        var otherElements = other.elements;
        for (var _i = 0, otherElements_1 = otherElements; _i < otherElements_1.length; _i++) {
            var el = otherElements_1[_i];
            if (this.contains(el))
                continue;
            newElements.push(el);
        }
        return new Set({
            setType: this.setType,
            elements: newElements
        }).unifyElements();
    };
    Set.prototype.intersect = function (other) {
        if (this.empty() || other.empty())
            return Set.EMPTY;
        var setType = this.setType;
        if (this.setType !== other.setType) {
            throw new TypeError("can not intersect sets of different types");
        }
        var thisElements = this.elements;
        var newElements;
        if (setType === 'NUMBER_RANGE' || setType === 'TIME_RANGE' || setType === 'STRING_RANGE') {
            var otherElements = other.elements;
            newElements = intersectElements(thisElements, otherElements);
        }
        else {
            newElements = [];
            for (var _i = 0, thisElements_1 = thisElements; _i < thisElements_1.length; _i++) {
                var el = thisElements_1[_i];
                if (!other.contains(el))
                    continue;
                newElements.push(el);
            }
        }
        return new Set({
            setType: this.setType,
            elements: newElements
        });
    };
    Set.prototype.overlap = function (other) {
        if (this.empty() || other.empty())
            return false;
        if (this.setType !== other.setType) {
            throw new TypeError("can determine overlap sets of different types");
        }
        var thisElements = this.elements;
        for (var _i = 0, thisElements_2 = thisElements; _i < thisElements_2.length; _i++) {
            var el = thisElements_2[_i];
            if (!other.contains(el))
                continue;
            return true;
        }
        return false;
    };
    Set.prototype.contains = function (value) {
        var setType = this.setType;
        if ((setType === 'NUMBER_RANGE' && typeof value === 'number')
            || (setType === 'TIME_RANGE' && isDate(value))
            || (setType === 'STRING_RANGE' && typeof value === 'string')) {
            return this.containsWithin(value);
        }
        return hasOwnProperty(this.hash, this.keyFn(value));
    };
    Set.prototype.containsWithin = function (value) {
        var elements = this.elements;
        for (var k in elements) {
            if (!hasOwnProperty(elements, k))
                continue;
            if (elements[k].contains(value))
                return true;
        }
        return false;
    };
    Set.prototype.add = function (value) {
        var setType = this.setType;
        var valueType = getValueType(value);
        if (setType === 'NULL')
            setType = valueType;
        if (valueType !== 'NULL' && setType !== valueType)
            throw new Error('value type must match');
        if (this.contains(value))
            return this;
        return new Set({
            setType: setType,
            elements: this.elements.concat([value])
        });
    };
    Set.prototype.remove = function (value) {
        if (!this.contains(value))
            return this;
        var keyFn = this.keyFn;
        var key = keyFn(value);
        return new Set({
            setType: this.setType,
            elements: this.elements.filter(function (element) { return keyFn(element) !== key; })
        });
    };
    Set.prototype.toggle = function (value) {
        return this.contains(value) ? this.remove(value) : this.add(value);
    };
    Set.type = 'SET';
    return Set;
}());
check = Set;
Set.EMPTY = Set.fromJS([]);











var fillExpressionExternalAlteration = exports.fillExpressionExternalAlteration = function(alteration, filler) {
    for (var k in alteration) {
        var thing = alteration[k];
        if (Array.isArray(thing)) {
            fillDatasetExternalAlterations(thing, filler);
        }
        else {
            thing.result = filler(thing.external, Boolean(thing.terminal));
        }
    }
}
var fillDatasetExternalAlterations = exports.fillDatasetExternalAlterations = function(alterations, filler) {
    for (var _i = 0, alterations_1 = alterations; _i < alterations_1.length; _i++) {
        var alteration = alterations_1[_i];
        if (alteration.external) {
            alteration.result = filler(alteration.external, alteration.terminal);
        }
        else if (alteration.datasetAlterations) {
            fillDatasetExternalAlterations(alteration.datasetAlterations, filler);
        }
        else if (alteration.expressionAlterations) {
            fillExpressionExternalAlteration(alteration.expressionAlterations, filler);
        }
        else {
            throw new Error('fell through');
        }
    }
}
var directionFns = {
    ascending: function (a, b) {
        if (a == null) {
            return b == null ? 0 : -1;
        }
        else {
            if (a.compare)
                return a.compare(b);
            if (b == null)
                return 1;
        }
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    },
    descending: function (a, b) {
        if (b == null) {
            return a == null ? 0 : -1;
        }
        else {
            if (b.compare)
                return b.compare(a);
            if (a == null)
                return 1;
        }
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }
};
function uniqueColumns(columns) {
    var seen = {};
    var uniqueColumns = [];
    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
        var column = columns_1[_i];
        if (!seen[column.name]) {
            uniqueColumns.push(column);
            seen[column.name] = true;
        }
    }
    return uniqueColumns;
}
function flattenColumns(nestedColumns, prefixColumns) {
    var flatColumns = [];
    var i = 0;
    var prefixString = '';
    while (i < nestedColumns.length) {
        var nestedColumn = nestedColumns[i];
        if (nestedColumn.type === 'DATASET') {
            nestedColumns = nestedColumn.columns;
            if (prefixColumns)
                prefixString += nestedColumn.name + '.';
            i = 0;
        }
        else {
            flatColumns.push({
                name: prefixString + nestedColumn.name,
                type: nestedColumn.type
            });
            i++;
        }
    }
    return uniqueColumns(flatColumns);
}
function removeLineBreaks(v) {
    return v.replace(/(?:\r\n|\r|\n)/g, ' ');
}
var escapeFnCSV = function (v) {
    v = removeLineBreaks(v);
    if (v.indexOf('"') === -1 && v.indexOf(",") === -1)
        return v;
    return "\"" + v.replace(/"/g, '""') + "\"";
};
var escapeFnTSV = function (v) {
    return removeLineBreaks(v).replace(/\t/g, "").replace(/"/g, '""');
};
var typeOrder = {
    'NULL': 0,
    'TIME': 1,
    'TIME_RANGE': 2,
    'SET/TIME': 3,
    'SET/TIME_RANGE': 4,
    'STRING': 5,
    'SET/STRING': 6,
    'BOOLEAN': 7,
    'NUMBER': 8,
    'NUMBER_RANGE': 9,
    'SET/NUMBER': 10,
    'SET/NUMBER_RANGE': 11,
    'DATASET': 12
};
var defaultFormatter = {
    'NULL': function (v) { return 'NULL'; },
    'TIME': function (v) { return v.toISOString(); },
    'TIME_RANGE': function (v) { return '' + v; },
    'SET/TIME': function (v) { return '' + v; },
    'SET/TIME_RANGE': function (v) { return '' + v; },
    'STRING': function (v) { return '' + v; },
    'SET/STRING': function (v) { return '' + v; },
    'BOOLEAN': function (v) { return '' + v; },
    'NUMBER': function (v) { return '' + v; },
    'NUMBER_RANGE': function (v) { return '' + v; },
    'SET/NUMBER': function (v) { return '' + v; },
    'SET/NUMBER_RANGE': function (v) { return '' + v; },
    'DATASET': function (v) { return 'DATASET'; }
};
function isBoolean(b) {
    return b === true || b === false;
}
function isNumber(n) {
    return n !== null && !isNaN(Number(n));
}
function isString(str) {
    return typeof str === "string";
}
function getAttributeInfo(name, attributeValue) {
    if (attributeValue == null)
        return null;
    if (isDate(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'TIME' });
    }
    else if (isBoolean(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'BOOLEAN' });
    }
    else if (isNumber(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'NUMBER' });
    }
    else if (isString(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'STRING' });
    }
    else if (attributeValue instanceof NumberRange) {
        return new AttributeInfo({ name: name, type: 'NUMBER_RANGE' });
    }
    else if (attributeValue instanceof StringRange) {
        return new AttributeInfo({ name: name, type: 'STRING_RANGE' });
    }
    else if (attributeValue instanceof TimeRange) {
        return new AttributeInfo({ name: name, type: 'TIME_RANGE' });
    }
    else if (attributeValue instanceof Set) {
        return new AttributeInfo({ name: name, type: attributeValue.getType() });
    }
    else if (attributeValue instanceof Dataset) {
        return new AttributeInfo({ name: name, type: 'DATASET', datasetType: attributeValue.getFullType().datasetType });
    }
    else {
        throw new Error("Could not introspect " + attributeValue);
    }
}
function joinDatums(datumA, datumB) {
    var newDatum = Object.create(null);
    for (var k in datumA) {
        newDatum[k] = datumA[k];
    }
    for (var k in datumB) {
        newDatum[k] = datumB[k];
    }
    return newDatum;
}
function copy(obj) {
    var newObj = {};
    var k;
    for (k in obj) {
        if (hasOwnProperty(obj, k))
            newObj[k] = obj[k];
    }
    return newObj;
}
var check;
var Dataset = exports.Dataset = (function () {
    function Dataset(parameters) {
        this.attributes = null;
        this.keys = null;
        if (parameters.suppress === true)
            this.suppress = true;
        if (parameters.keys) {
            this.keys = parameters.keys;
        }
        var data = parameters.data;
        if (!Array.isArray(data)) {
            throw new TypeError("must have a `data` array");
        }
        this.data = data;
        var attributes = parameters.attributes;
        if (!attributes)
            attributes = Dataset.getAttributesFromData(data);
        var attributeOverrides = parameters.attributeOverrides;
        if (attributeOverrides) {
            attributes = AttributeInfo.override(attributes, attributeOverrides);
        }
        this.attributes = attributes;
    }
    Dataset.isDataset = function (candidate) {
        return candidate instanceof Dataset;
    };
    Dataset.datumFromJS = function (js) {
        if (typeof js !== 'object')
            throw new TypeError("datum must be an object");
        var datum = Object.create(null);
        for (var k in js) {
            if (!hasOwnProperty(js, k))
                continue;
            datum[k] = valueFromJS(js[k]);
        }
        return datum;
    };
    Dataset.datumToJS = function (datum) {
        var js = {};
        for (var k in datum) {
            var v = datum[k];
            if (v && v.suppress)
                continue;
            js[k] = valueToJSInlineType(v);
        }
        return js;
    };
    Dataset.getAttributesFromData = function (data) {
        if (!data.length)
            return [];
        var attributeNamesToIntrospect = Object.keys(data[0]);
        var attributes = [];
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var datum = data_1[_i];
            var attributeNamesStillToIntrospect = [];
            for (var _a = 0, attributeNamesToIntrospect_1 = attributeNamesToIntrospect; _a < attributeNamesToIntrospect_1.length; _a++) {
                var attributeNameToIntrospect = attributeNamesToIntrospect_1[_a];
                var attributeInfo = getAttributeInfo(attributeNameToIntrospect, datum[attributeNameToIntrospect]);
                if (attributeInfo) {
                    attributes.push(attributeInfo);
                }
                else {
                    attributeNamesStillToIntrospect.push(attributeNameToIntrospect);
                }
            }
            attributeNamesToIntrospect = attributeNamesStillToIntrospect;
            if (!attributeNamesToIntrospect.length)
                break;
        }
        for (var _b = 0, attributeNamesToIntrospect_2 = attributeNamesToIntrospect; _b < attributeNamesToIntrospect_2.length; _b++) {
            var attributeName = attributeNamesToIntrospect_2[_b];
            attributes.push(new AttributeInfo({ name: attributeName, type: 'STRING' }));
        }
        attributes.sort(function (a, b) {
            var typeDiff = typeOrder[a.type] - typeOrder[b.type];
            if (typeDiff)
                return typeDiff;
            return a.name.localeCompare(b.name);
        });
        return attributes;
    };
    Dataset.parseJSON = function (text) {
        text = text.trim();
        var firstChar = text[0];
        if (firstChar[0] === '[') {
            try {
                return JSON.parse(text);
            }
            catch (e) {
                throw new Error("could not parse");
            }
        }
        else if (firstChar[0] === '{') {
            return text.split(/\r?\n/).map(function (line, i) {
                try {
                    return JSON.parse(line);
                }
                catch (e) {
                    throw new Error("problem in line: " + i + ": '" + line + "'");
                }
            });
        }
        else {
            throw new Error("Unsupported start, starts with '" + firstChar[0] + "'");
        }
    };
    Dataset.fromJS = function (parameters) {
        if (Array.isArray(parameters)) {
            parameters = { data: parameters };
        }
        if (!Array.isArray(parameters.data)) {
            throw new Error('must have data');
        }
        var value = {};
        if (hasOwnProperty(parameters, 'attributes')) {
            value.attributes = AttributeInfo.fromJSs(parameters.attributes);
        }
        else if (hasOwnProperty(parameters, 'attributeOverrides')) {
            value.attributeOverrides = AttributeInfo.fromJSs(parameters.attributeOverrides);
        }
        value.keys = parameters.keys;
        value.data = parameters.data.map(Dataset.datumFromJS);
        return new Dataset(value);
    };
    Dataset.prototype.valueOf = function () {
        var value = {};
        if (this.suppress)
            value.suppress = true;
        if (this.attributes)
            value.attributes = this.attributes;
        if (this.keys)
            value.keys = this.keys;
        value.data = this.data;
        return value;
    };
    Dataset.prototype.toJS = function () {
        return this.data.map(Dataset.datumToJS);
    };
    Dataset.prototype.toString = function () {
        return "Dataset(" + this.data.length + ")";
    };
    Dataset.prototype.toJSON = function () {
        return this.toJS();
    };
    Dataset.prototype.equals = function (other) {
        return other instanceof Dataset &&
            this.data.length === other.data.length;
    };
    Dataset.prototype.hide = function () {
        var value = this.valueOf();
        value.suppress = true;
        return new Dataset(value);
    };
    Dataset.prototype.basis = function () {
        var data = this.data;
        return data.length === 1 && Object.keys(data[0]).length === 0;
    };
    Dataset.prototype.hasExternal = function () {
        if (!this.data.length)
            return false;
        return datumHasExternal(this.data[0]);
    };
    Dataset.prototype.getFullType = function () {
        var attributes = this.attributes;
        if (!attributes)
            throw new Error("dataset has not been introspected");
        var myDatasetType = {};
        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
            var attribute = attributes_1[_i];
            var attrName = attribute.name;
            if (attribute.type === 'DATASET') {
                myDatasetType[attrName] = {
                    type: 'DATASET',
                    datasetType: attribute.datasetType
                };
            }
            else {
                myDatasetType[attrName] = {
                    type: attribute.type
                };
            }
        }
        return {
            type: 'DATASET',
            datasetType: myDatasetType
        };
    };
    Dataset.prototype.select = function (attrs) {
        var attributes = this.attributes;
        var newAttributes = [];
        var attrLookup = Object.create(null);
        for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
            var attr = attrs_1[_i];
            attrLookup[attr] = true;
            var existingAttribute = NamedArray.get(attributes, attr);
            if (existingAttribute)
                newAttributes.push(existingAttribute);
        }
        var data = this.data;
        var n = data.length;
        var newData = new Array(n);
        for (var i = 0; i < n; i++) {
            var datum = data[i];
            var newDatum = Object.create(null);
            for (var key in datum) {
                if (attrLookup[key]) {
                    newDatum[key] = datum[key];
                }
            }
            newData[i] = newDatum;
        }
        var value = this.valueOf();
        value.attributes = newAttributes;
        value.data = newData;
        return new Dataset(value);
    };
    Dataset.prototype.apply = function (name, ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#apply now takes Expressions use Dataset.applyFn instead");
            return this.applyFn(name, ex, arguments[2]);
        }
        return this.applyFn(name, ex.getFn(), ex.type);
    };
    Dataset.prototype.applyFn = function (name, exFn, type) {
        var data = this.data;
        var n = data.length;
        var newData = new Array(n);
        for (var i = 0; i < n; i++) {
            var datum = data[i];
            var newDatum = Object.create(null);
            for (var key in datum)
                newDatum[key] = datum[key];
            newDatum[name] = exFn(datum);
            newData[i] = newDatum;
        }
        var datasetType = null;
        if (type === 'DATASET' && newData[0] && newData[0][name]) {
            var thing = newData[0][name];
            if (thing instanceof Dataset) {
                datasetType = thing.getFullType().datasetType;
            }
            else {
                datasetType = {};
            }
        }
        var value = this.valueOf();
        value.attributes = NamedArray.overrideByName(value.attributes, new AttributeInfo({ name: name, type: type, datasetType: datasetType }));
        value.data = newData;
        return new Dataset(value);
    };
    Dataset.prototype.filter = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#filter now takes Expressions use Dataset.filterFn instead");
            return this.filterFn(ex);
        }
        return this.filterFn(ex.getFn());
    };
    Dataset.prototype.filterFn = function (exFn) {
        var value = this.valueOf();
        value.data = value.data.filter(function (datum) { return exFn(datum); });
        return new Dataset(value);
    };
    Dataset.prototype.sort = function (ex, direction) {
        if (typeof ex === 'function') {
            console.warn("Dataset#sort now takes Expressions use Dataset.sortFn instead");
            return this.sortFn(ex, direction);
        }
        return this.sortFn(ex.getFn(), direction);
    };
    Dataset.prototype.sortFn = function (exFn, direction) {
        var value = this.valueOf();
        var directionFn = directionFns[direction];
        value.data = this.data.slice().sort(function (a, b) {
            return directionFn(exFn(a), exFn(b));
        });
        return new Dataset(value);
    };
    Dataset.prototype.limit = function (limit) {
        var data = this.data;
        if (data.length <= limit)
            return this;
        var value = this.valueOf();
        value.data = data.slice(0, limit);
        return new Dataset(value);
    };
    Dataset.prototype.count = function () {
        return this.data.length;
    };
    Dataset.prototype.sum = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#sum now takes Expressions use Dataset.sumFn instead");
            return this.sumFn(ex);
        }
        return this.sumFn(ex.getFn());
    };
    Dataset.prototype.sumFn = function (exFn) {
        var data = this.data;
        var sum = 0;
        for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
            var datum = data_2[_i];
            sum += exFn(datum);
        }
        return sum;
    };
    Dataset.prototype.average = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#average now takes Expressions use Dataset.averageFn instead");
            return this.averageFn(ex);
        }
        return this.averageFn(ex.getFn());
    };
    Dataset.prototype.averageFn = function (exFn) {
        var count = this.count();
        return count ? (this.sumFn(exFn) / count) : null;
    };
    Dataset.prototype.min = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#min now takes Expressions use Dataset.minFn instead");
            return this.minFn(ex);
        }
        return this.minFn(ex.getFn());
    };
    Dataset.prototype.minFn = function (exFn) {
        var data = this.data;
        var min = Infinity;
        for (var _i = 0, data_3 = data; _i < data_3.length; _i++) {
            var datum = data_3[_i];
            var v = exFn(datum);
            if (v < min)
                min = v;
        }
        return min;
    };
    Dataset.prototype.max = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#max now takes Expressions use Dataset.maxFn instead");
            return this.maxFn(ex);
        }
        return this.maxFn(ex.getFn());
    };
    Dataset.prototype.maxFn = function (exFn) {
        var data = this.data;
        var max = -Infinity;
        for (var _i = 0, data_4 = data; _i < data_4.length; _i++) {
            var datum = data_4[_i];
            var v = exFn(datum);
            if (max < v)
                max = v;
        }
        return max;
    };
    Dataset.prototype.countDistinct = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#countDistinct now takes Expressions use Dataset.countDistinctFn instead");
            return this.countDistinctFn(ex);
        }
        return this.countDistinctFn(ex.getFn());
    };
    Dataset.prototype.countDistinctFn = function (exFn) {
        var data = this.data;
        var seen = Object.create(null);
        var count = 0;
        for (var _i = 0, data_5 = data; _i < data_5.length; _i++) {
            var datum = data_5[_i];
            var v = exFn(datum);
            if (!seen[v]) {
                seen[v] = 1;
                ++count;
            }
        }
        return count;
    };
    Dataset.prototype.quantile = function (ex, quantile) {
        if (typeof ex === 'function') {
            console.warn("Dataset#quantile now takes Expressions use Dataset.quantileFn instead");
            return this.quantileFn(ex, quantile);
        }
        return this.quantileFn(ex.getFn(), quantile);
    };
    Dataset.prototype.quantileFn = function (exFn, quantile) {
        var data = this.data;
        var vs = [];
        for (var _i = 0, data_6 = data; _i < data_6.length; _i++) {
            var datum = data_6[_i];
            var v = exFn(datum);
            if (v != null)
                vs.push(v);
        }
        vs.sort(function (a, b) { return a - b; });
        var n = vs.length;
        if (quantile === 0)
            return vs[0];
        if (quantile === 1)
            return vs[n - 1];
        var rank = n * quantile - 1;
        if (rank === Math.floor(rank)) {
            return (vs[rank] + vs[rank + 1]) / 2;
        }
        else {
            return vs[Math.ceil(rank)];
        }
    };
    Dataset.prototype.collect = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#collect now takes Expressions use Dataset.collectFn instead");
            return this.collectFn(ex);
        }
        return this.collectFn(ex.getFn());
    };
    Dataset.prototype.collectFn = function (exFn) {
        return Set.fromJS(this.data.map(exFn));
    };
    Dataset.prototype.split = function (splits, datasetName) {
        var splitFns = {};
        for (var k in splits) {
            var ex = splits[k];
            if (typeof ex === 'function') {
                console.warn("Dataset#collect now takes Expressions use Dataset.collectFn instead");
                return this.split(splits, datasetName);
            }
            splitFns[k] = ex.getFn();
        }
        return this.splitFn(splitFns, datasetName);
    };
    Dataset.prototype.splitFn = function (splitFns, datasetName) {
        var _a = this, data = _a.data, attributes = _a.attributes;
        var keys = Object.keys(splitFns);
        var numberOfKeys = keys.length;
        var splitFnList = keys.map(function (k) { return splitFns[k]; });
        var splits = {};
        var datumGroups = {};
        var finalData = [];
        var finalDataset = [];
        function addDatum(datum, valueList) {
            var key = valueList.join(';_PLYw00d_;');
            if (hasOwnProperty(datumGroups, key)) {
                datumGroups[key].push(datum);
            }
            else {
                var newDatum = Object.create(null);
                for (var i = 0; i < numberOfKeys; i++) {
                    newDatum[keys[i]] = valueList[i];
                }
                finalDataset.push(datumGroups[key] = [datum]);
                splits[key] = newDatum;
                finalData.push(newDatum);
            }
        }
        var _loop_1 = function(datum) {
            var valueList = splitFnList.map(function (splitFn) { return splitFn(datum); });
            var setIndex = -1;
            for (var i = 0; i < valueList.length; i++) {
                if (Set.isSet(valueList[i])) {
                    if (setIndex !== -1)
                        throw new Error("only one SET value is supported in native split for now");
                    setIndex = i;
                }
            }
            if (setIndex !== -1) {
                var elements = valueList[setIndex].elements;
                var atomicValueList = valueList.slice();
                for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                    var element = elements_1[_i];
                    atomicValueList[setIndex] = element;
                    addDatum(datum, atomicValueList);
                }
            }
            else {
                addDatum(datum, valueList);
            }
        };
        for (var _b = 0, data_7 = data; _b < data_7.length; _b++) {
            var datum = data_7[_b];
            _loop_1(datum);
        }
        for (var i = 0; i < finalData.length; i++) {
            finalData[i][datasetName] = new Dataset({
                suppress: true,
                attributes: attributes,
                data: finalDataset[i]
            });
        }
        return new Dataset({
            keys: keys,
            data: finalData
        });
    };
    Dataset.prototype.introspect = function () {
        console.error('introspection is always done, `.introspect()` method never needs to be called');
    };
    Dataset.prototype.getReadyExternals = function () {
        var externalAlterations = [];
        var _a = this, data = _a.data, attributes = _a.attributes;
        for (var i = 0; i < data.length; i++) {
            var datum = data[i];
            var normalExternalAlterations = [];
            var valueExternalAlterations = [];
            for (var _i = 0, attributes_2 = attributes; _i < attributes_2.length; _i++) {
                var attribute = attributes_2[_i];
                var value = datum[attribute.name];
                if (value instanceof Expression) {
                    var subExpressionAlterations = value.getReadyExternals();
                    if (Object.keys(subExpressionAlterations).length) {
                        normalExternalAlterations.push({
                            index: i,
                            key: attribute.name,
                            expressionAlterations: subExpressionAlterations
                        });
                    }
                }
                else if (value instanceof Dataset) {
                    var subDatasetAlterations = value.getReadyExternals();
                    if (subDatasetAlterations.length) {
                        normalExternalAlterations.push({
                            index: i,
                            key: attribute.name,
                            datasetAlterations: subDatasetAlterations
                        });
                    }
                }
                else if (value instanceof External) {
                    if (!value.suppress) {
                        var externalAlteration = {
                            index: i,
                            key: attribute.name,
                            external: value,
                            terminal: true
                        };
                        if (value.mode === 'value') {
                            valueExternalAlterations.push(externalAlteration);
                        }
                        else {
                            normalExternalAlterations.push(externalAlteration);
                        }
                    }
                }
            }
            if (valueExternalAlterations.length) {
                if (valueExternalAlterations.length === 1) {
                    externalAlterations.push(valueExternalAlterations[0]);
                }
                else {
                    externalAlterations.push({
                        index: i,
                        key: '',
                        external: External.uniteValueExternalsIntoTotal(valueExternalAlterations)
                    });
                }
            }
            if (normalExternalAlterations.length) {
                Array.prototype.push.apply(externalAlterations, normalExternalAlterations);
            }
        }
        return externalAlterations;
    };
    Dataset.prototype.applyReadyExternals = function (alterations) {
        var data = this.data;
        for (var _i = 0, alterations_2 = alterations; _i < alterations_2.length; _i++) {
            var alteration = alterations_2[_i];
            var datum = data[alteration.index];
            var key = alteration.key;
            if (alteration.external) {
                var result = alteration.result;
                if (result instanceof TotalContainer) {
                    var resultDatum = result.datum;
                    for (var k in resultDatum) {
                        datum[k] = resultDatum[k];
                    }
                }
                else {
                    datum[key] = result;
                }
            }
            else if (alteration.datasetAlterations) {
                datum[key] = datum[key].applyReadyExternals(alteration.datasetAlterations);
            }
            else if (alteration.expressionAlterations) {
                var exAlt = datum[key].applyReadyExternals(alteration.expressionAlterations);
                if (exAlt instanceof ExternalExpression) {
                    datum[key] = exAlt.external;
                }
                else if (exAlt instanceof LiteralExpression) {
                    datum[key] = exAlt.getLiteralValue();
                }
                else {
                    datum[key] = exAlt;
                }
            }
            else {
                throw new Error('fell through');
            }
        }
        for (var _a = 0, data_8 = data; _a < data_8.length; _a++) {
            var datum = data_8[_a];
            for (var key in datum) {
                var v = datum[key];
                if (v instanceof Expression) {
                    var simp = v.resolve(datum).simplify();
                    datum[key] = simp instanceof ExternalExpression ? simp.external : simp;
                }
            }
        }
        var value = this.valueOf();
        value.data = data;
        return new Dataset(value);
    };
    Dataset.prototype.join = function (other) {
        if (!other)
            return this;
        var thisKey = this.keys[0];
        if (!thisKey)
            throw new Error('join lhs must have a key (be a product of a split)');
        var otherKey = other.keys[0];
        if (!otherKey)
            throw new Error('join rhs must have a key (be a product of a split)');
        var thisData = this.data;
        var otherData = other.data;
        var k;
        var mapping = Object.create(null);
        for (var i = 0; i < thisData.length; i++) {
            var datum = thisData[i];
            k = String(thisKey ? datum[thisKey] : i);
            mapping[k] = [datum];
        }
        for (var i = 0; i < otherData.length; i++) {
            var datum = otherData[i];
            k = String(otherKey ? datum[otherKey] : i);
            if (!mapping[k])
                mapping[k] = [];
            mapping[k].push(datum);
        }
        var newData = [];
        for (var j in mapping) {
            var datums = mapping[j];
            if (datums.length === 1) {
                newData.push(datums[0]);
            }
            else {
                newData.push(joinDatums(datums[0], datums[1]));
            }
        }
        return new Dataset({ data: newData });
    };
    Dataset.prototype.findDatumByAttribute = function (attribute, value) {
        return SimpleArray.find(this.data, function (d) { return generalEqual(d[attribute], value); });
    };
    Dataset.prototype.getNestedColumns = function () {
        var nestedColumns = [];
        var attributes = this.attributes;
        var subDatasetAdded = false;
        for (var _i = 0, attributes_3 = attributes; _i < attributes_3.length; _i++) {
            var attribute = attributes_3[_i];
            var column = {
                name: attribute.name,
                type: attribute.type
            };
            if (attribute.type === 'DATASET') {
                var subDataset = this.data[0][attribute.name];
                if (!subDatasetAdded && subDataset instanceof Dataset) {
                    subDatasetAdded = true;
                    column.columns = subDataset.getNestedColumns();
                    nestedColumns.push(column);
                }
            }
            else {
                nestedColumns.push(column);
            }
        }
        return nestedColumns;
    };
    Dataset.prototype.getColumns = function (options) {
        if (options === void 0) { options = {}; }
        var prefixColumns = options.prefixColumns;
        return flattenColumns(this.getNestedColumns(), prefixColumns);
    };
    Dataset.prototype._flattenHelper = function (nestedColumns, prefix, order, nestingName, parentName, nesting, context, flat) {
        var nestedColumnsLength = nestedColumns.length;
        if (!nestedColumnsLength)
            return;
        var data = this.data;
        var datasetColumn = nestedColumns.filter(function (nestedColumn) { return nestedColumn.type === 'DATASET'; })[0];
        for (var _i = 0, data_9 = data; _i < data_9.length; _i++) {
            var datum = data_9[_i];
            var flatDatum = context ? copy(context) : {};
            if (nestingName)
                flatDatum[nestingName] = nesting;
            if (parentName)
                flatDatum[parentName] = context;
            for (var _a = 0, nestedColumns_1 = nestedColumns; _a < nestedColumns_1.length; _a++) {
                var flattenedColumn = nestedColumns_1[_a];
                if (flattenedColumn.type === 'DATASET')
                    continue;
                var flatName = (prefix !== null ? prefix : '') + flattenedColumn.name;
                flatDatum[flatName] = datum[flattenedColumn.name];
            }
            if (datasetColumn) {
                var nextPrefix = null;
                if (prefix !== null)
                    nextPrefix = prefix + datasetColumn.name + '.';
                if (order === 'preorder')
                    flat.push(flatDatum);
                datum[datasetColumn.name]._flattenHelper(datasetColumn.columns, nextPrefix, order, nestingName, parentName, nesting + 1, flatDatum, flat);
                if (order === 'postorder')
                    flat.push(flatDatum);
            }
            if (!datasetColumn)
                flat.push(flatDatum);
        }
    };
    Dataset.prototype.flatten = function (options) {
        if (options === void 0) { options = {}; }
        var prefixColumns = options.prefixColumns;
        var order = options.order;
        var nestingName = options.nestingName;
        var parentName = options.parentName;
        var nestedColumns = this.getNestedColumns();
        var flatData = [];
        if (nestedColumns.length) {
            this._flattenHelper(nestedColumns, (prefixColumns ? '' : null), order, nestingName, parentName, 0, null, flatData);
        }
        return flatData;
    };
    Dataset.prototype.toTabular = function (tabulatorOptions) {
        var formatter = tabulatorOptions.formatter || {};
        var finalizer = tabulatorOptions.finalizer;
        var data = this.flatten(tabulatorOptions);
        var columns = this.getColumns(tabulatorOptions);
        var lines = [];
        lines.push(columns.map(function (c) { return c.name; }).join(tabulatorOptions.separator || ','));
        var _loop_2 = function(i) {
            var datum = data[i];
            lines.push(columns.map(function (c) {
                var value = datum[c.name];
                var formatted = String((formatter[c.type] || defaultFormatter[c.type])(value));
                var finalized = formatted && finalizer ? finalizer(formatted) : formatted;
                return finalized;
            }).join(tabulatorOptions.separator || ','));
        };
        for (var i = 0; i < data.length; i++) {
            _loop_2(i);
        }
        var lineBreak = tabulatorOptions.lineBreak || '\n';
        return lines.join(lineBreak) + (tabulatorOptions.finalLineBreak === 'include' && lines.length > 0 ? lineBreak : '');
    };
    Dataset.prototype.toCSV = function (tabulatorOptions) {
        if (tabulatorOptions === void 0) { tabulatorOptions = {}; }
        tabulatorOptions.finalizer = escapeFnCSV;
        tabulatorOptions.separator = tabulatorOptions.separator || ',';
        tabulatorOptions.lineBreak = tabulatorOptions.lineBreak || '\r\n';
        tabulatorOptions.finalLineBreak = tabulatorOptions.finalLineBreak || 'suppress';
        return this.toTabular(tabulatorOptions);
    };
    Dataset.prototype.toTSV = function (tabulatorOptions) {
        if (tabulatorOptions === void 0) { tabulatorOptions = {}; }
        tabulatorOptions.finalizer = escapeFnTSV;
        tabulatorOptions.separator = tabulatorOptions.separator || '\t';
        tabulatorOptions.lineBreak = tabulatorOptions.lineBreak || '\r\n';
        tabulatorOptions.finalLineBreak = tabulatorOptions.finalLineBreak || 'suppress';
        return this.toTabular(tabulatorOptions);
    };
    Dataset.type = 'DATASET';
    return Dataset;
}());
check = Dataset;
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
































































function fillExpressionExternalAlterationAsync(alteration, filler) {
    var tasks = [];
    fillExpressionExternalAlteration(alteration, function (external, terminal) {
        tasks.push(filler(external, terminal));
        return null;
    });
    return Q.all(tasks).then(function (results) {
        var i = 0;
        fillExpressionExternalAlteration(alteration, function () {
            var res = results[i];
            i++;
            return res;
        });
        return alteration;
    });
}
function runtimeAbstract() {
    return new Error('must be implemented');
}
function getDataName(ex) {
    if (ex instanceof RefExpression) {
        return ex.name;
    }
    else if (ex instanceof ChainableExpression) {
        return getDataName(ex.operand);
    }
    else {
        return null;
    }
}
function getValue(param) {
    if (param instanceof LiteralExpression)
        return param.value;
    return param;
}
function getString(param) {
    if (typeof param === 'string')
        return param;
    if (param instanceof LiteralExpression && param.type === 'STRING') {
        return param.value;
    }
    if (param instanceof RefExpression && param.nest === 0) {
        return param.name;
    }
    throw new Error('could not extract a string out of ' + String(param));
}
function getNumber(param) {
    if (typeof param === 'number')
        return param;
    if (param instanceof LiteralExpression && param.type === 'NUMBER') {
        return param.value;
    }
    throw new Error('could not extract a number out of ' + String(param));
}
var ply = exports.ply = function(dataset) {
    if (!dataset)
        dataset = new Dataset({ data: [{}] });
    return r(dataset);
}
var $ = exports.$ = function(name, nest, type) {
    if (typeof name !== 'string')
        throw new TypeError('$() argument must be a string');
    if (typeof nest === 'string') {
        type = nest;
        nest = 0;
    }
    return new RefExpression({
        name: name,
        nest: nest != null ? nest : 0,
        type: type
    });
}
var i$ = exports.i$ = function(name, nest, type) {
    if (typeof name !== 'string')
        throw new TypeError('$() argument must be a string');
    if (typeof nest === 'string') {
        type = nest;
        nest = 0;
    }
    return new RefExpression({
        name: name,
        nest: nest != null ? nest : 0,
        type: type,
        ignoreCase: true
    });
}
var r = exports.r = function(value) {
    if (value instanceof External)
        throw new TypeError('r() can not accept externals');
    if (Array.isArray(value))
        value = Set.fromJS(value);
    return LiteralExpression.fromJS({ op: 'literal', value: value });
}
var toJS = exports.toJS = function(thing) {
    return (thing && typeof thing.toJS === 'function') ? thing.toJS() : thing;
}
function chainVia(op, expressions, zero) {
    var n = expressions.length;
    if (!n)
        return zero;
    var acc = expressions[0];
    if (!(acc instanceof Expression))
        acc = Expression.fromJSLoose(acc);
    for (var i = 1; i < n; i++)
        acc = acc[op](expressions[i]);
    return acc;
}
var Expression = exports.Expression = (function () {
    function Expression(parameters, dummy) {
        if (dummy === void 0) { dummy = null; }
        this.op = parameters.op;
        if (dummy !== dummyObject) {
            throw new TypeError("can not call `new Expression` directly use Expression.fromJS instead");
        }
        if (parameters.simple)
            this.simple = true;
    }
    Expression.isExpression = function (candidate) {
        return candidate instanceof Expression;
    };
    Expression.expressionLookupFromJS = function (expressionJSs) {
        var expressions = Object.create(null);
        for (var name in expressionJSs) {
            if (!hasOwnProperty(expressionJSs, name))
                continue;
            expressions[name] = Expression.fromJSLoose(expressionJSs[name]);
        }
        return expressions;
    };
    Expression.expressionLookupToJS = function (expressions) {
        var expressionsJSs = {};
        for (var name in expressions) {
            if (!hasOwnProperty(expressions, name))
                continue;
            expressionsJSs[name] = expressions[name].toJS();
        }
        return expressionsJSs;
    };
    Expression.parse = function (str, timezone) {
        if (str[0] === '{' && str[str.length - 1] === '}') {
            return Expression.fromJS(JSON.parse(str));
        }
        var original = Expression.defaultParserTimezone;
        if (timezone)
            Expression.defaultParserTimezone = timezone;
        try {
            return Expression.expressionParser.parse(str);
        }
        catch (e) {
            throw new Error("Expression parse error: " + e.message + " on '" + str + "'");
        }
        finally {
            Expression.defaultParserTimezone = original;
        }
    };
    Expression.parseSQL = function (str, timezone) {
        var original = Expression.defaultParserTimezone;
        if (timezone)
            Expression.defaultParserTimezone = timezone;
        try {
            return Expression.plyqlParser.parse(str);
        }
        catch (e) {
            throw new Error("SQL parse error: " + e.message + " on '" + str + "'");
        }
        finally {
            Expression.defaultParserTimezone = original;
        }
    };
    Expression.fromJSLoose = function (param) {
        var expressionJS;
        switch (typeof param) {
            case 'undefined':
                throw new Error('must have an expression');
            case 'object':
                if (param === null) {
                    return Expression.NULL;
                }
                else if (param instanceof Expression) {
                    return param;
                }
                else if (isImmutableClass(param)) {
                    if (param.constructor.type) {
                        expressionJS = { op: 'literal', value: param };
                    }
                    else {
                        throw new Error("unknown object");
                    }
                }
                else if (param.op) {
                    expressionJS = param;
                }
                else if (param.toISOString) {
                    expressionJS = { op: 'literal', value: new Date(param) };
                }
                else if (Array.isArray(param)) {
                    expressionJS = { op: 'literal', value: Set.fromJS(param) };
                }
                else if (hasOwnProperty(param, 'start') && hasOwnProperty(param, 'end')) {
                    expressionJS = { op: 'literal', value: Range.fromJS(param) };
                }
                else {
                    throw new Error('unknown parameter');
                }
                break;
            case 'number':
            case 'boolean':
                expressionJS = { op: 'literal', value: param };
                break;
            case 'string':
                return Expression.parse(param);
            default:
                throw new Error("unrecognizable expression");
        }
        return Expression.fromJS(expressionJS);
    };
    Expression.inOrIs = function (lhs, value) {
        var literal = r(value);
        var literalType = literal.type;
        var returnExpression = null;
        if (literalType === 'NUMBER_RANGE' || literalType === 'TIME_RANGE' || literalType === 'STRING_RANGE' || isSetType(literalType)) {
            returnExpression = lhs.in(literal);
        }
        else {
            returnExpression = lhs.is(literal);
        }
        return returnExpression.simplify();
    };
    Expression.jsNullSafetyUnary = function (inputJS, ifNotNull) {
        return "(_=" + inputJS + ",(_==null?null:" + ifNotNull('_') + "))";
    };
    Expression.jsNullSafetyBinary = function (lhs, rhs, combine, lhsCantBeNull, rhsCantBeNull) {
        if (lhsCantBeNull) {
            if (rhsCantBeNull) {
                return "(" + combine(lhs, rhs) + ")";
            }
            else {
                return "(_=" + rhs + ",(_==null)?null:(" + combine(lhs, '_') + "))";
            }
        }
        else {
            if (rhsCantBeNull) {
                return "(_=" + lhs + ",(_==null)?null:(" + combine('_', rhs) + "))";
            }
            else {
                return "(_=" + rhs + ",_2=" + lhs + ",(_==null||_2==null)?null:(" + combine('_', '_2') + ")";
            }
        }
    };
    Expression.and = function (expressions) {
        return chainVia('and', expressions, Expression.TRUE);
    };
    Expression.or = function (expressions) {
        return chainVia('or', expressions, Expression.FALSE);
    };
    Expression.add = function (expressions) {
        return chainVia('add', expressions, Expression.ZERO);
    };
    Expression.subtract = function (expressions) {
        return chainVia('subtract', expressions, Expression.ZERO);
    };
    Expression.multiply = function (expressions) {
        return chainVia('multiply', expressions, Expression.ONE);
    };
    Expression.power = function (expressions) {
        return chainVia('power', expressions, Expression.ZERO);
    };
    Expression.concat = function (expressions) {
        return chainVia('concat', expressions, Expression.EMPTY_STRING);
    };
    Expression.register = function (ex) {
        var op = ex.op.replace(/^\w/, function (s) { return s.toLowerCase(); });
        Expression.classMap[op] = ex;
    };
    Expression.getConstructorFor = function (op) {
        var ClassFn = Expression.classMap[op];
        if (!ClassFn)
            throw new Error("unsupported expression op '" + op + "'");
        return ClassFn;
    };
    Expression.applyMixins = function (derivedCtor, baseCtors) {
        baseCtors.forEach(function (baseCtor) {
            Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
                derivedCtor.prototype[name] = baseCtor.prototype[name];
            });
        });
    };
    Expression.jsToValue = function (js) {
        return {
            op: js.op,
            type: js.type
        };
    };
    Expression.fromJS = function (expressionJS) {
        if (!expressionJS)
            throw new Error('must have expressionJS');
        if (!hasOwnProperty(expressionJS, "op")) {
            if (hasOwnProperty(expressionJS, "action")) {
                expressionJS = shallowCopy(expressionJS);
                expressionJS.op = expressionJS.action;
                delete expressionJS.action;
                expressionJS.operand = { op: 'ref', name: '_' };
            }
            else {
                throw new Error("op must be defined");
            }
        }
        if (expressionJS.op === 'custom') {
            expressionJS = shallowCopy(expressionJS);
            expressionJS.op = 'customAggregate';
        }
        var op = expressionJS.op;
        if (typeof op !== "string") {
            throw new Error("op must be a string");
        }
        if (op === 'chain') {
            var actions = expressionJS.actions || [expressionJS.action];
            return Expression.fromJS(expressionJS.expression).performActions(actions.map(Expression.fromJS));
        }
        var ClassFn = Expression.getConstructorFor(op);
        return ClassFn.fromJS(expressionJS);
    };
    Expression.fromValue = function (parameters) {
        var op = parameters.op;
        var ClassFn = Expression.getConstructorFor(op);
        return new ClassFn(parameters);
    };
    Expression.prototype._ensureOp = function (op) {
        if (!this.op) {
            this.op = op;
            return;
        }
        if (this.op !== op) {
            throw new TypeError("incorrect expression op '" + this.op + "' (needs to be: '" + op + "')");
        }
    };
    Expression.prototype.valueOf = function () {
        var value = { op: this.op };
        if (this.simple)
            value.simple = true;
        return value;
    };
    Expression.prototype.toJS = function () {
        return {
            op: this.op
        };
    };
    Expression.prototype.toJSON = function () {
        return this.toJS();
    };
    Expression.prototype.equals = function (other) {
        return other instanceof Expression &&
            this.op === other.op &&
            this.type === other.type;
    };
    Expression.prototype.canHaveType = function (wantedType) {
        var type = this.type;
        if (!type)
            return true;
        if (wantedType === 'SET') {
            return isSetType(type);
        }
        else {
            return type === wantedType;
        }
    };
    Expression.prototype.expressionCount = function () {
        return 1;
    };
    Expression.prototype.isOp = function (op) {
        return this.op === op;
    };
    Expression.prototype.markSimple = function () {
        if (this.simple)
            return this;
        var value = this.valueOf();
        value.simple = true;
        return Expression.fromValue(value);
    };
    Expression.prototype.containsOp = function (op) {
        return this.some(function (ex) { return ex.isOp(op) || null; });
    };
    Expression.prototype.hasExternal = function () {
        return this.some(function (ex) {
            if (ex instanceof ExternalExpression)
                return true;
            return null;
        });
    };
    Expression.prototype.getBaseExternals = function () {
        var externals = [];
        this.forEach(function (ex) {
            if (ex instanceof ExternalExpression)
                externals.push(ex.external.getBase());
        });
        return External.deduplicateExternals(externals);
    };
    Expression.prototype.getRawExternals = function () {
        var externals = [];
        this.forEach(function (ex) {
            if (ex instanceof ExternalExpression)
                externals.push(ex.external.getRaw());
        });
        return External.deduplicateExternals(externals);
    };
    Expression.prototype.getReadyExternals = function () {
        var indexToSkip = {};
        var externalsByIndex = {};
        this.every(function (ex, index) {
            if (ex instanceof ExternalExpression) {
                if (indexToSkip[index])
                    return null;
                if (!ex.external.suppress) {
                    externalsByIndex[index] = {
                        external: ex.external,
                        terminal: true
                    };
                }
            }
            else if (ex instanceof ChainableExpression) {
                var h = ex._headExternal();
                if (h) {
                    if (h.allGood) {
                        externalsByIndex[index + h.offset] = { external: h.external };
                        return true;
                    }
                    else {
                        indexToSkip[index + h.offset] = true;
                        return null;
                    }
                }
            }
            else if (ex instanceof LiteralExpression && ex.type === 'DATASET') {
                var datasetExternals = ex.value.getReadyExternals();
                if (datasetExternals.length)
                    externalsByIndex[index] = datasetExternals;
                return null;
            }
            return null;
        });
        return externalsByIndex;
    };
    Expression.prototype.applyReadyExternals = function (alterations) {
        return this.substitute(function (ex, index) {
            var alteration = alterations[index];
            if (!alteration)
                return null;
            if (Array.isArray(alteration)) {
                return r(ex.getLiteralValue().applyReadyExternals(alteration));
            }
            else {
                return r(alteration.result);
            }
        }).simplify();
    };
    Expression.prototype._headExternal = function () {
        var ex = this;
        var allGood = true;
        var offset = 0;
        while (ex instanceof ChainableExpression) {
            allGood = allGood && (ex.op === 'filter' ? ex.argumentsResolvedWithoutExternals() : ex.argumentsResolved());
            ex = ex.operand;
            offset++;
        }
        if (ex instanceof ExternalExpression) {
            return {
                allGood: allGood,
                external: ex.external,
                offset: offset
            };
        }
        else {
            return null;
        }
    };
    Expression.prototype.getHeadOperand = function () {
        return this;
    };
    Expression.prototype.getFreeReferences = function () {
        var freeReferences = [];
        this.forEach(function (ex, index, depth, nestDiff) {
            if (ex instanceof RefExpression && nestDiff <= ex.nest) {
                freeReferences.push(repeat('^', ex.nest - nestDiff) + ex.name);
            }
        });
        return deduplicateSort(freeReferences);
    };
    Expression.prototype.getFreeReferenceIndexes = function () {
        var freeReferenceIndexes = [];
        this.forEach(function (ex, index, depth, nestDiff) {
            if (ex instanceof RefExpression && nestDiff <= ex.nest) {
                freeReferenceIndexes.push(index);
            }
        });
        return freeReferenceIndexes;
    };
    Expression.prototype.incrementNesting = function (by) {
        if (by === void 0) { by = 1; }
        var freeReferenceIndexes = this.getFreeReferenceIndexes();
        if (freeReferenceIndexes.length === 0)
            return this;
        return this.substitute(function (ex, index) {
            if (ex instanceof RefExpression && freeReferenceIndexes.indexOf(index) !== -1) {
                return ex.incrementNesting(by);
            }
            return null;
        });
    };
    Expression.prototype.simplify = function () {
        return this;
    };
    Expression.prototype.every = function (iter, thisArg) {
        return this._everyHelper(iter, thisArg, { index: 0 }, 0, 0);
    };
    Expression.prototype._everyHelper = function (iter, thisArg, indexer, depth, nestDiff) {
        var pass = iter.call(thisArg, this, indexer.index, depth, nestDiff);
        if (pass != null) {
            return pass;
        }
        else {
            indexer.index++;
        }
        return true;
    };
    Expression.prototype.some = function (iter, thisArg) {
        var _this = this;
        return !this.every(function (ex, index, depth, nestDiff) {
            var v = iter.call(_this, ex, index, depth, nestDiff);
            return (v == null) ? null : !v;
        }, thisArg);
    };
    Expression.prototype.forEach = function (iter, thisArg) {
        var _this = this;
        this.every(function (ex, index, depth, nestDiff) {
            iter.call(_this, ex, index, depth, nestDiff);
            return null;
        }, thisArg);
    };
    Expression.prototype.substitute = function (substitutionFn, typeContext) {
        if (typeContext === void 0) { typeContext = null; }
        return this._substituteHelper(substitutionFn, { index: 0 }, 0, 0, typeContext).expression;
    };
    Expression.prototype._substituteHelper = function (substitutionFn, indexer, depth, nestDiff, typeContext) {
        var sub = substitutionFn.call(this, this, indexer.index, depth, nestDiff, typeContext);
        if (sub) {
            indexer.index += this.expressionCount();
            return {
                expression: sub,
                typeContext: sub.updateTypeContextIfNeeded(typeContext)
            };
        }
        else {
            indexer.index++;
        }
        return {
            expression: this,
            typeContext: this.updateTypeContextIfNeeded(typeContext)
        };
    };
    Expression.prototype.fullyDefined = function () {
        return true;
    };
    Expression.prototype.getJSFn = function (datumVar) {
        if (datumVar === void 0) { datumVar = 'd[]'; }
        var type = this.type;
        var jsEx = this.getJS(datumVar);
        var body;
        if (type === 'NUMBER' || type === 'NUMBER_RANGE' || type === 'TIME') {
            body = "_=" + jsEx + ";return isNaN(_)?null:_";
        }
        else {
            body = "return " + jsEx + ";";
        }
        return "function(" + datumVar.replace('[]', '') + "){var _,_2;" + body + "}";
    };
    Expression.prototype.extractFromAnd = function (matchFn) {
        if (this.type !== 'BOOLEAN')
            return null;
        if (matchFn(this)) {
            return {
                extract: this,
                rest: Expression.TRUE
            };
        }
        else {
            return {
                extract: Expression.TRUE,
                rest: this
            };
        }
    };
    Expression.prototype.breakdownByDataset = function (tempNamePrefix) {
        throw new Error('todo');
    };
    Expression.prototype.getLiteralValue = function () {
        return null;
    };
    Expression.prototype.bumpStringLiteralToSetString = function () {
        return this;
    };
    Expression.prototype.upgradeToType = function (targetType) {
        return this;
    };
    Expression.prototype.isAction = function () {
        return false;
    };
    Expression.prototype.performAction = function (action) {
        var _this = this;
        if (!action.isAction())
            throw new Error(action + " is not an action");
        return action.substitute(function (ex) { return ex.equals(Expression._) ? _this : null; });
    };
    Expression.prototype.performActions = function (actions) {
        var ex = this;
        for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {
            var action = actions_1[_i];
            ex = ex.performAction(action);
        }
        return ex;
    };
    Expression.prototype._mkChain = function (ExpressionClass, exs) {
        var cur = this;
        for (var _i = 0, exs_1 = exs; _i < exs_1.length; _i++) {
            var ex = exs_1[_i];
            cur = new ExpressionClass({
                operand: cur,
                expression: ex instanceof Expression ? ex : Expression.fromJSLoose(ex)
            });
        }
        return cur;
    };
    Expression.prototype.add = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._mkChain(AddExpression, exs);
    };
    Expression.prototype.subtract = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._mkChain(SubtractExpression, exs);
    };
    Expression.prototype.negate = function () {
        return Expression.ZERO.subtract(this);
    };
    Expression.prototype.multiply = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._mkChain(MultiplyExpression, exs);
    };
    Expression.prototype.divide = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._mkChain(DivideExpression, exs);
    };
    Expression.prototype.reciprocate = function () {
        return Expression.ONE.divide(this);
    };
    Expression.prototype.sqrt = function () {
        return this.power(0.5);
    };
    Expression.prototype.power = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._mkChain(PowerExpression, exs);
    };
    Expression.prototype.fallback = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new FallbackExpression({ operand: this, expression: ex });
    };
    Expression.prototype.is = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new IsExpression({ operand: this, expression: ex });
    };
    Expression.prototype.isnt = function (ex) {
        return this.is(ex).not();
    };
    Expression.prototype.lessThan = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new LessThanExpression({ operand: this, expression: ex });
    };
    Expression.prototype.lessThanOrEqual = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new LessThanOrEqualExpression({ operand: this, expression: ex });
    };
    Expression.prototype.greaterThan = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new GreaterThanExpression({ operand: this, expression: ex });
    };
    Expression.prototype.greaterThanOrEqual = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new GreaterThanOrEqualExpression({ operand: this, expression: ex });
    };
    Expression.prototype.contains = function (ex, compare) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        if (compare)
            compare = getString(compare);
        return new ContainsExpression({ operand: this, expression: ex, compare: compare });
    };
    Expression.prototype.match = function (re) {
        return new MatchExpression({ operand: this, regexp: getString(re) });
    };
    Expression.prototype.in = function (ex, snd) {
        if (arguments.length === 2) {
            ex = getValue(ex);
            snd = getValue(snd);
            if (typeof ex === 'string') {
                var parse = parseISODate(ex, Expression.defaultParserTimezone);
                if (parse)
                    ex = parse;
            }
            if (typeof snd === 'string') {
                var parse = parseISODate(snd, Expression.defaultParserTimezone);
                if (parse)
                    snd = parse;
            }
            if (typeof ex === 'number' && typeof snd === 'number') {
                ex = new NumberRange({ start: ex, end: snd });
            }
            else if (ex.toISOString && snd.toISOString) {
                ex = new TimeRange({ start: ex, end: snd });
            }
            else if (typeof ex === 'string' && typeof snd === 'string') {
                ex = new StringRange({ start: ex, end: snd });
            }
            else {
                throw new Error('uninterpretable IN parameters');
            }
        }
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new InExpression({ operand: this, expression: ex });
    };
    Expression.prototype.overlap = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new OverlapExpression({ operand: this, expression: ex.bumpStringLiteralToSetString() });
    };
    Expression.prototype.not = function () {
        return new NotExpression({ operand: this });
    };
    Expression.prototype.and = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._mkChain(AndExpression, exs);
    };
    Expression.prototype.or = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._mkChain(OrExpression, exs);
    };
    Expression.prototype.substr = function (position, len) {
        return new SubstrExpression({ operand: this, position: getNumber(position), len: getNumber(len) });
    };
    Expression.prototype.extract = function (re) {
        return new ExtractExpression({ operand: this, regexp: getString(re) });
    };
    Expression.prototype.concat = function () {
        var exs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exs[_i - 0] = arguments[_i];
        }
        return this._mkChain(ConcatExpression, exs);
    };
    Expression.prototype.lookup = function (lookupFn) {
        return new LookupExpression({ operand: this, lookupFn: getString(lookupFn) });
    };
    Expression.prototype.indexOf = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new IndexOfExpression({ operand: this, expression: ex });
    };
    Expression.prototype.transformCase = function (transformType) {
        return new TransformCaseExpression({ operand: this, transformType: getString(transformType) });
    };
    Expression.prototype.customTransform = function (custom, outputType) {
        if (!custom)
            throw new Error("Must provide an extraction function name for custom transform");
        outputType = outputType !== undefined ? getString(outputType) : null;
        return new CustomTransformExpression({ operand: this, custom: getString(custom), outputType: outputType });
    };
    Expression.prototype.numberBucket = function (size, offset) {
        if (offset === void 0) { offset = 0; }
        return new NumberBucketExpression({ operand: this, size: getNumber(size), offset: getNumber(offset) });
    };
    Expression.prototype.absolute = function () {
        return new AbsoluteExpression({ operand: this });
    };
    Expression.prototype.length = function () {
        return new LengthExpression({ operand: this });
    };
    Expression.prototype.timeBucket = function (duration, timezone) {
        if (!(duration instanceof Duration))
            duration = Duration.fromJS(getString(duration));
        if (timezone && !(timezone instanceof Timezone))
            timezone = Timezone.fromJS(getString(timezone));
        return new TimeBucketExpression({ operand: this, duration: duration, timezone: timezone });
    };
    Expression.prototype.timeFloor = function (duration, timezone) {
        if (!(duration instanceof Duration))
            duration = Duration.fromJS(getString(duration));
        if (timezone && !(timezone instanceof Timezone))
            timezone = Timezone.fromJS(getString(timezone));
        return new TimeFloorExpression({ operand: this, duration: duration, timezone: timezone });
    };
    Expression.prototype.timeShift = function (duration, step, timezone) {
        if (!(duration instanceof Duration))
            duration = Duration.fromJS(getString(duration));
        step = typeof step !== 'undefined' ? getNumber(step) : null;
        if (timezone && !(timezone instanceof Timezone))
            timezone = Timezone.fromJS(getString(timezone));
        return new TimeShiftExpression({ operand: this, duration: duration, step: step, timezone: timezone });
    };
    Expression.prototype.timeRange = function (duration, step, timezone) {
        if (!(duration instanceof Duration))
            duration = Duration.fromJS(getString(duration));
        step = typeof step !== 'undefined' ? getNumber(step) : null;
        if (timezone && !(timezone instanceof Timezone))
            timezone = Timezone.fromJS(getString(timezone));
        return new TimeRangeExpression({ operand: this, duration: duration, step: step, timezone: timezone });
    };
    Expression.prototype.timePart = function (part, timezone) {
        if (timezone && !(timezone instanceof Timezone))
            timezone = Timezone.fromJS(getString(timezone));
        return new TimePartExpression({ operand: this, part: getString(part), timezone: timezone });
    };
    Expression.prototype.cast = function (outputType) {
        return new CastExpression({ operand: this, outputType: getString(outputType) });
    };
    Expression.prototype.cardinality = function () {
        return new CardinalityExpression({ operand: this });
    };
    Expression.prototype.filter = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new FilterExpression({ operand: this, expression: ex });
    };
    Expression.prototype.split = function (splits, name, dataName) {
        if (arguments.length === 3 ||
            (arguments.length === 2 && splits && (typeof splits === 'string' || typeof splits.op === 'string'))) {
            name = getString(name);
            var realSplits = Object.create(null);
            realSplits[name] = splits;
            splits = realSplits;
        }
        else {
            dataName = name;
        }
        var parsedSplits = Object.create(null);
        for (var k in splits) {
            if (!hasOwnProperty(splits, k))
                continue;
            var ex = splits[k];
            parsedSplits[k] = ex instanceof Expression ? ex : Expression.fromJSLoose(ex);
        }
        dataName = dataName ? getString(dataName) : getDataName(this);
        if (!dataName)
            throw new Error("could not guess data name in `split`, please provide one explicitly");
        return new SplitExpression({ operand: this, splits: parsedSplits, dataName: dataName });
    };
    Expression.prototype.apply = function (name, ex) {
        if (arguments.length < 2)
            throw new Error('invalid arguments to .apply, did you forget to specify a name?');
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new ApplyExpression({ operand: this, name: getString(name), expression: ex });
    };
    Expression.prototype.sort = function (ex, direction) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new SortExpression({ operand: this, expression: ex, direction: direction ? getString(direction) : null });
    };
    Expression.prototype.limit = function (value) {
        return new LimitExpression({ operand: this, value: getNumber(value) });
    };
    Expression.prototype.select = function () {
        var attributes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            attributes[_i - 0] = arguments[_i];
        }
        attributes = (attributes.length === 1 && Array.isArray(attributes[0])) ? attributes[0] : attributes.map(getString);
        return new SelectExpression({ operand: this, attributes: attributes });
    };
    Expression.prototype.count = function () {
        if (arguments.length)
            throw new Error('.count() should not have arguments, did you want to .filter().count() ?');
        return new CountExpression({ operand: this });
    };
    Expression.prototype.sum = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new SumExpression({ operand: this, expression: ex });
    };
    Expression.prototype.min = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new MinExpression({ operand: this, expression: ex });
    };
    Expression.prototype.max = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new MaxExpression({ operand: this, expression: ex });
    };
    Expression.prototype.average = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new AverageExpression({ operand: this, expression: ex });
    };
    Expression.prototype.countDistinct = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new CountDistinctExpression({ operand: this, expression: ex });
    };
    Expression.prototype.quantile = function (ex, value) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new QuantileExpression({ operand: this, expression: ex, value: getNumber(value) });
    };
    Expression.prototype.collect = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new CollectExpression({ operand: this, expression: ex });
    };
    Expression.prototype.customAggregate = function (custom) {
        return new CustomAggregateExpression({ operand: this, custom: getString(custom) });
    };
    Expression.prototype.join = function (ex) {
        if (!(ex instanceof Expression))
            ex = Expression.fromJSLoose(ex);
        return new JoinExpression({ operand: this, expression: ex });
    };
    Expression.prototype.needsEnvironment = function () {
        return false;
    };
    Expression.prototype.defineEnvironment = function (environment) {
        if (!environment.timezone)
            environment = { timezone: Timezone.UTC };
        if (typeof environment.timezone === 'string')
            environment = { timezone: Timezone.fromJS(environment.timezone) };
        return this.substitute(function (ex) {
            if (ex.needsEnvironment()) {
                return ex.defineEnvironment(environment);
            }
            return null;
        });
    };
    Expression.prototype.referenceCheck = function (context) {
        return this.changeInTypeContext(getFullTypeFromDatum(context));
    };
    Expression.prototype.definedInTypeContext = function (typeContext) {
        try {
            this.changeInTypeContext(typeContext);
        }
        catch (e) {
            return false;
        }
        return true;
    };
    Expression.prototype.referenceCheckInTypeContext = function (typeContext) {
        console.warn("referenceCheckInTypeContext is deprecated, use changeInTypeContext instead");
        return this.changeInTypeContext(typeContext);
    };
    Expression.prototype.changeInTypeContext = function (typeContext) {
        return this.substitute(function (ex, index, depth, nestDiff, typeContext) {
            if (ex instanceof RefExpression) {
                return ex.changeInTypeContext(typeContext);
            }
            return null;
        }, typeContext);
    };
    Expression.prototype.updateTypeContext = function (typeContext, extra) {
        return typeContext;
    };
    Expression.prototype.updateTypeContextIfNeeded = function (typeContext, extra) {
        return typeContext ? this.updateTypeContext(typeContext, extra) : null;
    };
    Expression.prototype.resolve = function (context, ifNotFound) {
        if (ifNotFound === void 0) { ifNotFound = 'throw'; }
        var expressions = Object.create(null);
        for (var k in context) {
            if (!hasOwnProperty(context, k))
                continue;
            var value = context[k];
            if (value instanceof External) {
                expressions[k] = new ExternalExpression({ external: value });
            }
            else if (value instanceof Expression) {
                expressions[k] = value;
            }
            else {
                expressions[k] = new LiteralExpression({ value: value });
            }
        }
        return this.resolveWithExpressions(expressions, ifNotFound);
    };
    Expression.prototype.resolveWithExpressions = function (expressions, ifNotFound) {
        if (ifNotFound === void 0) { ifNotFound = 'throw'; }
        return this.substitute(function (ex, index, depth, nestDiff) {
            if (ex instanceof RefExpression) {
                var nest = ex.nest, ignoreCase = ex.ignoreCase, name = ex.name;
                if (nestDiff === nest) {
                    var foundExpression = null;
                    var valueFound = false;
                    var property = ignoreCase ? RefExpression.findPropertyCI(expressions, name) : RefExpression.findProperty(expressions, name);
                    if (property != null) {
                        foundExpression = expressions[property];
                        valueFound = true;
                    }
                    if (foundExpression instanceof ExternalExpression) {
                        var mode = foundExpression.external.mode;
                        if (mode === 'split') {
                            return ex;
                        }
                        if (nest > 0 && mode !== 'raw') {
                            return ex;
                        }
                    }
                    if (valueFound) {
                        return foundExpression;
                    }
                    else if (ifNotFound === 'throw') {
                        throw new Error("could not resolve " + ex + " because is was not in the context");
                    }
                    else if (ifNotFound === 'null') {
                        return Expression.NULL;
                    }
                    else if (ifNotFound === 'leave') {
                        return ex;
                    }
                }
                else if (nestDiff < nest) {
                    throw new Error("went too deep during resolve on: " + ex);
                }
            }
            return null;
        });
    };
    Expression.prototype.resolved = function () {
        return this.every(function (ex, index, depth, nestDiff) {
            return (ex instanceof RefExpression) ? ex.nest <= nestDiff : null;
        });
    };
    Expression.prototype.resolvedWithoutExternals = function () {
        return this.every(function (ex, index, depth, nestDiff) {
            if (ex instanceof ExternalExpression)
                return false;
            return (ex instanceof RefExpression) ? ex.nest <= nestDiff : null;
        });
    };
    Expression.prototype.noRefs = function () {
        return this.every(function (ex) {
            if (ex instanceof RefExpression)
                return false;
            return null;
        });
    };
    Expression.prototype.isAggregate = function () {
        return false;
    };
    Expression.prototype.decomposeAverage = function (countEx) {
        return this.substitute(function (ex) {
            if (ex instanceof AverageExpression) {
                return ex.decomposeAverage(countEx);
            }
            return null;
        });
    };
    Expression.prototype.distribute = function () {
        return this.substitute(function (ex, index) {
            if (index === 0)
                return null;
            var distributedEx = ex.distribute();
            if (distributedEx === ex)
                return null;
            return distributedEx;
        }).simplify();
    };
    Expression.prototype.maxPossibleSplitValues = function () {
        return this.type === 'BOOLEAN' ? 3 : Infinity;
    };
    Expression.prototype._initialPrepare = function (context, environment) {
        return this.defineEnvironment(environment)
            .referenceCheck(context)
            .resolve(context)
            .simplify();
    };
    Expression.prototype.simulate = function (context, options) {
        if (context === void 0) { context = {}; }
        if (options === void 0) { options = {}; }
        failIfIntrospectNeededInDatum(context);
        var readyExpression = this._initialPrepare(context, options);
        if (readyExpression instanceof ExternalExpression) {
            readyExpression = readyExpression.unsuppress();
        }
        return readyExpression._computeResolvedSimulate(options, []);
    };
    Expression.prototype.simulateQueryPlan = function (context, options) {
        if (context === void 0) { context = {}; }
        if (options === void 0) { options = {}; }
        failIfIntrospectNeededInDatum(context);
        var readyExpression = this._initialPrepare(context, options);
        if (readyExpression instanceof ExternalExpression) {
            readyExpression = readyExpression.unsuppress();
        }
        var simulatedQueryGroups = [];
        readyExpression._computeResolvedSimulate(options, simulatedQueryGroups);
        return simulatedQueryGroups;
    };
    Expression.prototype._computeResolvedSimulate = function (options, simulatedQueryGroups) {
        var _a = options.maxComputeCycles, maxComputeCycles = _a === void 0 ? 5 : _a, _b = options.maxQueries, maxQueries = _b === void 0 ? 500 : _b;
        var ex = this;
        var readyExternals = ex.getReadyExternals();
        var computeCycles = 0;
        var queries = 0;
        var _loop_1 = function() {
            var simulatedQueryGroup = [];
            fillExpressionExternalAlteration(readyExternals, function (external, terminal) {
                if (queries < maxQueries) {
                    queries++;
                    return external.simulateValue(terminal, simulatedQueryGroup);
                }
                else {
                    queries++;
                    return null;
                }
            });
            simulatedQueryGroups.push(simulatedQueryGroup);
            ex = ex.applyReadyExternals(readyExternals);
            readyExternals = ex.getReadyExternals();
            computeCycles++;
        };
        while (Object.keys(readyExternals).length > 0 && computeCycles < maxComputeCycles && queries < maxQueries) {
            _loop_1();
        }
        return ex.getLiteralValue();
    };
    Expression.prototype.compute = function (context, options) {
        var _this = this;
        if (context === void 0) { context = {}; }
        if (options === void 0) { options = {}; }
        return Q(null)
            .then(function () {
            return introspectDatum(context);
        })
            .then(function (introspectedContext) {
            var readyExpression = _this._initialPrepare(introspectedContext, options);
            if (readyExpression instanceof ExternalExpression) {
                readyExpression = readyExpression.unsuppress();
            }
            return readyExpression._computeResolved(options);
        });
    };
    Expression.prototype._computeResolved = function (options) {
        var _a = options.maxComputeCycles, maxComputeCycles = _a === void 0 ? 5 : _a, _b = options.maxQueries, maxQueries = _b === void 0 ? 500 : _b;
        var ex = this;
        var readyExternals = ex.getReadyExternals();
        var computeCycles = 0;
        var queries = 0;
        return promiseWhile(function () { return Object.keys(readyExternals).length > 0 && computeCycles < maxComputeCycles && queries < maxQueries; }, function () {
            return fillExpressionExternalAlterationAsync(readyExternals, function (external, terminal) {
                if (queries < maxQueries) {
                    queries++;
                    return external.queryValue(terminal);
                }
                else {
                    queries++;
                    return Q(null);
                }
            })
                .then(function (readyExternalsFilled) {
                ex = ex.applyReadyExternals(readyExternalsFilled);
                readyExternals = ex.getReadyExternals();
                computeCycles++;
            });
        })
            .then(function () {
            if (!ex.isOp('literal'))
                throw new Error("something went wrong, did not get literal: " + ex);
            return ex.getLiteralValue();
        });
    };
    Expression.defaultParserTimezone = Timezone.UTC;
    Expression.classMap = {};
    return Expression;
}());
var ChainableExpression = exports.ChainableExpression = (function (_super) {
    __extends(ChainableExpression, _super);
    function ChainableExpression(value, dummy) {
        if (dummy === void 0) { dummy = null; }
        _super.call(this, value, dummy);
        this.operand = value.operand || Expression._;
    }
    ChainableExpression.jsToValue = function (js) {
        var value = Expression.jsToValue(js);
        value.operand = js.operand ? Expression.fromJS(js.operand) : Expression._;
        return value;
    };
    ChainableExpression.prototype._checkOperandTypes = function () {
        var neededTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            neededTypes[_i - 0] = arguments[_i];
        }
        var operandType = this.operand.type;
        if (operandType && operandType !== 'NULL' && neededTypes.indexOf(operandType) === -1) {
            if (neededTypes.length === 1) {
                throw new Error(this.op + " must have operand of type " + neededTypes[0] + " (is " + operandType + ")");
            }
            else {
                throw new Error(this.op + " must have operand of type " + neededTypes.join(' or ') + " (is " + operandType + ")");
            }
        }
    };
    ChainableExpression.prototype._bumpOperandToTime = function () {
        if (this.operand.type === 'STRING') {
            this.operand = this.operand.upgradeToType('TIME');
        }
    };
    ChainableExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.operand = this.operand;
        return value;
    };
    ChainableExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        if (!this.operand.equals(Expression._)) {
            js.operand = this.operand.toJS();
        }
        return js;
    };
    ChainableExpression.prototype._toStringParameters = function (indent) {
        return [];
    };
    ChainableExpression.prototype.toString = function (indent) {
        return this.operand.toString(indent) + "." + this.op + "(" + this._toStringParameters(indent).join(',') + ")";
    };
    ChainableExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.operand.equals(other.operand);
    };
    ChainableExpression.prototype.changeOperand = function (operand) {
        if (this.operand === operand || this.operand.equals(operand))
            return this;
        var value = this.valueOf();
        value.operand = operand;
        delete value.simple;
        return Expression.fromValue(value);
    };
    ChainableExpression.prototype.swapWithOperand = function () {
        var operand = this.operand;
        if (operand instanceof ChainableExpression) {
            return operand.changeOperand(this.changeOperand(operand.operand));
        }
        else {
            throw new Error('operand must be chainable');
        }
    };
    ChainableExpression.prototype.isAction = function () {
        return this.operand.equals(Expression._);
    };
    ChainableExpression.prototype.getAction = function () {
        return this.changeOperand(Expression._);
    };
    ChainableExpression.prototype.getHeadOperand = function () {
        var iter = this.operand;
        while (iter instanceof ChainableExpression)
            iter = iter.operand;
        return iter;
    };
    ChainableExpression.prototype.getArgumentExpressions = function () {
        return [];
    };
    ChainableExpression.prototype.expressionCount = function () {
        var sum = _super.prototype.expressionCount.call(this) + this.operand.expressionCount();
        this.getArgumentExpressions().forEach(function (ex) { return sum += ex.expressionCount(); });
        return sum;
    };
    ChainableExpression.prototype.argumentsResolved = function () {
        return this.getArgumentExpressions().every(function (ex) { return ex.resolved(); });
    };
    ChainableExpression.prototype.argumentsResolvedWithoutExternals = function () {
        return this.getArgumentExpressions().every(function (ex) { return ex.resolvedWithoutExternals(); });
    };
    ChainableExpression.prototype.getFn = function () {
        var _this = this;
        return function (d) { return _this.calc(d); };
    };
    ChainableExpression.prototype._calcChainableHelper = function (operandValue) {
        throw runtimeAbstract();
    };
    ChainableExpression.prototype.fullyDefined = function () {
        return this.operand.isOp('literal');
    };
    ChainableExpression.prototype.calc = function (datum) {
        return this._calcChainableHelper(this.operand.calc(datum));
    };
    ChainableExpression.prototype._getJSChainableHelper = function (operandJS) {
        throw runtimeAbstract();
    };
    ChainableExpression.prototype.getJS = function (datumVar) {
        return this._getJSChainableHelper(this.operand.getJS(datumVar));
    };
    ChainableExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        throw runtimeAbstract();
    };
    ChainableExpression.prototype.getSQL = function (dialect) {
        return this._getSQLChainableHelper(dialect, this.operand.getSQL(dialect));
    };
    ChainableExpression.prototype.pushIntoExternal = function () {
        var operand = this.operand;
        if (operand instanceof ExternalExpression) {
            return operand.addExpression(this.getAction());
        }
        return null;
    };
    ChainableExpression.prototype.specialSimplify = function () {
        return this;
    };
    ChainableExpression.prototype.simplify = function () {
        if (this.simple)
            return this;
        var simpler = this.changeOperand(this.operand.simplify());
        if (simpler.fullyDefined()) {
            return r(simpler.calc({}));
        }
        var specialSimpler = simpler.specialSimplify();
        if (specialSimpler === simpler) {
            simpler = specialSimpler.markSimple();
        }
        else {
            simpler = specialSimpler.simplify();
        }
        if (simpler instanceof ChainableExpression) {
            var pushedInExternal = simpler.pushIntoExternal();
            if (pushedInExternal)
                return pushedInExternal;
        }
        return simpler;
    };
    ChainableExpression.prototype.isNester = function () {
        return false;
    };
    ChainableExpression.prototype._everyHelper = function (iter, thisArg, indexer, depth, nestDiff) {
        var pass = iter.call(thisArg, this, indexer.index, depth, nestDiff);
        if (pass != null) {
            return pass;
        }
        else {
            indexer.index++;
        }
        depth++;
        var operand = this.operand;
        if (!operand._everyHelper(iter, thisArg, indexer, depth, nestDiff))
            return false;
        var nestDiffNext = nestDiff + Number(this.isNester());
        return this.getArgumentExpressions().every(function (ex) { return ex._everyHelper(iter, thisArg, indexer, depth, nestDiffNext); });
    };
    ChainableExpression.prototype._substituteHelper = function (substitutionFn, indexer, depth, nestDiff, typeContext) {
        var sub = substitutionFn.call(this, this, indexer.index, depth, nestDiff, typeContext);
        if (sub) {
            indexer.index += this.expressionCount();
            return {
                expression: sub,
                typeContext: sub.updateTypeContextIfNeeded(typeContext)
            };
        }
        else {
            indexer.index++;
        }
        depth++;
        var operandSubs = this.operand._substituteHelper(substitutionFn, indexer, depth, nestDiff, typeContext);
        var updatedThis = this.changeOperand(operandSubs.expression);
        return {
            expression: updatedThis,
            typeContext: updatedThis.updateTypeContextIfNeeded(operandSubs.typeContext)
        };
    };
    return ChainableExpression;
}(Expression));
var ChainableUnaryExpression = exports.ChainableUnaryExpression = (function (_super) {
    __extends(ChainableUnaryExpression, _super);
    function ChainableUnaryExpression(value, dummy) {
        if (dummy === void 0) { dummy = null; }
        _super.call(this, value, dummy);
        if (!value.expression)
            throw new Error("must have an expression");
        this.expression = value.expression;
    }
    ChainableUnaryExpression.jsToValue = function (js) {
        var value = ChainableExpression.jsToValue(js);
        value.expression = Expression.fromJS(js.expression);
        return value;
    };
    ChainableUnaryExpression.prototype._checkExpressionTypes = function () {
        var neededTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            neededTypes[_i - 0] = arguments[_i];
        }
        var expressionType = this.expression.type;
        if (expressionType && expressionType !== 'NULL' && neededTypes.indexOf(expressionType) === -1) {
            if (neededTypes.length === 1) {
                throw new Error(this.op + " must have expression of type " + neededTypes[0] + " (is " + expressionType + ")");
            }
            else {
                throw new Error(this.op + " must have expression of type " + neededTypes.join(' or ') + " (is " + expressionType + ")");
            }
        }
    };
    ChainableUnaryExpression.prototype._checkOperandExpressionTypesAlign = function () {
        var operandType = this.operand.type;
        var expressionType = this.expression.type;
        if (!operandType || operandType === 'NULL' || !expressionType || expressionType === 'NULL' || operandType === expressionType)
            return;
        throw new Error(this.op + " must have matching types (are " + operandType + ", " + expressionType + ")");
    };
    ChainableUnaryExpression.prototype._bumpOperandExpressionToTime = function () {
        if (this.expression.type === 'TIME' && this.operand.type === 'STRING') {
            this.operand = this.operand.upgradeToType('TIME');
        }
        if (this.operand.type === 'TIME' && this.expression.type === 'STRING') {
            this.expression = this.expression.upgradeToType('TIME');
        }
    };
    ChainableUnaryExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.expression = this.expression;
        return value;
    };
    ChainableUnaryExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.expression = this.expression.toJS();
        return js;
    };
    ChainableUnaryExpression.prototype._toStringParameters = function (indent) {
        return [this.expression.toString(indent)];
    };
    ChainableUnaryExpression.prototype.toString = function (indent) {
        return this.operand.toString(indent) + "." + this.op + "(" + this._toStringParameters(indent).join(',') + ")";
    };
    ChainableUnaryExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.expression.equals(other.expression);
    };
    ChainableUnaryExpression.prototype.changeExpression = function (expression) {
        if (this.expression === expression || this.expression.equals(expression))
            return this;
        var value = this.valueOf();
        value.expression = expression;
        delete value.simple;
        return Expression.fromValue(value);
    };
    ChainableUnaryExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        throw runtimeAbstract();
    };
    ChainableUnaryExpression.prototype.fullyDefined = function () {
        return this.operand.isOp('literal') && this.expression.isOp('literal');
    };
    ChainableUnaryExpression.prototype.calc = function (datum) {
        return this._calcChainableUnaryHelper(this.operand.calc(datum), this.isNester() ? null : this.expression.calc(datum));
    };
    ChainableUnaryExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        throw runtimeAbstract();
    };
    ChainableUnaryExpression.prototype.getJS = function (datumVar) {
        return this._getJSChainableUnaryHelper(this.operand.getJS(datumVar), this.expression.getJS(datumVar));
    };
    ChainableUnaryExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        throw runtimeAbstract();
    };
    ChainableUnaryExpression.prototype.getSQL = function (dialect) {
        return this._getSQLChainableUnaryHelper(dialect, this.operand.getSQL(dialect), this.expression.getSQL(dialect));
    };
    ChainableUnaryExpression.prototype.getExpressionList = function () {
        var _a = this, op = _a.op, operand = _a.operand, expression = _a.expression;
        var expressionList = [expression];
        var iter = operand;
        while (iter.op === op) {
            expressionList.unshift(iter.expression);
            iter = iter.operand;
        }
        expressionList.unshift(iter);
        return expressionList;
    };
    ChainableUnaryExpression.prototype.isCommutative = function () {
        return false;
    };
    ChainableUnaryExpression.prototype.isAssociative = function () {
        return false;
    };
    ChainableUnaryExpression.prototype.associateLeft = function () {
        if (!this.isAssociative())
            return null;
        var _a = this, op = _a.op, operand = _a.operand, expression = _a.expression;
        if (op !== expression.op)
            return null;
        var MyClass = this.constructor;
        return new MyClass({
            operand: new MyClass({
                operand: operand,
                expression: expression.operand
            }),
            expression: expression.expression
        });
    };
    ChainableUnaryExpression.prototype.associateRightIfSimpler = function () {
        if (!this.isAssociative())
            return null;
        var _a = this, op = _a.op, operand = _a.operand, expression = _a.expression;
        if (op !== operand.op)
            return null;
        var MyClass = this.constructor;
        var simpleExpression = new MyClass({
            operand: operand.expression,
            expression: expression
        }).simplify();
        if (simpleExpression instanceof LiteralExpression) {
            return new MyClass({
                operand: operand.operand,
                expression: simpleExpression
            }).simplify();
        }
        else {
            return null;
        }
    };
    ChainableUnaryExpression.prototype.pushIntoExternal = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (operand instanceof ExternalExpression) {
            return operand.addExpression(this.getAction());
        }
        if (expression instanceof ExternalExpression) {
            return expression.prePush(this.changeExpression(Expression._));
        }
        return null;
    };
    ChainableUnaryExpression.prototype.simplify = function () {
        if (this.simple)
            return this;
        var simpleOperand = this.operand.simplify();
        var simpleExpression = this.expression.simplify();
        var simpler = this.changeOperand(simpleOperand).changeExpression(simpleExpression);
        if (simpler.fullyDefined())
            return r(simpler.calc({}));
        if (this.isCommutative() && simpleOperand instanceof LiteralExpression) {
            var MyClass = this.constructor;
            var myValue = this.valueOf();
            myValue.operand = simpleExpression;
            myValue.expression = simpleOperand;
            return new MyClass(myValue).simplify();
        }
        var assLeft = simpler.associateLeft();
        if (assLeft)
            return assLeft.simplify();
        if (simpler instanceof ChainableUnaryExpression) {
            var specialSimpler = simpler.specialSimplify();
            if (specialSimpler !== simpler) {
                return specialSimpler.simplify();
            }
            else {
                simpler = specialSimpler;
            }
            if (simpler instanceof ChainableUnaryExpression) {
                var assRight = simpler.associateRightIfSimpler();
                if (assRight)
                    return assRight;
            }
        }
        simpler = simpler.markSimple();
        if (simpler instanceof ChainableExpression) {
            var pushedInExternal = simpler.pushIntoExternal();
            if (pushedInExternal)
                return pushedInExternal;
        }
        return simpler;
    };
    ChainableUnaryExpression.prototype.getArgumentExpressions = function () {
        return [this.expression];
    };
    ChainableUnaryExpression.prototype._substituteHelper = function (substitutionFn, indexer, depth, nestDiff, typeContext) {
        var sub = substitutionFn.call(this, this, indexer.index, depth, nestDiff);
        if (sub) {
            indexer.index += this.expressionCount();
            return {
                expression: sub,
                typeContext: sub.updateTypeContextIfNeeded(typeContext)
            };
        }
        else {
            indexer.index++;
        }
        depth++;
        var operandSubs = this.operand._substituteHelper(substitutionFn, indexer, depth, nestDiff, typeContext);
        var nestDiffNext = nestDiff + Number(this.isNester());
        var expressionSubs = this.expression._substituteHelper(substitutionFn, indexer, depth, nestDiffNext, this.isNester() ? operandSubs.typeContext : typeContext);
        var updatedThis = this.changeOperand(operandSubs.expression).changeExpression(expressionSubs.expression);
        return {
            expression: updatedThis,
            typeContext: updatedThis.updateTypeContextIfNeeded(operandSubs.typeContext, expressionSubs.typeContext)
        };
    };
    return ChainableUnaryExpression;
}(ChainableExpression));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






var LiteralExpression = exports.LiteralExpression = (function (_super) {
    __extends(LiteralExpression, _super);
    function LiteralExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        var value = parameters.value;
        this.value = value;
        this._ensureOp("literal");
        if (typeof this.value === 'undefined') {
            throw new TypeError("must have a `value`");
        }
        this.type = getValueType(value);
        this.simple = true;
    }
    LiteralExpression.fromJS = function (parameters) {
        var value = {
            op: parameters.op,
            type: parameters.type
        };
        if (!hasOwnProperty(parameters, 'value'))
            throw new Error('literal expression must have value');
        var v = parameters.value;
        if (isImmutableClass(v)) {
            value.value = v;
        }
        else {
            value.value = valueFromJS(v, parameters.type);
        }
        return new LiteralExpression(value);
    };
    LiteralExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.value = this.value;
        if (this.type)
            value.type = this.type;
        return value;
    };
    LiteralExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        if (this.value && this.value.toJS) {
            js.value = this.value.toJS();
            js.type = isSetType(this.type) ? 'SET' : this.type;
        }
        else {
            js.value = this.value;
            if (this.type === 'TIME')
                js.type = 'TIME';
        }
        return js;
    };
    LiteralExpression.prototype.toString = function () {
        var value = this.value;
        if (value instanceof Dataset && value.basis()) {
            return 'ply()';
        }
        else if (this.type === 'STRING') {
            return JSON.stringify(value);
        }
        else {
            return String(value);
        }
    };
    LiteralExpression.prototype.getFn = function () {
        var value = this.value;
        return function () { return value; };
    };
    LiteralExpression.prototype.calc = function (datum) {
        return this.value;
    };
    LiteralExpression.prototype.getJS = function (datumVar) {
        return JSON.stringify(this.value);
    };
    LiteralExpression.prototype.getSQL = function (dialect) {
        var value = this.value;
        if (value === null)
            return 'NULL';
        switch (this.type) {
            case 'STRING':
                return dialect.escapeLiteral(value);
            case 'BOOLEAN':
                return dialect.booleanToSQL(value);
            case 'NUMBER':
                return dialect.numberToSQL(value);
            case 'NUMBER_RANGE':
                return "" + dialect.numberToSQL(value.start);
            case 'TIME':
                return dialect.timeToSQL(value);
            case 'TIME_RANGE':
                return "" + dialect.timeToSQL(value.start);
            case 'STRING_RANGE':
                return dialect.escapeLiteral(value.start);
            case 'SET/STRING':
            case 'SET/NUMBER':
                return '(' + value.elements.map(function (v) { return typeof v === 'number' ? v : dialect.escapeLiteral(v); }).join(',') + ')';
            case 'SET/NUMBER_RANGE':
            case 'SET/TIME_RANGE':
                return 'FALSE';
            default:
                throw new Error("currently unsupported type: " + this.type);
        }
    };
    LiteralExpression.prototype.equals = function (other) {
        if (!_super.prototype.equals.call(this, other) || this.type !== other.type)
            return false;
        if (this.value && this.type !== 'DATASET') {
            if (this.value.equals) {
                return this.value.equals(other.value);
            }
            else if (this.value.toISOString && other.value.toISOString) {
                return this.value.valueOf() === other.value.valueOf();
            }
            else {
                return this.value === other.value;
            }
        }
        else {
            return this.value === other.value;
        }
    };
    LiteralExpression.prototype.updateTypeContext = function (typeContext) {
        var value = this.value;
        if (value instanceof Dataset) {
            var newTypeContext = value.getFullType();
            newTypeContext.parent = typeContext;
            return newTypeContext;
        }
        return typeContext;
    };
    LiteralExpression.prototype.getLiteralValue = function () {
        return this.value;
    };
    LiteralExpression.prototype.maxPossibleSplitValues = function () {
        var value = this.value;
        return value instanceof Set ? value.size() : 1;
    };
    LiteralExpression.prototype.bumpStringLiteralToTime = function () {
        if (this.type !== 'STRING')
            return this;
        var parse = parseISODate(this.value, Expression.defaultParserTimezone);
        if (!parse)
            throw new Error("could not parse '" + this.value + "' as time");
        return r(parse);
    };
    LiteralExpression.prototype.bumpStringLiteralToSetString = function () {
        if (this.type !== 'STRING')
            return this;
        return r(Set.fromJS([this.value]));
    };
    LiteralExpression.prototype.upgradeToType = function (targetType) {
        var _a = this, type = _a.type, value = _a.value;
        if (type === targetType)
            return this;
        if (type === 'STRING' && targetType === 'TIME') {
            var parse = parseISODate(value, Expression.defaultParserTimezone);
            if (!parse)
                throw new Error("can not upgrade " + value + " to TIME");
            return r(parse);
        }
        else if (type === 'STRING_RANGE' && targetType === 'TIME_RANGE') {
            var parseStart = parseISODate(value.start, Expression.defaultParserTimezone);
            if (!parseStart)
                throw new Error("can not upgrade " + value.start + " to TIME");
            var parseEnd = parseISODate(value.end, Expression.defaultParserTimezone);
            if (!parseEnd)
                throw new Error("can not upgrade " + value.end + " to TIME");
            return r(TimeRange.fromJS({
                start: parseStart,
                end: parseEnd,
                bounds: '[]'
            }));
        }
        throw new Error("can not upgrade " + type + " to " + targetType);
    };
    LiteralExpression.op = "Literal";
    return LiteralExpression;
}(Expression));
Expression.NULL = new LiteralExpression({ value: null });
Expression.ZERO = new LiteralExpression({ value: 0 });
Expression.ONE = new LiteralExpression({ value: 1 });
Expression.FALSE = new LiteralExpression({ value: false });
Expression.TRUE = new LiteralExpression({ value: true });
Expression.EMPTY_STRING = new LiteralExpression({ value: '' });
Expression.EMPTY_SET = new LiteralExpression({ value: Set.fromJS([]) });
Expression.register(LiteralExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var POSSIBLE_TYPES = exports.POSSIBLE_TYPES = {
    'NULL': 1,
    'BOOLEAN': 1,
    'NUMBER': 1,
    'TIME': 1,
    'STRING': 1,
    'NUMBER_RANGE': 1,
    'TIME_RANGE': 1,
    'SET': 1,
    'SET/NULL': 1,
    'SET/BOOLEAN': 1,
    'SET/NUMBER': 1,
    'SET/TIME': 1,
    'SET/STRING': 1,
    'SET/NUMBER_RANGE': 1,
    'SET/TIME_RANGE': 1,
    'DATASET': 1
};
var GENERATIONS_REGEXP = /^\^+/;
var TYPE_REGEXP = /:([A-Z\/_]+)$/;
var RefExpression = exports.RefExpression = (function (_super) {
    __extends(RefExpression, _super);
    function RefExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("ref");
        var name = parameters.name;
        if (typeof name !== 'string' || name.length === 0) {
            throw new TypeError("must have a nonempty `name`");
        }
        this.name = name;
        var nest = parameters.nest;
        if (typeof nest !== 'number') {
            throw new TypeError("must have nest");
        }
        if (nest < 0) {
            throw new Error("nest must be non-negative");
        }
        this.nest = nest;
        var myType = parameters.type;
        if (myType) {
            if (!RefExpression.validType(myType)) {
                throw new TypeError("unsupported type '" + myType + "'");
            }
            this.type = myType;
        }
        this.simple = true;
        this.ignoreCase = parameters.ignoreCase;
    }
    RefExpression.fromJS = function (parameters) {
        var value;
        if (hasOwnProperty(parameters, 'nest')) {
            value = parameters;
        }
        else {
            value = {
                op: 'ref',
                nest: 0,
                name: parameters.name,
                type: parameters.type,
                ignoreCase: parameters.ignoreCase
            };
        }
        return new RefExpression(value);
    };
    RefExpression.parse = function (str) {
        var refValue = { op: 'ref' };
        var match;
        match = str.match(GENERATIONS_REGEXP);
        if (match) {
            var nest = match[0].length;
            refValue.nest = nest;
            str = str.substr(nest);
        }
        else {
            refValue.nest = 0;
        }
        match = str.match(TYPE_REGEXP);
        if (match) {
            refValue.type = match[1];
            str = str.substr(0, str.length - match[0].length);
        }
        if (str[0] === '{' && str[str.length - 1] === '}') {
            str = str.substr(1, str.length - 2);
        }
        refValue.name = str;
        return new RefExpression(refValue);
    };
    RefExpression.validType = function (typeName) {
        return hasOwnProperty(POSSIBLE_TYPES, typeName);
    };
    RefExpression.toJavaScriptSafeName = function (variableName) {
        if (!RefExpression.SIMPLE_NAME_REGEXP.test(variableName)) {
            variableName = variableName.replace(/\W/g, function (c) { return ("$" + c.charCodeAt(0)); });
        }
        return '_' + variableName;
    };
    RefExpression.findProperty = function (obj, key) {
        return hasOwnProperty(obj, key) ? key : null;
    };
    RefExpression.findPropertyCI = function (obj, key) {
        var lowerKey = key.toLowerCase();
        if (obj == null)
            return null;
        return SimpleArray.find(Object.keys(obj), function (v) { return v.toLowerCase() === lowerKey; });
    };
    RefExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.name = this.name;
        value.nest = this.nest;
        if (this.type)
            value.type = this.type;
        if (this.ignoreCase)
            value.ignoreCase = true;
        return value;
    };
    RefExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.name = this.name;
        if (this.nest)
            js.nest = this.nest;
        if (this.type)
            js.type = this.type;
        if (this.ignoreCase)
            js.ignoreCase = true;
        return js;
    };
    RefExpression.prototype.toString = function () {
        var _a = this, name = _a.name, nest = _a.nest, type = _a.type, ignoreCase = _a.ignoreCase;
        var str = name;
        if (!RefExpression.SIMPLE_NAME_REGEXP.test(name)) {
            str = '{' + str + '}';
        }
        if (nest) {
            str = repeat('^', nest) + str;
        }
        if (type) {
            str += ':' + type;
        }
        return (ignoreCase ? 'i$' : '$') + str;
    };
    RefExpression.prototype.getFn = function () {
        var _a = this, name = _a.name, nest = _a.nest, ignoreCase = _a.ignoreCase;
        if (nest)
            throw new Error('can not getFn on a nested function');
        return function (d) {
            var property = ignoreCase ? RefExpression.findPropertyCI(d, name) : name;
            return property != null ? d[property] : null;
        };
    };
    RefExpression.prototype.calc = function (datum) {
        var _a = this, name = _a.name, nest = _a.nest, ignoreCase = _a.ignoreCase;
        if (nest)
            throw new Error('can not calc on a nested expression');
        var property = ignoreCase ? RefExpression.findPropertyCI(datum, name) : name;
        return property != null ? datum[property] : null;
    };
    RefExpression.prototype.getJS = function (datumVar) {
        var _a = this, name = _a.name, nest = _a.nest, ignoreCase = _a.ignoreCase;
        if (nest)
            throw new Error("can not call getJS on unresolved expression");
        if (ignoreCase)
            throw new Error("can not express ignore case as js expression");
        var expr;
        if (datumVar) {
            expr = datumVar.replace('[]', "[" + JSON.stringify(name) + "]");
        }
        else {
            expr = RefExpression.toJavaScriptSafeName(name);
        }
        if (this.type === 'NUMBER')
            expr = "(+" + expr + ")";
        return expr;
    };
    RefExpression.prototype.getSQL = function (dialect, minimal) {
        if (minimal === void 0) { minimal = false; }
        if (this.nest)
            throw new Error("can not call getSQL on unresolved expression: " + this);
        return dialect.escapeName(this.name);
    };
    RefExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.name === other.name &&
            this.nest === other.nest &&
            this.ignoreCase === other.ignoreCase;
    };
    RefExpression.prototype.changeInTypeContext = function (typeContext) {
        var _a = this, nest = _a.nest, ignoreCase = _a.ignoreCase, name = _a.name;
        var myTypeContext = typeContext;
        for (var i = nest; i > 0; i--) {
            myTypeContext = myTypeContext.parent;
            if (!myTypeContext)
                throw new Error('went too deep on ' + this.toString());
        }
        var myName = ignoreCase ? RefExpression.findPropertyCI(myTypeContext.datasetType, name) : name;
        if (myName == null)
            throw new Error('could not resolve ' + this.toString());
        var nestDiff = 0;
        while (myTypeContext && !hasOwnProperty(myTypeContext.datasetType, myName)) {
            myTypeContext = myTypeContext.parent;
            nestDiff++;
        }
        if (!myTypeContext) {
            throw new Error('could not resolve ' + this.toString());
        }
        var myFullType = myTypeContext.datasetType[myName];
        var myType = myFullType.type;
        if (this.type && this.type !== myType) {
            throw new TypeError("type mismatch in " + this + " (has: " + this.type + " needs: " + myType + ")");
        }
        if (!this.type || nestDiff > 0 || ignoreCase) {
            return new RefExpression({
                name: myName,
                nest: nest + nestDiff,
                type: myType
            });
        }
        else {
            return this;
        }
    };
    RefExpression.prototype.updateTypeContext = function (typeContext) {
        if (this.type !== 'DATASET')
            return typeContext;
        var _a = this, nest = _a.nest, name = _a.name;
        var myTypeContext = typeContext;
        for (var i = nest; i > 0; i--) {
            myTypeContext = myTypeContext.parent;
            if (!myTypeContext)
                throw new Error('went too deep on ' + this.toString());
        }
        var myFullType = myTypeContext.datasetType[name];
        return {
            parent: typeContext,
            type: 'DATASET',
            datasetType: myFullType.datasetType
        };
    };
    RefExpression.prototype.incrementNesting = function (by) {
        if (by === void 0) { by = 1; }
        var value = this.valueOf();
        value.nest += by;
        return new RefExpression(value);
    };
    RefExpression.prototype.upgradeToType = function (targetType) {
        var type = this.type;
        if (targetType === 'TIME' && (!type || type === 'STRING')) {
            return this.changeType(targetType);
        }
        return this;
    };
    RefExpression.prototype.toCaseInsensitive = function () {
        var value = this.valueOf();
        value.ignoreCase = true;
        return new RefExpression(value);
    };
    RefExpression.prototype.changeType = function (newType) {
        var value = this.valueOf();
        value.type = newType;
        return new RefExpression(value);
    };
    RefExpression.SIMPLE_NAME_REGEXP = /^([a-z_]\w*)$/i;
    RefExpression.op = "Ref";
    return RefExpression;
}(Expression));
Expression._ = new RefExpression({ name: '_', nest: 0 });
Expression.register(RefExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var ExternalExpression = exports.ExternalExpression = (function (_super) {
    __extends(ExternalExpression, _super);
    function ExternalExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        var external = parameters.external;
        if (!external)
            throw new Error('must have an external');
        this.external = external;
        this._ensureOp('external');
        this.type = external.mode === 'value' ? external.getValueType() : 'DATASET';
        this.simple = true;
    }
    ExternalExpression.fromJS = function (parameters) {
        var value = {
            op: parameters.op
        };
        value.external = External.fromJS(parameters.external);
        return new ExternalExpression(value);
    };
    ExternalExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.external = this.external;
        return value;
    };
    ExternalExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.external = this.external.toJS();
        return js;
    };
    ExternalExpression.prototype.toString = function () {
        return "E:" + this.external;
    };
    ExternalExpression.prototype.getFn = function () {
        throw new Error('should not call getFn on External');
    };
    ExternalExpression.prototype.calc = function (datum) {
        throw new Error('should not call calc on External');
    };
    ExternalExpression.prototype.getJS = function (datumVar) {
        throw new Error('should not call getJS on External');
    };
    ExternalExpression.prototype.getSQL = function (dialect) {
        throw new Error('should not call getSQL on External');
    };
    ExternalExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.external.equals(other.external);
    };
    ExternalExpression.prototype.updateTypeContext = function (typeContext) {
        var external = this.external;
        if (external.mode !== 'value') {
            var newTypeContext = this.external.getFullType();
            newTypeContext.parent = typeContext;
            return newTypeContext;
        }
        return typeContext;
    };
    ExternalExpression.prototype.unsuppress = function () {
        var value = this.valueOf();
        value.external = this.external.show();
        return new ExternalExpression(value);
    };
    ExternalExpression.prototype.addExpression = function (expression) {
        var newExternal = this.external.addExpression(expression);
        if (!newExternal)
            return null;
        return new ExternalExpression({ external: newExternal });
    };
    ExternalExpression.prototype.prePush = function (expression) {
        var newExternal = this.external.prePush(expression);
        if (!newExternal)
            return null;
        return new ExternalExpression({ external: newExternal });
    };
    ExternalExpression.prototype.maxPossibleSplitValues = function () {
        return Infinity;
    };
    ExternalExpression.op = "external";
    return ExternalExpression;
}(Expression));
Expression.register(ExternalExpression);


var HasTimezone = exports.HasTimezone = (function () {
    function HasTimezone() {
    }
    HasTimezone.prototype.getTimezone = function () {
        return this.timezone || Timezone.UTC;
    };
    HasTimezone.prototype.changeTimezone = function (timezone) {
        if (timezone.equals(this.timezone))
            return this;
        var value = this.valueOf();
        value.timezone = timezone;
        return Expression.fromValue(value);
    };
    HasTimezone.prototype.needsEnvironment = function () {
        return !this.timezone;
    };
    HasTimezone.prototype.defineEnvironment = function (environment) {
        if (!environment.timezone)
            environment = { timezone: Timezone.UTC };
        if (typeof environment.timezone === 'string')
            environment = { timezone: Timezone.fromJS(environment.timezone) };
        if (this.timezone || !environment.timezone)
            return this;
        return this.changeTimezone(environment.timezone);
    };
    return HasTimezone;
}());
var Aggregate = exports.Aggregate = (function () {
    function Aggregate() {
    }
    Aggregate.prototype.isAggregate = function () {
        return true;
    };
    Aggregate.prototype.isNester = function () {
        return true;
    };
    Aggregate.prototype.fullyDefined = function () {
        var expression = this.expression;
        return this.operand.isOp('literal') && (expression ? expression.resolved() : true);
    };
    return Aggregate;
}());
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var AbsoluteExpression = exports.AbsoluteExpression = (function (_super) {
    __extends(AbsoluteExpression, _super);
    function AbsoluteExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("absolute");
        this.type = 'NUMBER';
    }
    AbsoluteExpression.fromJS = function (parameters) {
        return new AbsoluteExpression(ChainableExpression.jsToValue(parameters));
    };
    AbsoluteExpression.prototype._calcChainableHelper = function (operandValue) {
        return operandValue ? Math.abs(operandValue) : null;
    };
    AbsoluteExpression.prototype._getJSChainableHelper = function (operandJS) {
        return "Math.abs(" + operandJS + ")";
    };
    AbsoluteExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return "ABS(" + operandSQL + ")";
    };
    AbsoluteExpression.prototype.specialSimplify = function () {
        var operand = this.operand;
        if (operand instanceof AbsoluteExpression)
            return operand;
        return this;
    };
    AbsoluteExpression.op = "Absolute";
    return AbsoluteExpression;
}(ChainableExpression));
Expression.register(AbsoluteExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var AddExpression = exports.AddExpression = (function (_super) {
    __extends(AddExpression, _super);
    function AddExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("add");
        this._checkOperandTypes('NUMBER');
        this._checkExpressionTypes('NUMBER');
        this.type = 'NUMBER';
    }
    AddExpression.fromJS = function (parameters) {
        return new AddExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    AddExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return (operandValue || 0) + (expressionValue || 0);
    };
    AddExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + "+" + expressionJS + ")";
    };
    AddExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + "+" + expressionSQL + ")";
    };
    AddExpression.prototype.isCommutative = function () {
        return true;
    };
    AddExpression.prototype.isAssociative = function () {
        return true;
    };
    AddExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression.equals(Expression.ZERO))
            return operand;
        return this;
    };
    AddExpression.op = "Add";
    return AddExpression;
}(ChainableUnaryExpression));
Expression.register(AddExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var IS_OR_IN = {
    'is': true,
    'in': true
};
var AndExpression = exports.AndExpression = (function (_super) {
    __extends(AndExpression, _super);
    function AndExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("and");
        this._checkOperandTypes('BOOLEAN');
        this._checkExpressionTypes('BOOLEAN');
        this.type = 'BOOLEAN';
    }
    AndExpression.fromJS = function (parameters) {
        return new AndExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    AndExpression.merge = function (ex1, ex2) {
        if (ex1.equals(ex2))
            return ex1;
        if (!IS_OR_IN[ex1.op] || !IS_OR_IN[ex2.op])
            return null;
        var _a = ex1, lhs1 = _a.operand, rhs1 = _a.expression;
        var _b = ex2, lhs2 = _b.operand, rhs2 = _b.expression;
        if (!lhs1.equals(lhs2) || !rhs1.isOp('literal') || !rhs2.isOp('literal'))
            return null;
        var intersect = Set.generalIntersect(rhs1.getLiteralValue(), rhs2.getLiteralValue());
        if (intersect === null)
            return null;
        return Expression.inOrIs(lhs1, intersect);
    };
    AndExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue && expressionValue;
    };
    AndExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + "&&" + expressionJS + ")";
    };
    AndExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + " AND " + expressionSQL + ")";
    };
    AndExpression.prototype.isCommutative = function () {
        return true;
    };
    AndExpression.prototype.isAssociative = function () {
        return true;
    };
    AndExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression.equals(Expression.FALSE))
            return Expression.FALSE;
        if (expression.equals(Expression.TRUE))
            return operand;
        if (operand instanceof AndExpression) {
            var andExpressions = operand.getExpressionList();
            for (var i = 0; i < andExpressions.length; i++) {
                var andExpression = andExpressions[i];
                var mergedExpression = AndExpression.merge(andExpression, expression);
                if (mergedExpression) {
                    andExpressions[i] = mergedExpression;
                    return Expression.and(andExpressions).simplify();
                }
            }
        }
        else {
            var mergedExpression = AndExpression.merge(operand, expression);
            if (mergedExpression)
                return mergedExpression;
        }
        return this;
    };
    AndExpression.prototype.extractFromAnd = function (matchFn) {
        if (!this.simple)
            return this.simplify().extractFromAnd(matchFn);
        var andExpressions = this.getExpressionList();
        var includedExpressions = [];
        var excludedExpressions = [];
        for (var _i = 0, andExpressions_1 = andExpressions; _i < andExpressions_1.length; _i++) {
            var ex = andExpressions_1[_i];
            if (matchFn(ex)) {
                includedExpressions.push(ex);
            }
            else {
                excludedExpressions.push(ex);
            }
        }
        return {
            extract: Expression.and(includedExpressions),
            rest: Expression.and(excludedExpressions)
        };
    };
    AndExpression.op = "And";
    return AndExpression;
}(ChainableUnaryExpression));
Expression.register(AndExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






var ApplyExpression = exports.ApplyExpression = (function (_super) {
    __extends(ApplyExpression, _super);
    function ApplyExpression(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this.name = parameters.name;
        this._ensureOp("apply");
        this._checkOperandTypes('DATASET');
        this.type = 'DATASET';
    }
    ApplyExpression.fromJS = function (parameters) {
        var value = ChainableUnaryExpression.jsToValue(parameters);
        value.name = parameters.name;
        return new ApplyExpression(value);
    };
    ApplyExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.name = this.name;
        return value;
    };
    ApplyExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.name = this.name;
        return js;
    };
    ApplyExpression.prototype.updateTypeContext = function (typeContext, expressionTypeContext) {
        var exprType = this.expression.type;
        typeContext.datasetType[this.name] = exprType === 'DATASET' ? expressionTypeContext : { type: exprType };
        return typeContext;
    };
    ApplyExpression.prototype._toStringParameters = function (indent) {
        var name = this.name;
        if (!RefExpression.SIMPLE_NAME_REGEXP.test(name))
            name = JSON.stringify(name);
        return [name, this.expression.toString(indent)];
    };
    ApplyExpression.prototype.toString = function (indent) {
        if (indent == null)
            return _super.prototype.toString.call(this);
        var param;
        if (this.expression.type === 'DATASET') {
            param = '\n    ' + this._toStringParameters(indent + 2).join(',\n    ') + '\n  ';
        }
        else {
            param = this._toStringParameters(indent).join(',');
        }
        var actionStr = indentBy("  .apply(" + param + ")", indent);
        return this.operand.toString(indent) + "\n" + actionStr;
    };
    ApplyExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.name === other.name;
    };
    ApplyExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        if (!operandValue)
            return null;
        var _a = this, name = _a.name, expression = _a.expression;
        return operandValue.apply(name, expression);
    };
    ApplyExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return expressionSQL + " AS " + dialect.escapeName(this.name);
    };
    ApplyExpression.prototype.isNester = function () {
        return true;
    };
    ApplyExpression.prototype.fullyDefined = function () {
        return false;
    };
    ApplyExpression.prototype.specialSimplify = function () {
        var _a = this, name = _a.name, operand = _a.operand, expression = _a.expression;
        if (expression instanceof RefExpression && expression.name === name && expression.nest === 0) {
            return operand;
        }
        if (expression.isAggregate() &&
            operand instanceof ApplyExpression &&
            !operand.expression.isAggregate() &&
            expression.getFreeReferences().indexOf(operand.name) === -1) {
            return this.swapWithOperand();
        }
        var dataset = operand.getLiteralValue();
        if (dataset instanceof Dataset && expression.resolved()) {
            var freeReferences = expression.getFreeReferences();
            var datum_1 = dataset.data[0];
            if (datum_1 && freeReferences.some(function (freeReference) { return datum_1[freeReference] instanceof Expression; })) {
                return this;
            }
            dataset = dataset.applyFn(name, function (d) {
                var simp = expression.resolve(d).simplify();
                if (simp instanceof ExternalExpression)
                    return simp.external;
                if (simp instanceof LiteralExpression)
                    return simp.value;
                return simp;
            }, expression.type);
            return r(dataset);
        }
        return this;
    };
    ApplyExpression.op = "Apply";
    return ApplyExpression;
}(ChainableUnaryExpression));
Expression.register(ApplyExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var AverageExpression = exports.AverageExpression = (function (_super) {
    __extends(AverageExpression, _super);
    function AverageExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("average");
        this._checkOperandTypes('DATASET');
        this._checkExpressionTypes('NUMBER');
        this.type = 'NUMBER';
    }
    AverageExpression.fromJS = function (parameters) {
        return new AverageExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    AverageExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.average(this.expression) : null;
    };
    AverageExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "AVG(" + dialect.aggregateFilterIfNeeded(operandSQL, expressionSQL) + ")";
    };
    AverageExpression.prototype.decomposeAverage = function (countEx) {
        var _a = this, operand = _a.operand, expression = _a.expression;
        return operand.sum(expression).divide(countEx ? operand.sum(countEx) : operand.count());
    };
    AverageExpression.op = "Average";
    return AverageExpression;
}(ChainableUnaryExpression));
Expression.applyMixins(AverageExpression, [Aggregate]);
Expression.register(AverageExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var CardinalityExpression = exports.CardinalityExpression = (function (_super) {
    __extends(CardinalityExpression, _super);
    function CardinalityExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("cardinality");
        this._checkOperandTypes('SET/STRING', 'SET/STRING_RANGE', 'SET/NUMBER', 'SET/NUMBER_RANGE', 'SET/TIME', 'SET/TIME_RANGE');
        this.type = 'NUMBER';
    }
    CardinalityExpression.fromJS = function (parameters) {
        return new CardinalityExpression(ChainableExpression.jsToValue(parameters));
    };
    CardinalityExpression.prototype._calcChainableHelper = function (operandValue) {
        return operandValue ? operandValue.cardinality() : operandValue;
    };
    CardinalityExpression.prototype._getJSChainableHelper = function (operandJS) {
        return Expression.jsNullSafetyUnary(operandJS, function (input) { return (input + ".length"); });
    };
    CardinalityExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return "cardinality(" + operandSQL + ")";
    };
    CardinalityExpression.op = "Cardinality";
    return CardinalityExpression;
}(ChainableExpression));
Expression.register(CardinalityExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var CAST_TYPE_TO_FN = {
    TIME: {
        NUMBER: function (n) { return new Date(n); }
    },
    NUMBER: {
        TIME: function (n) { return Date.parse(n.toString()); },
        _: function (s) { return Number(s); }
    },
    STRING: {
        _: function (v) { return '' + v; }
    }
};
var CAST_TYPE_TO_JS = {
    TIME: {
        NUMBER: function (operandJS) { return ("new Date(" + operandJS + ")"); }
    },
    NUMBER: {
        _: function (s) { return ("+(" + s + ")"); }
    },
    STRING: {
        _: function (operandJS) { return ("('' + " + operandJS + ")"); }
    }
};
var CastExpression = exports.CastExpression = (function (_super) {
    __extends(CastExpression, _super);
    function CastExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this.outputType = parameters.outputType;
        this._ensureOp("cast");
        if (typeof this.outputType !== 'string') {
            throw new Error("`outputType` must be a string");
        }
        this.type = this.outputType;
    }
    CastExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.outputType = parameters.outputType || parameters.castType;
        return new CastExpression(value);
    };
    CastExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.outputType = this.outputType;
        return value;
    };
    CastExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.outputType = this.outputType;
        return js;
    };
    CastExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.outputType === other.outputType;
    };
    CastExpression.prototype._toStringParameters = function (indent) {
        return [this.outputType];
    };
    CastExpression.prototype._calcChainableHelper = function (operandValue) {
        var outputType = this.outputType;
        var inputType = this.operand.type;
        if (outputType === inputType)
            return operandValue;
        var caster = CAST_TYPE_TO_FN[outputType];
        if (!caster)
            throw new Error("unsupported cast type in calc '" + outputType + "'");
        var castFn = caster[inputType] || caster['_'];
        if (!castFn)
            throw new Error("unsupported cast from " + inputType + " to '" + outputType + "'");
        return operandValue ? castFn(operandValue) : null;
    };
    CastExpression.prototype._getJSChainableHelper = function (operandJS) {
        var outputType = this.outputType;
        var inputType = this.operand.type;
        if (outputType === inputType)
            return operandJS;
        var castJS = CAST_TYPE_TO_JS[outputType];
        if (!castJS)
            throw new Error("unsupported cast type in getJS '" + outputType + "'");
        var js = castJS[inputType] || castJS['_'];
        if (!js)
            throw new Error("unsupported combo in getJS of cast action: " + inputType + " to " + outputType);
        return js(operandJS);
    };
    CastExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return dialect.castExpression(this.operand.type, operandSQL, this.outputType);
    };
    CastExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, outputType = _a.outputType;
        if (operand.type === outputType)
            return operand;
        return this;
    };
    CastExpression.op = "Cast";
    return CastExpression;
}(ChainableExpression));
Expression.register(CastExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var CollectExpression = exports.CollectExpression = (function (_super) {
    __extends(CollectExpression, _super);
    function CollectExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("collect");
        this._checkOperandTypes('DATASET');
        this._checkExpressionTypes('BOOLEAN', 'NUMBER', 'TIME', 'STRING', 'NUMBER_RANGE', 'TIME_RANGE', 'STRING_RANGE');
        this.type = wrapSetType(this.expression.type);
    }
    CollectExpression.fromJS = function (parameters) {
        return new CollectExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    CollectExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.collect(this.expression) : null;
    };
    CollectExpression.op = "Collect";
    return CollectExpression;
}(ChainableUnaryExpression));
Expression.applyMixins(CollectExpression, [Aggregate]);
Expression.register(CollectExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var ConcatExpression = exports.ConcatExpression = (function (_super) {
    __extends(ConcatExpression, _super);
    function ConcatExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("concat");
        this._checkOperandTypes('STRING', 'SET/STRING');
        this._checkExpressionTypes('STRING');
        this.type = this.operand.type;
    }
    ConcatExpression.fromJS = function (parameters) {
        return new ConcatExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    ConcatExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        if (operandValue === null || expressionValue === null)
            return null;
        return '' + operandValue + expressionValue;
    };
    ConcatExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return Expression.jsNullSafetyBinary(operandJS, expressionJS, (function (a, b) { return (a + "+" + b); }), operandJS[0] === '"', expressionJS[0] === '"');
    };
    ConcatExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return dialect.concatExpression(operandSQL, expressionSQL);
    };
    ConcatExpression.prototype.isAssociative = function () {
        return true;
    };
    ConcatExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (operand.equals(Expression.EMPTY_STRING))
            return expression;
        if (expression.equals(Expression.EMPTY_STRING))
            return operand;
        return this;
    };
    ConcatExpression.op = "Concat";
    return ConcatExpression;
}(ChainableUnaryExpression));
Expression.register(ConcatExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var ContainsExpression = exports.ContainsExpression = (function (_super) {
    __extends(ContainsExpression, _super);
    function ContainsExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._checkOperandTypes('STRING', 'SET/STRING');
        this._checkExpressionTypes('STRING');
        var compare = parameters.compare;
        if (!compare) {
            compare = ContainsExpression.NORMAL;
        }
        else if (compare !== ContainsExpression.NORMAL && compare !== ContainsExpression.IGNORE_CASE) {
            throw new Error("compare must be '" + ContainsExpression.NORMAL + "' or '" + ContainsExpression.IGNORE_CASE + "'");
        }
        this.compare = compare;
        this._ensureOp("contains");
        this.type = 'BOOLEAN';
    }
    ContainsExpression.fromJS = function (parameters) {
        var value = ChainableUnaryExpression.jsToValue(parameters);
        value.compare = parameters.compare;
        return new ContainsExpression(value);
    };
    ContainsExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.compare = this.compare;
        return value;
    };
    ContainsExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.compare = this.compare;
        return js;
    };
    ContainsExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.compare === other.compare;
    };
    ContainsExpression.prototype._toStringParameters = function (indent) {
        return [this.expression.toString(indent), this.compare];
    };
    ContainsExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        if (this.compare === ContainsExpression.NORMAL) {
            return String(operandValue).indexOf(expressionValue) > -1;
        }
        else {
            return String(operandValue).toLowerCase().indexOf(String(expressionValue).toLowerCase()) > -1;
        }
    };
    ContainsExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        var combine;
        if (this.compare === ContainsExpression.NORMAL) {
            combine = function (lhs, rhs) { return ("(''+" + lhs + ").indexOf(" + rhs + ")>-1"); };
        }
        else {
            combine = function (lhs, rhs) { return ("(''+" + lhs + ").toLowerCase().indexOf((''+" + rhs + ").toLowerCase())>-1"); };
        }
        return Expression.jsNullSafetyBinary(operandJS, expressionJS, combine, operandJS[0] === '"', expressionJS[0] === '"');
    };
    ContainsExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        if (this.compare === ContainsExpression.IGNORE_CASE) {
            expressionSQL = "LOWER(" + expressionSQL + ")";
            operandSQL = "LOWER(" + operandSQL + ")";
        }
        return dialect.containsExpression(expressionSQL, operandSQL);
    };
    ContainsExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (operand instanceof TransformCaseExpression && expression instanceof TransformCaseExpression) {
            var x = operand.operand, tt1 = operand.transformType;
            var y = expression.operand, tt2 = expression.transformType;
            if (tt1 === tt2) {
                return x.contains(y, ContainsExpression.IGNORE_CASE);
            }
        }
        return this;
    };
    ContainsExpression.NORMAL = 'normal';
    ContainsExpression.IGNORE_CASE = 'ignoreCase';
    ContainsExpression.op = "Contains";
    return ContainsExpression;
}(ChainableUnaryExpression));
Expression.register(ContainsExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var CountExpression = exports.CountExpression = (function (_super) {
    __extends(CountExpression, _super);
    function CountExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("count");
        this._checkOperandTypes('DATASET');
        this.type = 'NUMBER';
    }
    CountExpression.fromJS = function (parameters) {
        return new CountExpression(ChainableExpression.jsToValue(parameters));
    };
    CountExpression.prototype.calc = function (datum) {
        var inV = this.operand.calc(datum);
        return inV ? inV.count() : 0;
    };
    CountExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return operandSQL.indexOf(' WHERE ') === -1 ? "COUNT(*)" : "SUM(" + dialect.aggregateFilterIfNeeded(operandSQL, '1') + ")";
    };
    CountExpression.op = "Count";
    return CountExpression;
}(ChainableExpression));
Expression.applyMixins(CountExpression, [Aggregate]);
Expression.register(CountExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var CountDistinctExpression = exports.CountDistinctExpression = (function (_super) {
    __extends(CountDistinctExpression, _super);
    function CountDistinctExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("countDistinct");
        this._checkOperandTypes('DATASET');
        this.type = 'NUMBER';
    }
    CountDistinctExpression.fromJS = function (parameters) {
        return new CountDistinctExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    CountDistinctExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.countDistinct(this.expression) : null;
    };
    CountDistinctExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "COUNT(DISTINCT " + dialect.aggregateFilterIfNeeded(operandSQL, expressionSQL, 'NULL') + ")";
    };
    CountDistinctExpression.op = "CountDistinct";
    return CountDistinctExpression;
}(ChainableUnaryExpression));
Expression.applyMixins(CountDistinctExpression, [Aggregate]);
Expression.register(CountDistinctExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var CustomAggregateExpression = exports.CustomAggregateExpression = (function (_super) {
    __extends(CustomAggregateExpression, _super);
    function CustomAggregateExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this.custom = parameters.custom;
        this._ensureOp("customAggregate");
        this._checkOperandTypes('DATASET');
        this.type = 'NUMBER';
    }
    CustomAggregateExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.custom = parameters.custom;
        return new CustomAggregateExpression(value);
    };
    CustomAggregateExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.custom = this.custom;
        return value;
    };
    CustomAggregateExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.custom = this.custom;
        return js;
    };
    CustomAggregateExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.custom === other.custom;
    };
    CustomAggregateExpression.prototype._toStringParameters = function (indent) {
        return [this.custom];
    };
    CustomAggregateExpression.prototype._calcChainableHelper = function (operandValue) {
        throw new Error('can not compute on custom action');
    };
    CustomAggregateExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        throw new Error('custom action not implemented');
    };
    CustomAggregateExpression.op = "CustomAggregate";
    return CustomAggregateExpression;
}(ChainableExpression));
Expression.applyMixins(CustomAggregateExpression, [Aggregate]);
Expression.register(CustomAggregateExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var CustomTransformExpression = exports.CustomTransformExpression = (function (_super) {
    __extends(CustomTransformExpression, _super);
    function CustomTransformExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("customTransform");
        this.custom = parameters.custom;
        if (parameters.outputType)
            this.outputType = parameters.outputType;
        this.type = this.outputType || this.operand.type;
    }
    CustomTransformExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.custom = parameters.custom;
        if (parameters.outputType)
            value.outputType = parameters.outputType;
        return new CustomTransformExpression(value);
    };
    CustomTransformExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.custom = this.custom;
        if (this.outputType)
            value.outputType = this.outputType;
        return value;
    };
    CustomTransformExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.custom = this.custom;
        if (this.outputType)
            js.outputType = this.outputType;
        return js;
    };
    CustomTransformExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.custom === other.custom &&
            this.outputType === other.outputType;
    };
    CustomTransformExpression.prototype._toStringParameters = function (indent) {
        var param = [this.custom];
        if (this.outputType)
            param.push(this.outputType);
        return param;
    };
    CustomTransformExpression.prototype._calcChainableHelper = function (operandValue) {
        throw new Error('can not calc on custom transform action');
    };
    CustomTransformExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        throw new Error("Custom transform not supported in SQL");
    };
    CustomTransformExpression.prototype._getJSChainableHelper = function (operandJS) {
        throw new Error("Custom transform can't yet be expressed as JS");
    };
    CustomTransformExpression.op = "CustomTransform";
    return CustomTransformExpression;
}(ChainableExpression));
Expression.register(CustomTransformExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var DivideExpression = exports.DivideExpression = (function (_super) {
    __extends(DivideExpression, _super);
    function DivideExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("divide");
        this._checkOperandTypes('NUMBER');
        this._checkExpressionTypes('NUMBER');
        this.type = 'NUMBER';
    }
    DivideExpression.fromJS = function (parameters) {
        return new DivideExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    DivideExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        var v = (operandValue || 0) / (expressionValue || 0);
        return isNaN(v) ? null : v;
    };
    DivideExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + "/" + expressionJS + ")";
    };
    DivideExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + "/" + expressionSQL + ")";
    };
    DivideExpression.prototype.specialSimplify = function () {
        if (this.expression.equals(Expression.ONE))
            return this.operand;
        return this;
    };
    DivideExpression.op = "Divide";
    return DivideExpression;
}(ChainableUnaryExpression));
Expression.register(DivideExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var ExtractExpression = exports.ExtractExpression = (function (_super) {
    __extends(ExtractExpression, _super);
    function ExtractExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this.regexp = parameters.regexp;
        this._ensureOp("extract");
        this._checkOperandTypes('STRING', 'SET/STRING');
        this.type = this.operand.type;
    }
    ExtractExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.regexp = parameters.regexp;
        return new ExtractExpression(value);
    };
    ExtractExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.regexp = this.regexp;
        return value;
    };
    ExtractExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.regexp = this.regexp;
        return js;
    };
    ExtractExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.regexp === other.regexp;
    };
    ExtractExpression.prototype._toStringParameters = function (indent) {
        return [this.regexp];
    };
    ExtractExpression.prototype._calcChainableHelper = function (operandValue) {
        var re = new RegExp(this.regexp);
        return (String(operandValue).match(re) || [])[1] || null;
    };
    ExtractExpression.prototype._getJSChainableHelper = function (operandJS) {
        return "((''+" + operandJS + ").match(/" + this.regexp + "/) || [])[1] || null";
    };
    ExtractExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return dialect.extractExpression(operandSQL, this.regexp);
    };
    ExtractExpression.op = "Extract";
    return ExtractExpression;
}(ChainableExpression));
Expression.register(ExtractExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var FallbackExpression = exports.FallbackExpression = (function (_super) {
    __extends(FallbackExpression, _super);
    function FallbackExpression(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this._ensureOp("fallback");
        this._checkOperandExpressionTypesAlign();
        this.type = this.operand.type || this.expression.type;
    }
    FallbackExpression.fromJS = function (parameters) {
        return new FallbackExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    FallbackExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue !== null ? operandValue : expressionValue;
    };
    FallbackExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(_ = " + operandJS + ", (_ === null ? " + expressionJS + " : _))";
    };
    FallbackExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "COALESCE(" + operandSQL + ", " + expressionSQL + ")";
    };
    FallbackExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression.equals(Expression.NULL))
            return operand;
        if (operand.equals(Expression.NULL))
            return expression;
        if (operand.equals(expression))
            return operand;
        if (operand.getLiteralValue() != null)
            return operand;
        return this;
    };
    FallbackExpression.op = "Fallback";
    return FallbackExpression;
}(ChainableUnaryExpression));
Expression.register(FallbackExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





var FilterExpression = exports.FilterExpression = (function (_super) {
    __extends(FilterExpression, _super);
    function FilterExpression(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this._ensureOp("filter");
        this._checkExpressionTypes('BOOLEAN');
        this.type = 'DATASET';
    }
    FilterExpression.fromJS = function (parameters) {
        var value = ChainableUnaryExpression.jsToValue(parameters);
        return new FilterExpression(value);
    };
    FilterExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.filter(this.expression) : null;
    };
    FilterExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return operandSQL + " WHERE " + expressionSQL;
    };
    FilterExpression.prototype.isNester = function () {
        return true;
    };
    FilterExpression.prototype.fullyDefined = function () {
        return this.operand.isOp('literal') && this.expression.resolved();
    };
    FilterExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression.equals(Expression.TRUE))
            return operand;
        if (operand instanceof FilterExpression) {
            var x = operand.operand, a = operand.expression;
            return x.filter(a.and(expression));
        }
        if (operand instanceof ApplyExpression) {
            return expression.getFreeReferences().indexOf(operand.name) === -1 ? this.swapWithOperand() : this;
        }
        if (operand instanceof SplitExpression && operand.isLinear()) {
            var x = operand.operand, splits_1 = operand.splits, dataName = operand.dataName;
            var newFilter = expression.substitute(function (ex) {
                if (ex instanceof RefExpression && splits_1[ex.name])
                    return splits_1[ex.name];
                return null;
            });
            return x.filter(newFilter).split(splits_1, dataName);
        }
        if (operand instanceof SortExpression)
            return this.swapWithOperand();
        return this;
    };
    FilterExpression.op = "Filter";
    return FilterExpression;
}(ChainableUnaryExpression));
Expression.register(FilterExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var GreaterThanExpression = exports.GreaterThanExpression = (function (_super) {
    __extends(GreaterThanExpression, _super);
    function GreaterThanExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("greaterThan");
        this._checkOperandTypes('NUMBER', 'TIME', 'STRING');
        this._checkExpressionTypes('NUMBER', 'TIME', 'STRING');
        this._bumpOperandExpressionToTime();
        this._checkOperandExpressionTypesAlign();
        this.type = 'BOOLEAN';
    }
    GreaterThanExpression.fromJS = function (parameters) {
        return new GreaterThanExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    GreaterThanExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue > expressionValue;
    };
    GreaterThanExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + ">" + expressionJS + ")";
    };
    GreaterThanExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + ">" + expressionSQL + ")";
    };
    GreaterThanExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression instanceof LiteralExpression) {
            return operand.in(r(Range.fromJS({ start: expression.value, end: null, bounds: '()' })));
        }
        if (operand instanceof LiteralExpression) {
            return expression.in(r(Range.fromJS({ start: null, end: operand.value, bounds: '()' })));
        }
        return this;
    };
    GreaterThanExpression.op = "GreaterThan";
    return GreaterThanExpression;
}(ChainableUnaryExpression));
Expression.register(GreaterThanExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var GreaterThanOrEqualExpression = exports.GreaterThanOrEqualExpression = (function (_super) {
    __extends(GreaterThanOrEqualExpression, _super);
    function GreaterThanOrEqualExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("greaterThanOrEqual");
        this._checkOperandTypes('NUMBER', 'TIME', 'STRING');
        this._checkExpressionTypes('NUMBER', 'TIME', 'STRING');
        this._bumpOperandExpressionToTime();
        this._checkOperandExpressionTypesAlign();
        this.type = 'BOOLEAN';
    }
    GreaterThanOrEqualExpression.fromJS = function (parameters) {
        return new GreaterThanOrEqualExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    GreaterThanOrEqualExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue >= expressionValue;
    };
    GreaterThanOrEqualExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + ">=" + expressionJS + ")";
    };
    GreaterThanOrEqualExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + ">=" + expressionSQL + ")";
    };
    GreaterThanOrEqualExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression instanceof LiteralExpression) {
            return operand.in(r(Range.fromJS({ start: expression.value, end: null, bounds: '[)' })));
        }
        if (operand instanceof LiteralExpression) {
            return expression.in(r(Range.fromJS({ start: null, end: operand.value, bounds: '(]' })));
        }
        return this;
    };
    GreaterThanOrEqualExpression.op = "GreaterThanOrEqual";
    return GreaterThanOrEqualExpression;
}(ChainableUnaryExpression));
Expression.register(GreaterThanOrEqualExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






var InExpression = exports.InExpression = (function (_super) {
    __extends(InExpression, _super);
    function InExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("in");
        var operandType = this.operand.type;
        var expression = this.expression;
        if (operandType) {
            if (!((!isSetType(operandType) && expression.canHaveType('SET')) ||
                (operandType === 'NUMBER' && expression.canHaveType('NUMBER_RANGE')) ||
                (operandType === 'STRING' && expression.canHaveType('STRING_RANGE')) ||
                (operandType === 'TIME' && expression.canHaveType('TIME_RANGE')))) {
                throw new TypeError("in expression " + this + " has a bad type combination " + operandType + " IN " + (expression.type || '*'));
            }
        }
        else {
            if (!(expression.canHaveType('NUMBER_RANGE') || expression.canHaveType('STRING_RANGE') || expression.canHaveType('TIME_RANGE') || expression.canHaveType('SET'))) {
                throw new TypeError("in expression has invalid expression type " + expression.type);
            }
        }
        this.type = 'BOOLEAN';
    }
    InExpression.fromJS = function (parameters) {
        return new InExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    InExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        if (!expressionValue)
            return null;
        return expressionValue.contains(operandValue);
    };
    InExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        var expression = this.expression;
        if (expression instanceof LiteralExpression) {
            switch (expression.type) {
                case 'NUMBER_RANGE':
                case 'STRING_RANGE':
                case 'TIME_RANGE':
                    var range = expression.value;
                    var r0 = range.start;
                    var r1 = range.end;
                    var bounds = range.bounds;
                    var cmpStrings = [];
                    if (r0 != null) {
                        cmpStrings.push(JSON.stringify(r0) + " " + (bounds[0] === '(' ? '<' : '<=') + " _");
                    }
                    if (r1 != null) {
                        cmpStrings.push("_ " + (bounds[1] === ')' ? '<' : '<=') + " " + JSON.stringify(r1));
                    }
                    return "(_=" + operandJS + ", " + cmpStrings.join(' && ') + ")";
                case 'SET/STRING':
                    var valueSet = expression.value;
                    return JSON.stringify(valueSet.elements) + ".indexOf(" + operandJS + ")>-1";
                default:
                    throw new Error("can not convert " + this + " to JS function, unsupported type " + expression.type);
            }
        }
        throw new Error("can not convert " + this + " to JS function");
    };
    InExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        var expression = this.expression;
        var expressionType = expression.type;
        switch (expressionType) {
            case 'NUMBER_RANGE':
            case 'TIME_RANGE':
                if (expression instanceof LiteralExpression) {
                    var range = expression.value;
                    return dialect.inExpression(operandSQL, dialect.numberOrTimeToSQL(range.start), dialect.numberOrTimeToSQL(range.end), range.bounds);
                }
                throw new Error("can not convert action to SQL " + this);
            case 'STRING_RANGE':
                if (expression instanceof LiteralExpression) {
                    var stringRange = expression.value;
                    return dialect.inExpression(operandSQL, dialect.escapeLiteral(stringRange.start), dialect.escapeLiteral(stringRange.end), stringRange.bounds);
                }
                throw new Error("can not convert action to SQL " + this);
            case 'SET/STRING':
            case 'SET/NUMBER':
                return operandSQL + " IN " + expressionSQL;
            case 'SET/NUMBER_RANGE':
            case 'SET/TIME_RANGE':
                if (expression instanceof LiteralExpression) {
                    var setOfRange = expression.value;
                    return setOfRange.elements.map(function (range) {
                        return dialect.inExpression(operandSQL, dialect.numberOrTimeToSQL(range.start), dialect.numberOrTimeToSQL(range.end), range.bounds);
                    }).join(' OR ');
                }
                throw new Error("can not convert action to SQL " + this);
            default:
                throw new Error("can not convert action to SQL " + this);
        }
    };
    InExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        var literalValue = expression.getLiteralValue();
        if (literalValue instanceof Set) {
            if (literalValue.empty())
                return Expression.FALSE;
            if (literalValue && !literalValue.isNullSet()) {
                if (literalValue.size() === 1) {
                    if (wrapSetType(operand.type) === expression.type) {
                        return operand.is(r(literalValue.elements[0]));
                    }
                    else if (wrapSetType((operand.type + '_RANGE')) === expression.type) {
                        return operand.in(r(literalValue.elements[0]));
                    }
                    else {
                        return this;
                    }
                }
                var unifiedSetValue = literalValue.unifyElements();
                if (!literalValue.equals(unifiedSetValue)) {
                    return operand.in(r(unifiedSetValue));
                }
            }
        }
        if (operand instanceof IndexOfExpression && literalValue instanceof NumberRange) {
            var x = operand.operand, y = operand.expression;
            var start = literalValue.start, end = literalValue.end, bounds = literalValue.bounds;
            if ((start < 0 && end === null) || (start === 0 && end === null && bounds[0] === '[')) {
                return x.contains(y);
            }
        }
        return this;
    };
    InExpression.op = "In";
    return InExpression;
}(ChainableUnaryExpression));
Expression.register(InExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






var IsExpression = exports.IsExpression = (function (_super) {
    __extends(IsExpression, _super);
    function IsExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("is");
        this._checkOperandExpressionTypesAlign();
        this.type = 'BOOLEAN';
    }
    IsExpression.fromJS = function (parameters) {
        return new IsExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    IsExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue === expressionValue;
    };
    IsExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + "===" + expressionJS + ")";
    };
    IsExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return dialect.isNotDistinctFromExpression(operandSQL, expressionSQL);
    };
    IsExpression.prototype.isCommutative = function () {
        return true;
    };
    IsExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (operand.equals(expression))
            return Expression.TRUE;
        var literalValue = expression.getLiteralValue();
        if (literalValue) {
            if (operand instanceof IndexOfExpression && literalValue === -1) {
                var x = operand.operand, y = operand.expression;
                return x.contains(y).not();
            }
            if (operand instanceof TimeBucketExpression && literalValue instanceof TimeRange && operand.timezone) {
                var x = operand.operand, duration = operand.duration, timezone = operand.timezone;
                if (literalValue.start !== null && TimeRange.timeBucket(literalValue.start, duration, timezone).equals(literalValue)) {
                    return x.in(expression);
                }
                else {
                    return Expression.FALSE;
                }
            }
            if (operand instanceof NumberBucketExpression && literalValue instanceof NumberRange) {
                var x = operand.operand, size = operand.size, offset = operand.offset;
                if (literalValue.start !== null && NumberRange.numberBucket(literalValue.start, size, offset).equals(literalValue)) {
                    return x.in(expression);
                }
                else {
                    return Expression.FALSE;
                }
            }
            if (operand instanceof FallbackExpression) {
                var x = operand.operand, y = operand.expression;
                if (y.isOp('literal') && !y.equals(expression)) {
                    return this.changeOperand(x);
                }
            }
        }
        return this;
    };
    IsExpression.op = "Is";
    return IsExpression;
}(ChainableUnaryExpression));
Expression.register(IsExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var JoinExpression = exports.JoinExpression = (function (_super) {
    __extends(JoinExpression, _super);
    function JoinExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("join");
        this._checkOperandTypes('DATASET');
        this._checkExpressionTypes('DATASET');
        this.type = 'DATASET';
    }
    JoinExpression.fromJS = function (parameters) {
        return new JoinExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    JoinExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.join(expressionValue) : null;
    };
    JoinExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        throw new Error('not possible');
    };
    JoinExpression.op = "Join";
    return JoinExpression;
}(ChainableUnaryExpression));
Expression.register(JoinExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var LengthExpression = exports.LengthExpression = (function (_super) {
    __extends(LengthExpression, _super);
    function LengthExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("length");
        this._checkOperandTypes('STRING');
        this.type = 'NUMBER';
    }
    LengthExpression.fromJS = function (parameters) {
        return new LengthExpression(ChainableExpression.jsToValue(parameters));
    };
    LengthExpression.prototype._calcChainableHelper = function (operandValue) {
        return operandValue ? operandValue.length : null;
    };
    LengthExpression.prototype._getJSChainableHelper = function (operandJS) {
        return Expression.jsNullSafetyUnary(operandJS, function (input) { return (input + ".length"); });
    };
    LengthExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return dialect.lengthExpression(operandSQL);
    };
    LengthExpression.op = "Length";
    return LengthExpression;
}(ChainableExpression));
Expression.register(LengthExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var LessThanExpression = exports.LessThanExpression = (function (_super) {
    __extends(LessThanExpression, _super);
    function LessThanExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("lessThan");
        this._checkOperandTypes('NUMBER', 'TIME', 'STRING');
        this._checkExpressionTypes('NUMBER', 'TIME', 'STRING');
        this._bumpOperandExpressionToTime();
        this._checkOperandExpressionTypesAlign();
        this.type = 'BOOLEAN';
    }
    LessThanExpression.fromJS = function (parameters) {
        return new LessThanExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    LessThanExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue < expressionValue;
    };
    LessThanExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + "<" + expressionJS + ")";
    };
    LessThanExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + "<" + expressionSQL + ")";
    };
    LessThanExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression instanceof LiteralExpression) {
            return operand.in(r(Range.fromJS({ start: null, end: expression.value, bounds: '()' })));
        }
        if (operand instanceof LiteralExpression) {
            return expression.in(r(Range.fromJS({ start: operand.value, end: null, bounds: '()' })));
        }
        return this;
    };
    LessThanExpression.op = "LessThan";
    return LessThanExpression;
}(ChainableUnaryExpression));
Expression.register(LessThanExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var LessThanOrEqualExpression = exports.LessThanOrEqualExpression = (function (_super) {
    __extends(LessThanOrEqualExpression, _super);
    function LessThanOrEqualExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("lessThanOrEqual");
        this._checkOperandTypes('NUMBER', 'TIME', 'STRING');
        this._checkExpressionTypes('NUMBER', 'TIME', 'STRING');
        this._bumpOperandExpressionToTime();
        this._checkOperandExpressionTypesAlign();
        this.type = 'BOOLEAN';
    }
    LessThanOrEqualExpression.fromJS = function (parameters) {
        return new LessThanOrEqualExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    LessThanOrEqualExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue <= expressionValue;
    };
    LessThanOrEqualExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + "<=" + expressionJS + ")";
    };
    LessThanOrEqualExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + "<=" + expressionSQL + ")";
    };
    LessThanOrEqualExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression instanceof LiteralExpression) {
            return operand.in(r(Range.fromJS({ start: null, end: expression.value, bounds: '(]' })));
        }
        if (operand instanceof LiteralExpression) {
            return expression.in(r(Range.fromJS({ start: operand.value, end: null, bounds: '[)' })));
        }
        return this;
    };
    LessThanOrEqualExpression.op = "LessThanOrEqual";
    return LessThanOrEqualExpression;
}(ChainableUnaryExpression));
Expression.register(LessThanOrEqualExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var IndexOfExpression = exports.IndexOfExpression = (function (_super) {
    __extends(IndexOfExpression, _super);
    function IndexOfExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("indexOf");
        this._checkOperandTypes('STRING');
        this._checkExpressionTypes('STRING');
        this.type = 'NUMBER';
    }
    IndexOfExpression.fromJS = function (parameters) {
        return new IndexOfExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    IndexOfExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.indexOf(expressionValue) : null;
    };
    IndexOfExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return Expression.jsNullSafetyBinary(operandJS, expressionJS, (function (a, b) { return (a + ".indexOf(" + b + ")"); }), operandJS[0] === '"', expressionJS[0] === '"');
    };
    IndexOfExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return dialect.indexOfExpression(operandSQL, expressionSQL);
    };
    IndexOfExpression.op = "IndexOf";
    return IndexOfExpression;
}(ChainableUnaryExpression));
Expression.register(IndexOfExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var LookupExpression = exports.LookupExpression = (function (_super) {
    __extends(LookupExpression, _super);
    function LookupExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("lookup");
        this._checkOperandTypes('STRING', 'SET/STRING');
        this.lookupFn = parameters.lookupFn;
        this.type = this.operand.type;
    }
    LookupExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.lookupFn = parameters.lookupFn || parameters.lookup;
        return new LookupExpression(value);
    };
    LookupExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.lookupFn = this.lookupFn;
        return value;
    };
    LookupExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.lookupFn = this.lookupFn;
        return js;
    };
    LookupExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.lookupFn === other.lookupFn;
    };
    LookupExpression.prototype._toStringParameters = function (indent) {
        return [String(this.lookupFn)];
    };
    LookupExpression.prototype.fullyDefined = function () {
        return false;
    };
    LookupExpression.prototype._calcChainableHelper = function (operandValue) {
        throw new Error('can not express as JS');
    };
    LookupExpression.prototype._getJSChainableHelper = function (operandJS) {
        throw new Error('can not express as JS');
    };
    LookupExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        throw new Error('can not express as SQL');
    };
    LookupExpression.op = "Lookup";
    return LookupExpression;
}(ChainableExpression));
Expression.register(LookupExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var LimitExpression = exports.LimitExpression = (function (_super) {
    __extends(LimitExpression, _super);
    function LimitExpression(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this._ensureOp("limit");
        this._checkOperandTypes('DATASET');
        var value = parameters.value;
        if (value == null)
            value = Infinity;
        if (value < 0)
            throw new Error("limit value can not be negative (is " + value + ")");
        this.value = value;
        this.type = 'DATASET';
    }
    LimitExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.value = parameters.value || parameters.limit;
        return new LimitExpression(value);
    };
    LimitExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.value = this.value;
        return value;
    };
    LimitExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.value = this.value;
        return js;
    };
    LimitExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.value === other.value;
    };
    LimitExpression.prototype._toStringParameters = function (indent) {
        return [String(this.value)];
    };
    LimitExpression.prototype._calcChainableHelper = function (operandValue) {
        return operandValue ? operandValue.limit(this.value) : null;
    };
    LimitExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return "LIMIT " + this.value;
    };
    LimitExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, value = _a.value;
        if (!isFinite(value))
            return operand;
        if (operand instanceof LimitExpression) {
            var x = operand.operand, a = operand.value;
            return x.limit(Math.min(a, value));
        }
        if (operand instanceof ApplyExpression) {
            return this.swapWithOperand();
        }
        return this;
    };
    LimitExpression.op = "Limit";
    return LimitExpression;
}(ChainableExpression));
Expression.register(LimitExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var REGEXP_SPECIAL = "\\^$.|?*+()[{";

var MatchExpression = exports.MatchExpression = (function (_super) {
    __extends(MatchExpression, _super);
    function MatchExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("match");
        this._checkOperandTypes('STRING', 'SET/STRING');
        this.regexp = parameters.regexp;
        this.type = 'BOOLEAN';
    }
    MatchExpression.likeToRegExp = function (like, escapeChar) {
        if (escapeChar === void 0) { escapeChar = '\\'; }
        var regExp = ['^'];
        for (var i = 0; i < like.length; i++) {
            var char = like[i];
            if (char === escapeChar) {
                var nextChar = like[i + 1];
                if (!nextChar)
                    throw new Error("invalid LIKE string '" + like + "'");
                char = nextChar;
                i++;
            }
            else if (char === '%') {
                regExp.push('.*');
                continue;
            }
            else if (char === '_') {
                regExp.push('.');
                continue;
            }
            if (REGEXP_SPECIAL.indexOf(char) !== -1) {
                regExp.push('\\');
            }
            regExp.push(char);
        }
        regExp.push('$');
        return regExp.join('');
    };
    MatchExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.regexp = parameters.regexp;
        return new MatchExpression(value);
    };
    MatchExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.regexp = this.regexp;
        return value;
    };
    MatchExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.regexp = this.regexp;
        return js;
    };
    MatchExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.regexp === other.regexp;
    };
    MatchExpression.prototype._toStringParameters = function (indent) {
        return [this.regexp];
    };
    MatchExpression.prototype._calcChainableHelper = function (operandValue) {
        var re = new RegExp(this.regexp);
        if (!operandValue)
            return null;
        if (operandValue === null)
            return null;
        return re.test(operandValue);
    };
    MatchExpression.prototype._getJSChainableHelper = function (operandJS) {
        return "/" + this.regexp + "/.test(" + operandJS + ")";
    };
    MatchExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return dialect.regexpExpression(operandSQL, this.regexp);
    };
    MatchExpression.op = "Match";
    return MatchExpression;
}(ChainableExpression));
Expression.register(MatchExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var MaxExpression = exports.MaxExpression = (function (_super) {
    __extends(MaxExpression, _super);
    function MaxExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("max");
        this._checkOperandTypes('DATASET');
        this._checkExpressionTypes('NUMBER', 'TIME');
        this.type = 'NUMBER';
    }
    MaxExpression.fromJS = function (parameters) {
        return new MaxExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    MaxExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.max(this.expression) : null;
    };
    MaxExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "MAX(" + dialect.aggregateFilterIfNeeded(operandSQL, expressionSQL) + ")";
    };
    MaxExpression.op = "Max";
    return MaxExpression;
}(ChainableUnaryExpression));
Expression.applyMixins(MaxExpression, [Aggregate]);
Expression.register(MaxExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var MinExpression = exports.MinExpression = (function (_super) {
    __extends(MinExpression, _super);
    function MinExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("min");
        this._checkOperandTypes('DATASET');
        this._checkExpressionTypes('NUMBER', 'TIME');
        this.type = 'NUMBER';
    }
    MinExpression.fromJS = function (parameters) {
        return new MinExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    MinExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.min(this.expression) : null;
    };
    MinExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "MIN(" + dialect.aggregateFilterIfNeeded(operandSQL, expressionSQL) + ")";
    };
    MinExpression.op = "Min";
    return MinExpression;
}(ChainableUnaryExpression));
Expression.applyMixins(MinExpression, [Aggregate]);
Expression.register(MinExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var MultiplyExpression = exports.MultiplyExpression = (function (_super) {
    __extends(MultiplyExpression, _super);
    function MultiplyExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("multiply");
        this._checkOperandTypes('NUMBER');
        this._checkExpressionTypes('NUMBER');
        this.type = 'NUMBER';
    }
    MultiplyExpression.fromJS = function (parameters) {
        return new MultiplyExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    MultiplyExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return (operandValue || 0) * (expressionValue || 0);
    };
    MultiplyExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + "*" + expressionJS + ")";
    };
    MultiplyExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + "*" + expressionSQL + ")";
    };
    MultiplyExpression.prototype.isCommutative = function () {
        return true;
    };
    MultiplyExpression.prototype.isAssociative = function () {
        return true;
    };
    MultiplyExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression.equals(Expression.ZERO))
            return Expression.ZERO;
        if (expression.equals(Expression.ONE))
            return operand;
        return this;
    };
    MultiplyExpression.op = "Multiply";
    return MultiplyExpression;
}(ChainableUnaryExpression));
Expression.register(MultiplyExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var NotExpression = exports.NotExpression = (function (_super) {
    __extends(NotExpression, _super);
    function NotExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("not");
        this._checkOperandTypes('BOOLEAN');
        this.type = 'BOOLEAN';
    }
    NotExpression.fromJS = function (parameters) {
        return new NotExpression(ChainableExpression.jsToValue(parameters));
    };
    NotExpression.prototype._calcChainableHelper = function (operandValue) {
        return !operandValue;
    };
    NotExpression.prototype._getJSChainableHelper = function (operandJS) {
        return "!(" + operandJS + ")";
    };
    NotExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return "NOT(" + operandSQL + ")";
    };
    NotExpression.prototype.specialSimplify = function () {
        var operand = this.operand;
        if (operand instanceof NotExpression)
            return operand.operand;
        return this;
    };
    NotExpression.op = "Not";
    return NotExpression;
}(ChainableExpression));
Expression.register(NotExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var NumberBucketExpression = exports.NumberBucketExpression = (function (_super) {
    __extends(NumberBucketExpression, _super);
    function NumberBucketExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this.size = parameters.size;
        this.offset = parameters.offset;
        this._ensureOp("numberBucket");
        this._checkOperandTypes('NUMBER');
        this.type = 'NUMBER_RANGE';
    }
    NumberBucketExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.size = parameters.size;
        value.offset = hasOwnProperty(parameters, 'offset') ? parameters.offset : 0;
        return new NumberBucketExpression(value);
    };
    NumberBucketExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.size = this.size;
        value.offset = this.offset;
        return value;
    };
    NumberBucketExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.size = this.size;
        if (this.offset)
            js.offset = this.offset;
        return js;
    };
    NumberBucketExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.size === other.size &&
            this.offset === other.offset;
    };
    NumberBucketExpression.prototype._toStringParameters = function (indent) {
        var params = [String(this.size)];
        if (this.offset)
            params.push(String(this.offset));
        return params;
    };
    NumberBucketExpression.prototype._calcChainableHelper = function (operandValue) {
        var size = this.size;
        var offset = this.offset;
        var num = operandValue;
        if (num === null)
            return null;
        return NumberRange.numberBucket(num, size, offset);
    };
    NumberBucketExpression.prototype._getJSChainableHelper = function (operandJS) {
        var _this = this;
        return Expression.jsNullSafetyUnary(operandJS, function (n) { return continuousFloorExpression(n, "Math.floor", _this.size, _this.offset); });
    };
    NumberBucketExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return continuousFloorExpression(operandSQL, "FLOOR", this.size, this.offset);
    };
    NumberBucketExpression.op = "NumberBucket";
    return NumberBucketExpression;
}(ChainableExpression));
Expression.register(NumberBucketExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var IS_OR_IN = {
    'is': true,
    'in': true
};
var OrExpression = exports.OrExpression = (function (_super) {
    __extends(OrExpression, _super);
    function OrExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("or");
        this._checkOperandTypes('BOOLEAN');
        this._checkExpressionTypes('BOOLEAN');
        this.type = 'BOOLEAN';
    }
    OrExpression.fromJS = function (parameters) {
        return new OrExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    OrExpression.merge = function (ex1, ex2) {
        if (ex1.equals(ex2))
            return ex1;
        if (!IS_OR_IN[ex1.op] || !IS_OR_IN[ex2.op])
            return null;
        var _a = ex1, lhs1 = _a.operand, rhs1 = _a.expression;
        var _b = ex2, lhs2 = _b.operand, rhs2 = _b.expression;
        if (!lhs1.equals(lhs2) || !rhs1.isOp('literal') || !rhs2.isOp('literal'))
            return null;
        var union = Set.generalUnion(rhs1.getLiteralValue(), rhs2.getLiteralValue());
        if (union === null)
            return null;
        return Expression.inOrIs(lhs1, union);
    };
    OrExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue || expressionValue;
    };
    OrExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + "||" + expressionJS + ")";
    };
    OrExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + " OR " + expressionSQL + ")";
    };
    OrExpression.prototype.isCommutative = function () {
        return true;
    };
    OrExpression.prototype.isAssociative = function () {
        return true;
    };
    OrExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression.equals(Expression.TRUE))
            return Expression.TRUE;
        if (expression.equals(Expression.FALSE))
            return operand;
        if (operand instanceof OrExpression) {
            var orExpressions = operand.getExpressionList();
            for (var i = 0; i < orExpressions.length; i++) {
                var orExpression = orExpressions[i];
                var mergedExpression = OrExpression.merge(orExpression, expression);
                if (mergedExpression) {
                    orExpressions[i] = mergedExpression;
                    return Expression.or(orExpressions).simplify();
                }
            }
        }
        else {
            var mergedExpression = OrExpression.merge(operand, expression);
            if (mergedExpression)
                return mergedExpression;
        }
        return this;
    };
    OrExpression.op = "Or";
    return OrExpression;
}(ChainableUnaryExpression));
Expression.register(OrExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



var OverlapExpression = exports.OverlapExpression = (function (_super) {
    __extends(OverlapExpression, _super);
    function OverlapExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("overlap");
        if (!this.expression.canHaveType('SET')) {
            throw new Error(this.op + " must have an expression of type SET (is: " + this.expression.type + ")");
        }
        var oType = this.operand.type;
        var eType = this.expression.type;
        if (oType && eType && oType !== 'NULL' && oType !== 'SET/NULL' && eType !== 'NULL' && eType !== 'SET/NULL') {
            if (wrapSetType(oType) !== wrapSetType(eType)) {
                throw new Error("overlap expression has type mismatch between " + oType + " and " + eType);
            }
        }
        this.type = 'BOOLEAN';
    }
    OverlapExpression.fromJS = function (parameters) {
        return new OverlapExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    OverlapExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        if (expressionValue == null)
            return null;
        return operandValue instanceof Set ? operandValue.overlap(expressionValue) : expressionValue.contains(operandValue);
    };
    OverlapExpression.prototype.isCommutative = function () {
        return true;
    };
    OverlapExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression.equals(Expression.EMPTY_SET))
            return Expression.FALSE;
        if ('SET/' + operand.type === expression.type)
            return operand.in(expression);
        return this;
    };
    OverlapExpression.op = "Overlap";
    return OverlapExpression;
}(ChainableUnaryExpression));
Expression.register(OverlapExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var PowerExpression = exports.PowerExpression = (function (_super) {
    __extends(PowerExpression, _super);
    function PowerExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("power");
        this._checkOperandTypes('NUMBER');
        this._checkExpressionTypes('NUMBER');
        this.type = 'NUMBER';
    }
    PowerExpression.fromJS = function (parameters) {
        return new PowerExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    PowerExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return Math.pow((operandValue || 0), (expressionValue || 0));
    };
    PowerExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "Math.pow(" + operandJS + "," + expressionJS + ")";
    };
    PowerExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "POW(" + operandSQL + "," + expressionSQL + ")";
    };
    PowerExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression.equals(Expression.ZERO))
            return Expression.ONE;
        if (expression.equals(Expression.ONE))
            return operand;
        return this;
    };
    PowerExpression.op = "Power";
    return PowerExpression;
}(ChainableUnaryExpression));
Expression.register(PowerExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var QuantileExpression = exports.QuantileExpression = (function (_super) {
    __extends(QuantileExpression, _super);
    function QuantileExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("quantile");
        this._checkOperandTypes('DATASET');
        this._checkExpressionTypes('NUMBER');
        this.value = parameters.value;
        this.type = 'NUMBER';
    }
    QuantileExpression.fromJS = function (parameters) {
        var value = ChainableUnaryExpression.jsToValue(parameters);
        value.value = parameters.value || parameters.quantile;
        return new QuantileExpression(value);
    };
    QuantileExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.value = this.value;
        return value;
    };
    QuantileExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.value = this.value;
        return js;
    };
    QuantileExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.value === other.value;
    };
    QuantileExpression.prototype._toStringParameters = function (indent) {
        return [this.expression.toString(indent), String(this.value)];
    };
    QuantileExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.quantile(this.expression, this.value) : null;
    };
    QuantileExpression.op = "Quantile";
    return QuantileExpression;
}(ChainableUnaryExpression));
Expression.applyMixins(QuantileExpression, [Aggregate]);
Expression.register(QuantileExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var SelectExpression = exports.SelectExpression = (function (_super) {
    __extends(SelectExpression, _super);
    function SelectExpression(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this._ensureOp("select");
        this._checkOperandTypes('DATASET');
        this.attributes = parameters.attributes;
        this.type = 'DATASET';
    }
    SelectExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.attributes = parameters.attributes;
        return new SelectExpression(value);
    };
    SelectExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.attributes = this.attributes;
        return value;
    };
    SelectExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.attributes = this.attributes;
        return js;
    };
    SelectExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            String(this.attributes) === String(other.attributes);
    };
    SelectExpression.prototype._toStringParameters = function (indent) {
        return this.attributes;
    };
    SelectExpression.prototype.updateTypeContext = function (typeContext) {
        var attributes = this.attributes;
        var datasetType = typeContext.datasetType, parent = typeContext.parent;
        var newDatasetType = Object.create(null);
        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
            var attr = attributes_1[_i];
            var attrType = datasetType[attr];
            if (!attrType)
                throw new Error("unknown attribute '" + attr + "' in select");
            newDatasetType[attr] = attrType;
        }
        return {
            type: 'DATASET',
            datasetType: newDatasetType,
            parent: parent
        };
    };
    SelectExpression.prototype._calcChainableHelper = function (operandValue) {
        return operandValue ? operandValue.select(this.attributes) : null;
    };
    SelectExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        throw new Error('can not be expressed as SQL directly');
    };
    SelectExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, attributes = _a.attributes;
        if (operand instanceof SelectExpression) {
            var x = operand.operand, attr = operand.attributes;
            return x.select(attr.filter(function (a) { return attributes.indexOf(a) !== -1; }));
        }
        else if (operand instanceof ApplyExpression) {
            var x = operand.operand, name = operand.name;
            if (attributes.indexOf(name) === -1) {
                return this.changeOperand(x);
            }
        }
        return this;
    };
    SelectExpression.op = "Select";
    return SelectExpression;
}(ChainableExpression));
Expression.register(SelectExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var SortExpression = exports.SortExpression = (function (_super) {
    __extends(SortExpression, _super);
    function SortExpression(parameters) {
        if (parameters === void 0) { parameters = {}; }
        _super.call(this, parameters, dummyObject);
        this._ensureOp("sort");
        this._checkOperandTypes('DATASET');
        if (!this.expression.isOp('ref')) {
            throw new Error("must be a reference expression: " + this.expression);
        }
        var direction = parameters.direction || SortExpression.DEFAULT_DIRECTION;
        if (direction !== SortExpression.DESCENDING && direction !== SortExpression.ASCENDING) {
            throw new Error("direction must be '" + SortExpression.DESCENDING + "' or '" + SortExpression.ASCENDING + "'");
        }
        this.direction = direction;
        this.type = 'DATASET';
    }
    SortExpression.fromJS = function (parameters) {
        var value = ChainableUnaryExpression.jsToValue(parameters);
        value.direction = parameters.direction;
        return new SortExpression(value);
    };
    SortExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.direction = this.direction;
        return value;
    };
    SortExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.direction = this.direction;
        return js;
    };
    SortExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.direction === other.direction;
    };
    SortExpression.prototype._toStringParameters = function (indent) {
        return [this.expression.toString(indent), this.direction];
    };
    SortExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.sort(this.expression, this.direction) : null;
    };
    SortExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        var dir = this.direction === SortExpression.DESCENDING ? 'DESC' : 'ASC';
        return "ORDER BY " + expressionSQL + " " + dir;
    };
    SortExpression.prototype.refName = function () {
        var expression = this.expression;
        return (expression instanceof RefExpression) ? expression.name : null;
    };
    SortExpression.prototype.isNester = function () {
        return true;
    };
    SortExpression.prototype.fullyDefined = function () {
        return this.operand.isOp('literal') && this.expression.resolved();
    };
    SortExpression.prototype.changeDirection = function (direction) {
        if (this.direction === direction)
            return this;
        var value = this.valueOf();
        value.direction = direction;
        return new SortExpression(value);
    };
    SortExpression.prototype.toggleDirection = function () {
        return this.changeDirection(this.direction === SortExpression.ASCENDING ? SortExpression.DESCENDING : SortExpression.ASCENDING);
    };
    SortExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (operand instanceof SortExpression && operand.expression.equals(expression))
            return this.changeOperand(operand.operand);
        return this;
    };
    SortExpression.DESCENDING = 'descending';
    SortExpression.ASCENDING = 'ascending';
    SortExpression.DEFAULT_DIRECTION = 'ascending';
    SortExpression.op = "Sort";
    return SortExpression;
}(ChainableUnaryExpression));
Expression.register(SortExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






var SplitExpression = exports.SplitExpression = (function (_super) {
    __extends(SplitExpression, _super);
    function SplitExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("split");
        this._checkOperandTypes('DATASET');
        var splits = parameters.splits;
        if (!splits)
            throw new Error('must have splits');
        this.splits = splits;
        this.keys = Object.keys(splits).sort();
        if (!this.keys.length)
            throw new Error('must have at least one split');
        this.dataName = parameters.dataName;
        this.type = 'DATASET';
    }
    SplitExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        var splits;
        if (parameters.expression && parameters.name) {
            splits = (_a = {}, _a[parameters.name] = parameters.expression, _a);
        }
        else {
            splits = parameters.splits;
        }
        value.splits = Expression.expressionLookupFromJS(splits);
        value.dataName = parameters.dataName;
        return new SplitExpression(value);
        var _a;
    };
    SplitExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.splits = this.splits;
        value.dataName = this.dataName;
        return value;
    };
    SplitExpression.prototype.toJS = function () {
        var splits = this.splits;
        var js = _super.prototype.toJS.call(this);
        if (this.isMultiSplit()) {
            js.splits = Expression.expressionLookupToJS(splits);
        }
        else {
            for (var name in splits) {
                js.name = name;
                js.expression = splits[name].toJS();
            }
        }
        js.dataName = this.dataName;
        return js;
    };
    SplitExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            immutableLookupsEqual(this.splits, other.splits) &&
            this.dataName === other.dataName;
    };
    SplitExpression.prototype.changeSplits = function (splits) {
        if (immutableLookupsEqual(this.splits, splits))
            return this;
        var value = this.valueOf();
        value.splits = splits;
        return new SplitExpression(value);
    };
    SplitExpression.prototype.numSplits = function () {
        return this.keys.length;
    };
    SplitExpression.prototype.isMultiSplit = function () {
        return this.numSplits() > 1;
    };
    SplitExpression.prototype._toStringParameters = function (indent) {
        if (this.isMultiSplit()) {
            var splits = this.splits;
            var splitStrings = [];
            for (var name in splits) {
                splitStrings.push(name + ": " + splits[name]);
            }
            return [splitStrings.join(', '), this.dataName];
        }
        else {
            return [this.firstSplitExpression().toString(), this.firstSplitName(), this.dataName];
        }
    };
    SplitExpression.prototype.updateTypeContext = function (typeContext) {
        var newDatasetType = {};
        this.mapSplits(function (name, expression) {
            newDatasetType[name] = {
                type: unwrapSetType(expression.type)
            };
        });
        newDatasetType[this.dataName] = typeContext;
        return {
            parent: typeContext.parent,
            type: 'DATASET',
            datasetType: newDatasetType
        };
    };
    SplitExpression.prototype.firstSplitName = function () {
        return this.keys[0];
    };
    SplitExpression.prototype.firstSplitExpression = function () {
        return this.splits[this.firstSplitName()];
    };
    SplitExpression.prototype.getArgumentExpressions = function () {
        return this.mapSplits(function (name, ex) { return ex; });
    };
    SplitExpression.prototype.mapSplits = function (fn) {
        var _a = this, splits = _a.splits, keys = _a.keys;
        var res = [];
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            var v = fn(k, splits[k]);
            if (typeof v !== 'undefined')
                res.push(v);
        }
        return res;
    };
    SplitExpression.prototype.mapSplitExpressions = function (fn) {
        var _a = this, splits = _a.splits, keys = _a.keys;
        var ret = Object.create(null);
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
            var key = keys_2[_i];
            ret[key] = fn(splits[key], key);
        }
        return ret;
    };
    SplitExpression.prototype.calc = function (datum) {
        var _a = this, operand = _a.operand, splits = _a.splits, dataName = _a.dataName;
        var operandValue = operand.calc(datum);
        return operandValue ? operandValue.split(splits, dataName) : null;
    };
    SplitExpression.prototype.getSQL = function (dialect) {
        var groupBys = this.mapSplits(function (name, expression) { return expression.getSQL(dialect); });
        return "GROUP BY " + groupBys.join(', ');
    };
    SplitExpression.prototype.getSelectSQL = function (dialect) {
        return this.mapSplits(function (name, expression) { return (expression.getSQL(dialect) + " AS " + dialect.escapeName(name)); });
    };
    SplitExpression.prototype.getShortGroupBySQL = function () {
        return 'GROUP BY ' + Object.keys(this.splits).map(function (d, i) { return i + 1; }).join(', ');
    };
    SplitExpression.prototype.fullyDefined = function () {
        return this.operand.isOp('literal') && this.mapSplits(function (name, expression) { return expression.resolved(); }).every(Boolean);
    };
    SplitExpression.prototype.simplify = function () {
        if (this.simple)
            return this;
        var simpleOperand = this.operand.simplify();
        var simpleSplits = this.mapSplitExpressions(function (ex) { return ex.simplify(); });
        var simpler = this.changeOperand(simpleOperand).changeSplits(simpleSplits);
        if (simpler.fullyDefined())
            return r(this.calc({}));
        if (simpler instanceof ChainableExpression) {
            var pushedInExternal = simpler.pushIntoExternal();
            if (pushedInExternal)
                return pushedInExternal;
        }
        return simpler.markSimple();
    };
    SplitExpression.prototype._substituteHelper = function (substitutionFn, indexer, depth, nestDiff, typeContext) {
        var sub = substitutionFn.call(this, this, indexer.index, depth, nestDiff);
        if (sub) {
            indexer.index += this.expressionCount();
            return {
                expression: sub,
                typeContext: sub.updateTypeContextIfNeeded(typeContext)
            };
        }
        else {
            indexer.index++;
        }
        depth++;
        var operandSubs = this.operand._substituteHelper(substitutionFn, indexer, depth, nestDiff, typeContext);
        var nestDiffNext = nestDiff + 1;
        var splitsSubs = this.mapSplitExpressions(function (ex) {
            return ex._substituteHelper(substitutionFn, indexer, depth, nestDiffNext, operandSubs.typeContext).expression;
        });
        var updatedThis = this.changeOperand(operandSubs.expression).changeSplits(splitsSubs);
        return {
            expression: updatedThis,
            typeContext: updatedThis.updateTypeContextIfNeeded(operandSubs.typeContext)
        };
    };
    SplitExpression.prototype.transformExpressions = function (fn) {
        return this.changeSplits(this.mapSplitExpressions(fn));
    };
    SplitExpression.prototype.filterFromDatum = function (datum) {
        return Expression.and(this.mapSplits(function (name, expression) {
            if (isSetType(expression.type)) {
                return r(datum[name]).in(expression);
            }
            else {
                return expression.is(r(datum[name]));
            }
        })).simplify();
    };
    SplitExpression.prototype.hasKey = function (key) {
        return hasOwnProperty(this.splits, key);
    };
    SplitExpression.prototype.isLinear = function () {
        var _a = this, splits = _a.splits, keys = _a.keys;
        for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
            var k = keys_3[_i];
            var split = splits[k];
            if (isSetType(split.type))
                return false;
        }
        return true;
    };
    SplitExpression.prototype.maxBucketNumber = function () {
        var _a = this, splits = _a.splits, keys = _a.keys;
        var num = 1;
        for (var _i = 0, keys_4 = keys; _i < keys_4.length; _i++) {
            var key = keys_4[_i];
            num *= splits[key].maxPossibleSplitValues();
        }
        return num;
    };
    SplitExpression.op = "Split";
    return SplitExpression;
}(ChainableExpression));
Expression.applyMixins(SplitExpression, [Aggregate]);
Expression.register(SplitExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var SubstrExpression = exports.SubstrExpression = (function (_super) {
    __extends(SubstrExpression, _super);
    function SubstrExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this.position = parameters.position;
        this.len = parameters.len;
        this._ensureOp("substr");
        this._checkOperandTypes('STRING', 'SET/STRING');
        this.type = this.operand.type;
    }
    SubstrExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.position = parameters.position;
        value.len = parameters.len || parameters.length;
        return new SubstrExpression(value);
    };
    SubstrExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.position = this.position;
        value.len = this.len;
        return value;
    };
    SubstrExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.position = this.position;
        js.len = this.len;
        return js;
    };
    SubstrExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.position === other.position &&
            this.len === other.len;
    };
    SubstrExpression.prototype._toStringParameters = function (indent) {
        return [String(this.position), String(this.len)];
    };
    SubstrExpression.prototype._calcChainableHelper = function (operandValue) {
        var _a = this, position = _a.position, len = _a.len;
        if (operandValue === null)
            return null;
        return operandValue.substr(position, len);
    };
    SubstrExpression.prototype._getJSChainableHelper = function (operandJS) {
        var _a = this, position = _a.position, len = _a.len;
        return "(_=" + operandJS + ",_==null?null:(''+_).substr(" + position + "," + len + "))";
    };
    SubstrExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return "SUBSTR(" + operandSQL + "," + (this.position + 1) + "," + this.len + ")";
    };
    SubstrExpression.op = "Substr";
    return SubstrExpression;
}(ChainableExpression));
Expression.register(SubstrExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var SubtractExpression = exports.SubtractExpression = (function (_super) {
    __extends(SubtractExpression, _super);
    function SubtractExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("subtract");
        this._checkOperandTypes('NUMBER');
        this._checkExpressionTypes('NUMBER');
        this.type = 'NUMBER';
    }
    SubtractExpression.fromJS = function (parameters) {
        return new SubtractExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    SubtractExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return (operandValue || 0) - (expressionValue || 0);
    };
    SubtractExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + "-" + expressionJS + ")";
    };
    SubtractExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + "-" + expressionSQL + ")";
    };
    SubtractExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression.equals(Expression.ZERO))
            return operand;
        return this;
    };
    SubtractExpression.op = "Subtract";
    return SubtractExpression;
}(ChainableUnaryExpression));
Expression.register(SubtractExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






var SumExpression = exports.SumExpression = (function (_super) {
    __extends(SumExpression, _super);
    function SumExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("sum");
        this._checkOperandTypes('DATASET');
        this._checkExpressionTypes('NUMBER');
        this.type = 'NUMBER';
    }
    SumExpression.fromJS = function (parameters) {
        return new SumExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    SumExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue ? operandValue.sum(this.expression) : null;
    };
    SumExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "SUM(" + dialect.aggregateFilterIfNeeded(operandSQL, expressionSQL) + ")";
    };
    SumExpression.prototype.distribute = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression instanceof LiteralExpression) {
            var value = expression.value;
            return operand.count().multiply(value).simplify();
        }
        if (expression instanceof AddExpression) {
            var lhs = expression.operand, rhs = expression.expression;
            return operand.sum(lhs).distribute().add(operand.sum(rhs).distribute()).simplify();
        }
        if (expression instanceof SubtractExpression) {
            var lhs = expression.operand, rhs = expression.expression;
            return operand.sum(lhs).distribute().subtract(operand.sum(rhs).distribute()).simplify();
        }
        if (expression instanceof MultiplyExpression) {
            var lhs = expression.operand, rhs = expression.expression;
            if (rhs instanceof LiteralExpression) {
                return operand.sum(lhs).distribute().multiply(rhs).simplify();
            }
        }
        return this;
    };
    SumExpression.op = "Sum";
    return SumExpression;
}(ChainableUnaryExpression));
Expression.applyMixins(SumExpression, [Aggregate]);
Expression.register(SumExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





var TimeBucketExpression = exports.TimeBucketExpression = (function (_super) {
    __extends(TimeBucketExpression, _super);
    function TimeBucketExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        var duration = parameters.duration;
        this.duration = duration;
        this.timezone = parameters.timezone;
        this._ensureOp("timeBucket");
        this._checkOperandTypes('TIME');
        if (!(duration instanceof Duration)) {
            throw new Error("`duration` must be a Duration");
        }
        if (!duration.isFloorable()) {
            throw new Error("duration '" + duration.toString() + "' is not floorable");
        }
        this.type = 'TIME_RANGE';
    }
    TimeBucketExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.duration = Duration.fromJS(parameters.duration);
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimeBucketExpression(value);
    };
    TimeBucketExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.duration = this.duration;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimeBucketExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.duration = this.duration.toJS();
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimeBucketExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.duration.equals(other.duration) &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimeBucketExpression.prototype._toStringParameters = function (indent) {
        var ret = [this.duration.toString()];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimeBucketExpression.prototype._calcChainableHelper = function (operandValue) {
        return operandValue ? TimeRange.timeBucket(operandValue, this.duration, this.getTimezone()) : null;
    };
    TimeBucketExpression.prototype._getJSChainableHelper = function (operandJS) {
        throw new Error("implement me");
    };
    TimeBucketExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return dialect.timeBucketExpression(operandSQL, this.duration, this.getTimezone());
    };
    TimeBucketExpression.op = "TimeBucket";
    return TimeBucketExpression;
}(ChainableExpression));
Expression.applyMixins(TimeBucketExpression, [HasTimezone]);
Expression.register(TimeBucketExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};








var TimeFloorExpression = exports.TimeFloorExpression = (function (_super) {
    __extends(TimeFloorExpression, _super);
    function TimeFloorExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        var duration = parameters.duration;
        this.duration = duration;
        this.timezone = parameters.timezone;
        this._ensureOp("timeFloor");
        this._bumpOperandToTime();
        this._checkOperandTypes('TIME');
        if (!(duration instanceof Duration)) {
            throw new Error("`duration` must be a Duration");
        }
        if (!duration.isFloorable()) {
            throw new Error("duration '" + duration.toString() + "' is not floorable");
        }
        this.type = 'TIME';
    }
    TimeFloorExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.duration = Duration.fromJS(parameters.duration);
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimeFloorExpression(value);
    };
    TimeFloorExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.duration = this.duration;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimeFloorExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.duration = this.duration.toJS();
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimeFloorExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.duration.equals(other.duration) &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimeFloorExpression.prototype._toStringParameters = function (indent) {
        var ret = [this.duration.toString()];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimeFloorExpression.prototype._calcChainableHelper = function (operandValue) {
        return operandValue ? this.duration.floor(operandValue, this.getTimezone()) : null;
    };
    TimeFloorExpression.prototype._getJSChainableHelper = function (operandJS) {
        throw new Error("implement me");
    };
    TimeFloorExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return dialect.timeFloorExpression(operandSQL, this.duration, this.getTimezone());
    };
    TimeFloorExpression.prototype.alignsWith = function (ex) {
        var _a = this, timezone = _a.timezone, duration = _a.duration;
        if (!timezone)
            return false;
        if (ex instanceof TimeFloorExpression || ex instanceof TimeBucketExpression) {
            return timezone.equals(ex.timezone) && ex.duration.dividesBy(duration);
        }
        if (ex instanceof InExpression || ex instanceof OverlapExpression) {
            var literal = ex.expression.getLiteralValue();
            if (literal instanceof TimeRange) {
                return literal.isAligned(duration, timezone);
            }
            else if (literal instanceof Set) {
                if (literal.setType !== 'TIME_RANGE')
                    return false;
                return literal.elements.every(function (e) {
                    return e.isAligned(duration, timezone);
                });
            }
        }
        return false;
    };
    TimeFloorExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, duration = _a.duration, timezone = _a.timezone;
        if (operand instanceof TimeFloorExpression) {
            var d = operand.duration, tz = operand.timezone;
            if (duration.equals(d) && immutableEqual(timezone, tz))
                return operand;
        }
        return this;
    };
    TimeFloorExpression.op = "TimeFloor";
    return TimeFloorExpression;
}(ChainableExpression));
Expression.applyMixins(TimeFloorExpression, [HasTimezone]);
Expression.register(TimeFloorExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





var PART_TO_FUNCTION = {
    SECOND_OF_MINUTE: function (d) { return d.seconds(); },
    SECOND_OF_HOUR: function (d) { return d.minutes() * 60 + d.seconds(); },
    SECOND_OF_DAY: function (d) { return (d.hours() * 60 + d.minutes()) * 60 + d.seconds(); },
    SECOND_OF_WEEK: function (d) { return ((d.day() * 24) + d.hours() * 60 + d.minutes()) * 60 + d.seconds(); },
    SECOND_OF_MONTH: function (d) { return (((d.date() - 1) * 24) + d.hours() * 60 + d.minutes()) * 60 + d.seconds(); },
    SECOND_OF_YEAR: function (d) { return (((d.dayOfYear() - 1) * 24) + d.hours() * 60 + d.minutes()) * 60 + d.seconds(); },
    MINUTE_OF_HOUR: function (d) { return d.minutes(); },
    MINUTE_OF_DAY: function (d) { return d.hours() * 60 + d.minutes(); },
    MINUTE_OF_WEEK: function (d) { return (d.day() * 24) + d.hours() * 60 + d.minutes(); },
    MINUTE_OF_MONTH: function (d) { return ((d.date() - 1) * 24) + d.hours() * 60 + d.minutes(); },
    MINUTE_OF_YEAR: function (d) { return ((d.dayOfYear() - 1) * 24) + d.hours() * 60 + d.minutes(); },
    HOUR_OF_DAY: function (d) { return d.hours(); },
    HOUR_OF_WEEK: function (d) { return d.day() * 24 + d.hours(); },
    HOUR_OF_MONTH: function (d) { return (d.date() - 1) * 24 + d.hours(); },
    HOUR_OF_YEAR: function (d) { return (d.dayOfYear() - 1) * 24 + d.hours(); },
    DAY_OF_WEEK: function (d) { return d.day() || 7; },
    DAY_OF_MONTH: function (d) { return d.date(); },
    DAY_OF_YEAR: function (d) { return d.dayOfYear(); },
    WEEK_OF_MONTH: null,
    WEEK_OF_YEAR: null,
    MONTH_OF_YEAR: function (d) { return d.month(); },
    YEAR: function (d) { return d.year(); },
    QUARTER: function (d) { return d.quarter(); }
};
var PART_TO_MAX_VALUES = {
    SECOND_OF_MINUTE: 61,
    SECOND_OF_HOUR: 3601,
    SECOND_OF_DAY: 93601,
    SECOND_OF_WEEK: null,
    SECOND_OF_MONTH: null,
    SECOND_OF_YEAR: null,
    MINUTE_OF_HOUR: 60,
    MINUTE_OF_DAY: 26 * 60,
    MINUTE_OF_WEEK: null,
    MINUTE_OF_MONTH: null,
    MINUTE_OF_YEAR: null,
    HOUR_OF_DAY: 26,
    HOUR_OF_WEEK: null,
    HOUR_OF_MONTH: null,
    HOUR_OF_YEAR: null,
    DAY_OF_WEEK: 7,
    DAY_OF_MONTH: 31,
    DAY_OF_YEAR: 366,
    WEEK_OF_MONTH: 5,
    WEEK_OF_YEAR: 53,
    MONTH_OF_YEAR: 12,
    YEAR: null
};
var TimePartExpression = exports.TimePartExpression = (function (_super) {
    __extends(TimePartExpression, _super);
    function TimePartExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this.part = parameters.part;
        this.timezone = parameters.timezone;
        this._ensureOp("timePart");
        this._checkOperandTypes('TIME');
        if (typeof this.part !== 'string') {
            throw new Error("`part` must be a string");
        }
        this.type = 'NUMBER';
    }
    TimePartExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.part = parameters.part;
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimePartExpression(value);
    };
    TimePartExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.part = this.part;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimePartExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.part = this.part;
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimePartExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.part === other.part &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimePartExpression.prototype._toStringParameters = function (indent) {
        var ret = [this.part];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimePartExpression.prototype._calcChainableHelper = function (operandValue) {
        var part = this.part;
        var parter = PART_TO_FUNCTION[part];
        if (!parter)
            throw new Error("unsupported part '" + part + "'");
        if (!operandValue)
            return null;
        operandValue = moment.tz(operandValue, this.getTimezone().toString());
        return parter(operandValue);
    };
    TimePartExpression.prototype._getJSChainableHelper = function (operandJS) {
        throw new Error("implement me");
    };
    TimePartExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return dialect.timePartExpression(operandSQL, this.part, this.getTimezone());
    };
    TimePartExpression.prototype.maxPossibleSplitValues = function () {
        var maxValue = PART_TO_MAX_VALUES[this.part];
        if (!maxValue)
            return Infinity;
        return maxValue + 1;
    };
    TimePartExpression.op = "TimePart";
    return TimePartExpression;
}(ChainableExpression));
Expression.applyMixins(TimePartExpression, [HasTimezone]);
Expression.register(TimePartExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





var TimeRangeExpression = exports.TimeRangeExpression = (function (_super) {
    __extends(TimeRangeExpression, _super);
    function TimeRangeExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this.duration = parameters.duration;
        this.step = parameters.step || TimeRangeExpression.DEFAULT_STEP;
        this.timezone = parameters.timezone;
        this._ensureOp("timeRange");
        this._checkOperandTypes('TIME');
        if (!Duration.isDuration(this.duration)) {
            throw new Error("`duration` must be a Duration");
        }
        this.type = 'TIME_RANGE';
    }
    TimeRangeExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.duration = Duration.fromJS(parameters.duration);
        value.step = parameters.step;
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimeRangeExpression(value);
    };
    TimeRangeExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.duration = this.duration;
        value.step = this.step;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimeRangeExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.duration = this.duration.toJS();
        js.step = this.step;
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimeRangeExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.duration.equals(other.duration) &&
            this.step === other.step &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimeRangeExpression.prototype._toStringParameters = function (indent) {
        var ret = [this.duration.toString(), this.step.toString()];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimeRangeExpression.prototype._calcChainableHelper = function (operandValue) {
        var duration = this.duration;
        var step = this.step;
        var timezone = this.getTimezone();
        if (operandValue === null)
            return null;
        var other = duration.shift(operandValue, timezone, step);
        if (step > 0) {
            return new TimeRange({ start: operandValue, end: other });
        }
        else {
            return new TimeRange({ start: other, end: operandValue });
        }
    };
    TimeRangeExpression.prototype._getJSChainableHelper = function (operandJS) {
        throw new Error("implement me");
    };
    TimeRangeExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        throw new Error("implement me");
    };
    TimeRangeExpression.DEFAULT_STEP = 1;
    TimeRangeExpression.op = "TimeRange";
    return TimeRangeExpression;
}(ChainableExpression));
Expression.applyMixins(TimeRangeExpression, [HasTimezone]);
Expression.register(TimeRangeExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




var TimeShiftExpression = exports.TimeShiftExpression = (function (_super) {
    __extends(TimeShiftExpression, _super);
    function TimeShiftExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this.duration = parameters.duration;
        this.step = parameters.step != null ? parameters.step : TimeShiftExpression.DEFAULT_STEP;
        this.timezone = parameters.timezone;
        this._ensureOp("timeShift");
        this._checkOperandTypes('TIME');
        if (!Duration.isDuration(this.duration)) {
            throw new Error("`duration` must be a Duration");
        }
        this.type = 'TIME';
    }
    TimeShiftExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.duration = Duration.fromJS(parameters.duration);
        value.step = parameters.step;
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimeShiftExpression(value);
    };
    TimeShiftExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.duration = this.duration;
        value.step = this.step;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimeShiftExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.duration = this.duration.toJS();
        js.step = this.step;
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimeShiftExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.duration.equals(other.duration) &&
            this.step === other.step &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimeShiftExpression.prototype._toStringParameters = function (indent) {
        var ret = [this.duration.toString(), this.step.toString()];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimeShiftExpression.prototype._calcChainableHelper = function (operandValue) {
        return operandValue ? this.duration.shift(operandValue, this.getTimezone(), this.step) : null;
    };
    TimeShiftExpression.prototype._getJSChainableHelper = function (operandJS) {
        throw new Error("implement me");
    };
    TimeShiftExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        return dialect.timeShiftExpression(operandSQL, this.duration, this.getTimezone());
    };
    TimeShiftExpression.prototype.changeStep = function (step) {
        if (this.step === step)
            return this;
        var value = this.valueOf();
        value.step = step;
        return new TimeShiftExpression(value);
    };
    TimeShiftExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, duration = _a.duration, step = _a.step, timezone = _a.timezone;
        if (step === 0)
            return operand;
        if (operand instanceof TimeShiftExpression) {
            var x = operand.operand, d = operand.duration, s = operand.step, tz = operand.timezone;
            if (duration.equals(d) && immutableEqual(timezone, tz)) {
                return x.timeShift(d, step + s, tz);
            }
        }
        return this;
    };
    TimeShiftExpression.DEFAULT_STEP = 1;
    TimeShiftExpression.op = "TimeShift";
    return TimeShiftExpression;
}(ChainableExpression));
Expression.applyMixins(TimeShiftExpression, [HasTimezone]);
Expression.register(TimeShiftExpression);
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var TransformCaseExpression = exports.TransformCaseExpression = (function (_super) {
    __extends(TransformCaseExpression, _super);
    function TransformCaseExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        var transformType = parameters.transformType;
        if (transformType !== TransformCaseExpression.UPPER_CASE && transformType !== TransformCaseExpression.LOWER_CASE) {
            throw new Error("Must supply transform type of '" + TransformCaseExpression.UPPER_CASE + "' or '" + TransformCaseExpression.LOWER_CASE + "'");
        }
        this.transformType = transformType;
        this._ensureOp("transformCase");
        this._checkOperandTypes('STRING');
        this.type = 'STRING';
    }
    TransformCaseExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.transformType = parameters.transformType;
        return new TransformCaseExpression(value);
    };
    TransformCaseExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.transformType = this.transformType;
        return value;
    };
    TransformCaseExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.transformType = this.transformType;
        return js;
    };
    TransformCaseExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.transformType === other.transformType;
    };
    TransformCaseExpression.prototype._calcChainableHelper = function (operandValue) {
        var transformType = this.transformType;
        return transformType === TransformCaseExpression.UPPER_CASE ? String(operandValue).toLocaleUpperCase() : String(operandValue).toLocaleLowerCase();
    };
    TransformCaseExpression.prototype._getJSChainableHelper = function (operandJS) {
        var transformType = this.transformType;
        return Expression.jsNullSafetyUnary(operandJS, function (input) {
            return transformType === TransformCaseExpression.UPPER_CASE ? "String(" + input + ").toLocaleUpperCase()" : "String(" + input + ").toLocaleLowerCase()";
        });
    };
    TransformCaseExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        var transformType = this.transformType;
        return transformType === TransformCaseExpression.UPPER_CASE ? "UPPER(" + operandSQL + ")" : "LOWER(" + operandSQL + ")";
    };
    TransformCaseExpression.prototype.specialSimplify = function () {
        var operand = this.operand;
        if (operand instanceof TransformCaseExpression)
            return this.changeOperand(operand.operand);
        return this;
    };
    TransformCaseExpression.UPPER_CASE = 'upperCase';
    TransformCaseExpression.LOWER_CASE = 'lowerCase';
    TransformCaseExpression.op = "TransformCase";
    return TransformCaseExpression;
}(ChainableExpression));
Expression.register(TransformCaseExpression);













var TotalContainer = exports.TotalContainer = (function () {
    function TotalContainer(d) {
        this.datum = d;
    }
    TotalContainer.prototype.toJS = function () {
        return {
            datum: Dataset.datumToJS(this.datum)
        };
    };
    return TotalContainer;
}());
function nullMap(xs, fn) {
    if (!xs)
        return null;
    var res = [];
    for (var _i = 0, xs_1 = xs; _i < xs_1.length; _i++) {
        var x = xs_1[_i];
        var y = fn(x);
        if (y)
            res.push(y);
    }
    return res.length ? res : null;
}
function filterToAnds(filter) {
    if (filter.equals(Expression.TRUE))
        return [];
    if (filter instanceof AndExpression)
        return filter.getExpressionList();
    return [filter];
}
function filterDiff(strongerFilter, weakerFilter) {
    var strongerFilterAnds = filterToAnds(strongerFilter);
    var weakerFilterAnds = filterToAnds(weakerFilter);
    if (weakerFilterAnds.length > strongerFilterAnds.length)
        return null;
    for (var i = 0; i < weakerFilterAnds.length; i++) {
        if (!(weakerFilterAnds[i].equals(strongerFilterAnds[i])))
            return null;
    }
    return Expression.and(strongerFilterAnds.slice(weakerFilterAnds.length));
}
function getCommonFilter(filter1, filter2) {
    var filter1Ands = filterToAnds(filter1);
    var filter2Ands = filterToAnds(filter2);
    var minLength = Math.min(filter1Ands.length, filter2Ands.length);
    var commonExpressions = [];
    for (var i = 0; i < minLength; i++) {
        if (!filter1Ands[i].equals(filter2Ands[i]))
            break;
        commonExpressions.push(filter1Ands[i]);
    }
    return Expression.and(commonExpressions);
}
function mergeDerivedAttributes(derivedAttributes1, derivedAttributes2) {
    var derivedAttributes = Object.create(null);
    for (var k in derivedAttributes1) {
        derivedAttributes[k] = derivedAttributes1[k];
    }
    for (var k in derivedAttributes2) {
        if (hasOwnProperty(derivedAttributes, k) && !derivedAttributes[k].equals(derivedAttributes2[k])) {
            throw new Error("can not currently redefine conflicting " + k);
        }
        derivedAttributes[k] = derivedAttributes2[k];
    }
    return derivedAttributes;
}
function getSampleValue(valueType, ex) {
    switch (valueType) {
        case 'BOOLEAN':
            return true;
        case 'NUMBER':
            return 4;
        case 'NUMBER_RANGE':
            if (ex instanceof NumberBucketExpression) {
                return new NumberRange({
                    start: ex.offset,
                    end: ex.offset + ex.size
                });
            }
            else {
                return new NumberRange({ start: 0, end: 1 });
            }
        case 'TIME':
            return new Date('2015-03-14T00:00:00');
        case 'TIME_RANGE':
            if (ex instanceof TimeBucketExpression) {
                var timezone = ex.timezone || Timezone.UTC;
                var start = ex.duration.floor(new Date('2015-03-14T00:00:00'), timezone);
                return new TimeRange({
                    start: start,
                    end: ex.duration.shift(start, timezone, 1)
                });
            }
            else {
                return new TimeRange({ start: new Date('2015-03-14T00:00:00'), end: new Date('2015-03-15T00:00:00') });
            }
        case 'STRING':
            if (ex instanceof RefExpression) {
                return 'some_' + ex.name;
            }
            else {
                return 'something';
            }
        case 'SET/STRING':
            if (ex instanceof RefExpression) {
                return Set.fromJS([ex.name + '1']);
            }
            else {
                return Set.fromJS(['something']);
            }
        case 'STRING_RANGE':
            if (ex instanceof RefExpression) {
                return StringRange.fromJS({ start: 'some_' + ex.name, end: null });
            }
            else {
                return StringRange.fromJS({ start: 'something', end: null });
            }
        default:
            throw new Error("unsupported simulation on: " + valueType);
    }
}
function immutableAdd(obj, key, value) {
    var newObj = Object.create(null);
    for (var k in obj)
        newObj[k] = obj[k];
    newObj[key] = value;
    return newObj;
}
function findApplyByExpression(applies, expression) {
    for (var _i = 0, applies_1 = applies; _i < applies_1.length; _i++) {
        var apply = applies_1[_i];
        if (apply.expression.equals(expression))
            return apply;
    }
    return null;
}
var External = exports.External = (function () {
    function External(parameters, dummy) {
        if (dummy === void 0) { dummy = null; }
        this.attributes = null;
        this.attributeOverrides = null;
        if (dummy !== dummyObject) {
            throw new TypeError("can not call `new External` directly use External.fromJS instead");
        }
        this.engine = parameters.engine;
        var version = null;
        if (parameters.version) {
            version = External.extractVersion(parameters.version);
            if (!version)
                throw new Error("invalid version " + parameters.version);
        }
        this.version = version;
        this.source = parameters.source;
        this.suppress = Boolean(parameters.suppress);
        this.rollup = Boolean(parameters.rollup);
        if (parameters.attributes) {
            this.attributes = parameters.attributes;
        }
        if (parameters.attributeOverrides) {
            this.attributeOverrides = parameters.attributeOverrides;
        }
        this.derivedAttributes = parameters.derivedAttributes || {};
        if (parameters.delegates) {
            this.delegates = parameters.delegates;
        }
        this.concealBuckets = parameters.concealBuckets;
        this.rawAttributes = parameters.rawAttributes || parameters.attributes || [];
        this.requester = parameters.requester;
        this.mode = parameters.mode || 'raw';
        this.filter = parameters.filter || Expression.TRUE;
        if (this.rawAttributes.length) {
            this.derivedAttributes = External.typeCheckDerivedAttributes(this.derivedAttributes, this.getRawFullType(true));
            this.filter = this.filter.changeInTypeContext(this.getRawFullType());
        }
        switch (this.mode) {
            case 'raw':
                this.select = parameters.select;
                this.sort = parameters.sort;
                this.limit = parameters.limit;
                break;
            case 'value':
                this.valueExpression = parameters.valueExpression;
                break;
            case 'total':
                this.applies = parameters.applies || [];
                break;
            case 'split':
                this.select = parameters.select;
                this.dataName = parameters.dataName;
                this.split = parameters.split;
                if (!this.split)
                    throw new Error('must have split action in split mode');
                this.applies = parameters.applies || [];
                this.sort = parameters.sort;
                this.limit = parameters.limit;
                this.havingFilter = parameters.havingFilter || Expression.TRUE;
                break;
        }
    }
    External.isExternal = function (candidate) {
        return candidate instanceof External;
    };
    External.extractVersion = function (v) {
        if (!v)
            return null;
        var m = v.match(/^\d+\.\d+\.\d+(?:-[\w\-]+)?/);
        return m ? m[0] : null;
    };
    External.versionLessThan = function (va, vb) {
        var pa = va.split('-')[0].split('.');
        var pb = vb.split('-')[0].split('.');
        if (pa[0] !== pb[0])
            return pa[0] < pb[0];
        if (pa[1] !== pb[1])
            return pa[1] < pb[1];
        return pa[2] < pb[2];
    };
    External.deduplicateExternals = function (externals) {
        if (externals.length < 2)
            return externals;
        var uniqueExternals = [externals[0]];
        function addToUniqueExternals(external) {
            for (var _i = 0, uniqueExternals_1 = uniqueExternals; _i < uniqueExternals_1.length; _i++) {
                var uniqueExternal = uniqueExternals_1[_i];
                if (uniqueExternal.equalBaseAndFilter(external))
                    return;
            }
            uniqueExternals.push(external);
        }
        for (var i = 1; i < externals.length; i++)
            addToUniqueExternals(externals[i]);
        return uniqueExternals;
    };
    External.addExtraFilter = function (ex, extraFilter) {
        if (extraFilter.equals(Expression.TRUE))
            return ex;
        return ex.substitute(function (ex) {
            if (ex instanceof RefExpression && ex.type === 'DATASET' && ex.name === External.SEGMENT_NAME) {
                return ex.filter(extraFilter);
            }
            return null;
        });
    };
    External.makeZeroDatum = function (applies) {
        var newDatum = Object.create(null);
        for (var _i = 0, applies_2 = applies; _i < applies_2.length; _i++) {
            var apply = applies_2[_i];
            var applyName = apply.name;
            if (applyName[0] === '_')
                continue;
            newDatum[applyName] = 0;
        }
        return newDatum;
    };
    External.normalizeAndAddApply = function (attributesAndApplies, apply) {
        var attributes = attributesAndApplies.attributes, applies = attributesAndApplies.applies;
        var expressions = Object.create(null);
        for (var _i = 0, applies_3 = applies; _i < applies_3.length; _i++) {
            var existingApply = applies_3[_i];
            expressions[existingApply.name] = existingApply.expression;
        }
        apply = apply.changeExpression(apply.expression.resolveWithExpressions(expressions, 'leave').simplify());
        return {
            attributes: NamedArray.overrideByName(attributes, new AttributeInfo({ name: apply.name, type: apply.expression.type })),
            applies: NamedArray.overrideByName(applies, apply)
        };
    };
    External.segregationAggregateApplies = function (applies) {
        var aggregateApplies = [];
        var postAggregateApplies = [];
        var nameIndex = 0;
        var appliesToSegregate = [];
        for (var _i = 0, applies_4 = applies; _i < applies_4.length; _i++) {
            var apply = applies_4[_i];
            var applyExpression = apply.expression;
            if (applyExpression.isAggregate()) {
                aggregateApplies.push(apply);
            }
            else {
                appliesToSegregate.push(apply);
            }
        }
        for (var _a = 0, appliesToSegregate_1 = appliesToSegregate; _a < appliesToSegregate_1.length; _a++) {
            var apply = appliesToSegregate_1[_a];
            var newExpression = apply.expression.substitute(function (ex) {
                if (ex.isAggregate()) {
                    var existingApply = findApplyByExpression(aggregateApplies, ex);
                    if (existingApply) {
                        return $(existingApply.name, ex.type);
                    }
                    else {
                        var name = '!T_' + (nameIndex++);
                        aggregateApplies.push(Expression._.apply(name, ex));
                        return $(name, ex.type);
                    }
                }
                return null;
            });
            postAggregateApplies.push(apply.changeExpression(newExpression));
        }
        return {
            aggregateApplies: aggregateApplies,
            postAggregateApplies: postAggregateApplies
        };
    };
    External.getCommonFilterFromExternals = function (externals) {
        if (!externals.length)
            throw new Error('must have externals');
        var commonFilter = externals[0].filter;
        for (var i = 1; i < externals.length; i++) {
            commonFilter = getCommonFilter(commonFilter, externals[i].filter);
        }
        return commonFilter;
    };
    External.getMergedDerivedAttributesFromExternals = function (externals) {
        if (!externals.length)
            throw new Error('must have externals');
        var derivedAttributes = externals[0].derivedAttributes;
        for (var i = 1; i < externals.length; i++) {
            derivedAttributes = mergeDerivedAttributes(derivedAttributes, externals[i].derivedAttributes);
        }
        return derivedAttributes;
    };
    External.getSimpleInflater = function (splitExpression, label) {
        switch (splitExpression.type) {
            case 'BOOLEAN': return External.booleanInflaterFactory(label);
            case 'NUMBER': return External.numberInflaterFactory(label);
            case 'TIME': return External.timeInflaterFactory(label);
            default: return null;
        }
    };
    External.booleanInflaterFactory = function (label) {
        return function (d) {
            var v = '' + d[label];
            switch (v) {
                case 'null':
                    d[label] = null;
                    break;
                case '0':
                case 'false':
                    d[label] = false;
                    break;
                case '1':
                case 'true':
                    d[label] = true;
                    break;
                default:
                    throw new Error("got strange result from boolean: " + v);
            }
        };
    };
    External.timeRangeInflaterFactory = function (label, duration, timezone) {
        return function (d) {
            var v = d[label];
            if ('' + v === "null") {
                d[label] = null;
                return;
            }
            var start = new Date(v);
            d[label] = new TimeRange({ start: start, end: duration.shift(start, timezone) });
        };
    };
    External.numberRangeInflaterFactory = function (label, rangeSize) {
        return function (d) {
            var v = d[label];
            if ('' + v === "null") {
                d[label] = null;
                return;
            }
            var start = Number(v);
            d[label] = new NumberRange({
                start: start,
                end: safeAdd(start, rangeSize)
            });
        };
    };
    External.numberInflaterFactory = function (label) {
        return function (d) {
            var v = d[label];
            if ('' + v === "null") {
                d[label] = null;
                return;
            }
            v = Number(v);
            d[label] = isNaN(v) ? null : v;
        };
    };
    External.timeInflaterFactory = function (label) {
        return function (d) {
            var v = d[label];
            if ('' + v === "null") {
                d[label] = null;
                return;
            }
            d[label] = new Date(v);
        };
    };
    External.setStringInflaterFactory = function (label) {
        return function (d) {
            var v = d[label];
            if ('' + v === "null") {
                d[label] = null;
                return;
            }
            if (typeof v === 'string')
                v = [v];
            d[label] = Set.fromJS({
                setType: 'STRING',
                elements: v
            });
        };
    };
    External.setCardinalityInflaterFactory = function (label) {
        return function (d) {
            var v = d[label];
            d[label] = Array.isArray(v) ? v.length : 1;
        };
    };
    External.typeCheckDerivedAttributes = function (derivedAttributes, typeContext) {
        var changed = false;
        var newDerivedAttributes = {};
        for (var k in derivedAttributes) {
            var ex = derivedAttributes[k];
            var newEx = ex.changeInTypeContext(typeContext);
            if (ex !== newEx)
                changed = true;
            newDerivedAttributes[k] = newEx;
        }
        return changed ? newDerivedAttributes : derivedAttributes;
    };
    External.jsToValue = function (parameters, requester) {
        var value = {
            engine: parameters.engine,
            version: parameters.version,
            source: parameters.source,
            suppress: true,
            rollup: parameters.rollup,
            concealBuckets: Boolean(parameters.concealBuckets),
            requester: requester
        };
        if (parameters.attributes) {
            value.attributes = AttributeInfo.fromJSs(parameters.attributes);
        }
        if (parameters.attributeOverrides) {
            value.attributeOverrides = AttributeInfo.fromJSs(parameters.attributeOverrides);
        }
        if (parameters.derivedAttributes) {
            value.derivedAttributes = Expression.expressionLookupFromJS(parameters.derivedAttributes);
        }
        value.filter = parameters.filter ? Expression.fromJS(parameters.filter) : Expression.TRUE;
        return value;
    };
    External.register = function (ex) {
        var engine = ex.engine.replace(/^\w/, function (s) { return s.toLowerCase(); });
        External.classMap[engine] = ex;
    };
    External.getConstructorFor = function (engine) {
        var ClassFn = External.classMap[engine];
        if (!ClassFn)
            throw new Error("unsupported engine '" + engine + "'");
        return ClassFn;
    };
    External.uniteValueExternalsIntoTotal = function (keyExternals) {
        if (keyExternals.length === 0)
            return null;
        var applies = [];
        var baseExternal = null;
        for (var _i = 0, keyExternals_1 = keyExternals; _i < keyExternals_1.length; _i++) {
            var keyExternal = keyExternals_1[_i];
            var key = keyExternal.key;
            var external = keyExternal.external;
            if (!baseExternal)
                baseExternal = external;
            applies.push(Expression._.apply(key, new ExternalExpression({ external: external })));
        }
        return keyExternals[0].external.getBase().makeTotal(applies);
    };
    External.fromJS = function (parameters, requester) {
        if (requester === void 0) { requester = null; }
        if (!hasOwnProperty(parameters, "engine")) {
            throw new Error("external `engine` must be defined");
        }
        var engine = parameters.engine;
        if (typeof engine !== "string")
            throw new Error("engine must be a string");
        var ClassFn = External.getConstructorFor(engine);
        if (!requester && hasOwnProperty(parameters, 'requester')) {
            console.warn("'requester' parameter should be passed as context (2nd argument)");
            requester = parameters.requester;
        }
        if (!parameters.source) {
            parameters.source = parameters.dataSource || parameters.table;
        }
        return ClassFn.fromJS(parameters, requester);
    };
    External.fromValue = function (parameters) {
        var engine = parameters.engine;
        var ClassFn = External.getConstructorFor(engine);
        return new ClassFn(parameters);
    };
    External.prototype._ensureEngine = function (engine) {
        if (!this.engine) {
            this.engine = engine;
            return;
        }
        if (this.engine !== engine) {
            throw new TypeError("incorrect engine '" + this.engine + "' (needs to be: '" + engine + "')");
        }
    };
    External.prototype._ensureMinVersion = function (minVersion) {
        if (this.version && External.versionLessThan(this.version, minVersion)) {
            throw new Error("only " + this.engine + " versions >= " + minVersion + " are supported");
        }
    };
    External.prototype.valueOf = function () {
        var value = {
            engine: this.engine,
            version: this.version,
            source: this.source,
            rollup: this.rollup,
            mode: this.mode
        };
        if (this.suppress)
            value.suppress = this.suppress;
        if (this.attributes)
            value.attributes = this.attributes;
        if (this.attributeOverrides)
            value.attributeOverrides = this.attributeOverrides;
        if (nonEmptyLookup(this.derivedAttributes))
            value.derivedAttributes = this.derivedAttributes;
        if (this.delegates)
            value.delegates = this.delegates;
        value.concealBuckets = this.concealBuckets;
        if (this.mode !== 'raw' && this.rawAttributes) {
            value.rawAttributes = this.rawAttributes;
        }
        if (this.requester) {
            value.requester = this.requester;
        }
        if (this.dataName) {
            value.dataName = this.dataName;
        }
        value.filter = this.filter;
        if (this.valueExpression) {
            value.valueExpression = this.valueExpression;
        }
        if (this.select) {
            value.select = this.select;
        }
        if (this.split) {
            value.split = this.split;
        }
        if (this.applies) {
            value.applies = this.applies;
        }
        if (this.sort) {
            value.sort = this.sort;
        }
        if (this.limit) {
            value.limit = this.limit;
        }
        if (this.havingFilter) {
            value.havingFilter = this.havingFilter;
        }
        return value;
    };
    External.prototype.toJS = function () {
        var js = {
            engine: this.engine,
            source: this.source
        };
        if (this.version)
            js.version = this.version;
        if (this.rollup)
            js.rollup = true;
        if (this.attributes)
            js.attributes = AttributeInfo.toJSs(this.attributes);
        if (this.attributeOverrides)
            js.attributeOverrides = AttributeInfo.toJSs(this.attributeOverrides);
        if (nonEmptyLookup(this.derivedAttributes))
            js.derivedAttributes = Expression.expressionLookupToJS(this.derivedAttributes);
        if (this.concealBuckets)
            js.concealBuckets = true;
        if (this.mode !== 'raw' && this.rawAttributes)
            js.rawAttributes = AttributeInfo.toJSs(this.rawAttributes);
        if (!this.filter.equals(Expression.TRUE)) {
            js.filter = this.filter.toJS();
        }
        return js;
    };
    External.prototype.toJSON = function () {
        return this.toJS();
    };
    External.prototype.toString = function () {
        var mode = this.mode;
        switch (mode) {
            case 'raw':
                return "ExternalRaw(" + this.filter + ")";
            case 'value':
                return "ExternalValue(" + this.valueExpression + ")";
            case 'total':
                return "ExternalTotal(" + this.applies.length + ")";
            case 'split':
                return "ExternalSplit(" + this.split + ", " + this.applies.length + ")";
            default:
                throw new Error("unknown mode: " + mode);
        }
    };
    External.prototype.equals = function (other) {
        return this.equalBaseAndFilter(other) &&
            immutableLookupsEqual(this.derivedAttributes, other.derivedAttributes) &&
            immutableArraysEqual(this.attributes, other.attributes) &&
            immutableArraysEqual(this.delegates, other.delegates) &&
            this.concealBuckets === other.concealBuckets &&
            Boolean(this.requester) === Boolean(other.requester);
    };
    External.prototype.equalBaseAndFilter = function (other) {
        return this.equalBase(other) &&
            this.filter.equals(other.filter);
    };
    External.prototype.equalBase = function (other) {
        return other instanceof External &&
            this.engine === other.engine &&
            String(this.source) === String(other.source) &&
            this.version === other.version &&
            this.rollup === other.rollup &&
            this.mode === other.mode;
    };
    External.prototype.changeVersion = function (version) {
        var value = this.valueOf();
        value.version = version;
        return External.fromValue(value);
    };
    External.prototype.attachRequester = function (requester) {
        var value = this.valueOf();
        value.requester = requester;
        return External.fromValue(value);
    };
    External.prototype.versionBefore = function (neededVersion) {
        var version = this.version;
        return version && External.versionLessThan(version, neededVersion);
    };
    External.prototype.getAttributesInfo = function (attributeName) {
        return NamedArray.get(this.rawAttributes, attributeName);
    };
    External.prototype.updateAttribute = function (newAttribute) {
        if (!this.attributes)
            return this;
        var value = this.valueOf();
        value.attributes = AttributeInfo.override(value.attributes, [newAttribute]);
        return External.fromValue(value);
    };
    External.prototype.show = function () {
        var value = this.valueOf();
        value.suppress = false;
        return External.fromValue(value);
    };
    External.prototype.hasAttribute = function (name) {
        var _a = this, attributes = _a.attributes, rawAttributes = _a.rawAttributes, derivedAttributes = _a.derivedAttributes;
        if (SimpleArray.find(rawAttributes || attributes, function (a) { return a.name === name; }))
            return true;
        return hasOwnProperty(derivedAttributes, name);
    };
    External.prototype.expressionDefined = function (ex) {
        return ex.definedInTypeContext(this.getFullType());
    };
    External.prototype.bucketsConcealed = function (ex) {
        var _this = this;
        return ex.every(function (ex, index, depth, nestDiff) {
            if (nestDiff)
                return true;
            if (ex instanceof RefExpression) {
                var refAttributeInfo = _this.getAttributesInfo(ex.name);
                if (refAttributeInfo && refAttributeInfo.maker instanceof TimeFloorExpression) {
                    return refAttributeInfo.maker.alignsWith(ex);
                }
            }
            else if (ex instanceof ChainableExpression) {
                var refExpression = ex.operand;
                if (refExpression instanceof RefExpression) {
                    var refAttributeInfo = _this.getAttributesInfo(refExpression.name);
                    if (refAttributeInfo && refAttributeInfo.maker instanceof TimeFloorExpression) {
                        return refAttributeInfo.maker.alignsWith(ex);
                    }
                }
            }
            return null;
        });
    };
    External.prototype.addDelegate = function (delegate) {
        var value = this.valueOf();
        if (!value.delegates)
            value.delegates = [];
        value.delegates = value.delegates.concat(delegate);
        return External.fromValue(value);
    };
    External.prototype.getBase = function () {
        var value = this.valueOf();
        value.suppress = true;
        value.mode = 'raw';
        value.dataName = null;
        if (this.mode !== 'raw')
            value.attributes = value.rawAttributes;
        value.rawAttributes = null;
        value.filter = null;
        value.applies = [];
        value.split = null;
        value.sort = null;
        value.limit = null;
        value.delegates = nullMap(value.delegates, function (e) { return e.getBase(); });
        return External.fromValue(value);
    };
    External.prototype.getRaw = function () {
        if (this.mode === 'raw')
            return this;
        var value = this.valueOf();
        value.suppress = true;
        value.mode = 'raw';
        value.dataName = null;
        value.attributes = value.rawAttributes;
        value.rawAttributes = null;
        value.applies = [];
        value.split = null;
        value.sort = null;
        value.limit = null;
        value.delegates = nullMap(value.delegates, function (e) { return e.getRaw(); });
        return External.fromValue(value);
    };
    External.prototype.makeTotal = function (applies) {
        if (this.mode !== 'raw')
            return null;
        if (!this.canHandleTotal())
            return null;
        if (!applies.length)
            throw new Error('must have applies');
        var externals = [];
        for (var _i = 0, applies_5 = applies; _i < applies_5.length; _i++) {
            var apply = applies_5[_i];
            var applyExpression = apply.expression;
            if (applyExpression instanceof ExternalExpression) {
                externals.push(applyExpression.external);
            }
        }
        var commonFilter = External.getCommonFilterFromExternals(externals);
        var value = this.valueOf();
        value.mode = 'total';
        value.suppress = false;
        value.rawAttributes = value.attributes;
        value.derivedAttributes = External.getMergedDerivedAttributesFromExternals(externals);
        value.filter = commonFilter;
        value.attributes = [];
        value.applies = [];
        value.delegates = nullMap(value.delegates, function (e) { return e.makeTotal(applies); });
        var totalExternal = External.fromValue(value);
        for (var _a = 0, applies_6 = applies; _a < applies_6.length; _a++) {
            var apply = applies_6[_a];
            totalExternal = totalExternal._addApplyExpression(apply);
            if (!totalExternal)
                return null;
        }
        return totalExternal;
    };
    External.prototype.addExpression = function (ex) {
        if (ex instanceof FilterExpression) {
            return this._addFilterExpression(ex);
        }
        if (ex instanceof SelectExpression) {
            return this._addSelectExpression(ex);
        }
        if (ex instanceof SplitExpression) {
            return this._addSplitExpression(ex);
        }
        if (ex instanceof ApplyExpression) {
            return this._addApplyExpression(ex);
        }
        if (ex instanceof SortExpression) {
            return this._addSortExpression(ex);
        }
        if (ex instanceof LimitExpression) {
            return this._addLimitExpression(ex);
        }
        if (ex.isAggregate()) {
            return this._addAggregateExpression(ex);
        }
        return this._addPostAggregateExpression(ex);
    };
    External.prototype._addFilterExpression = function (filter) {
        var expression = filter.expression;
        if (!expression.resolvedWithoutExternals())
            return null;
        if (!this.expressionDefined(expression))
            return null;
        var value = this.valueOf();
        switch (this.mode) {
            case 'raw':
                if (this.concealBuckets && !this.bucketsConcealed(expression))
                    return null;
                if (!this.canHandleFilter(filter))
                    return null;
                if (value.filter.equals(Expression.TRUE)) {
                    value.filter = expression;
                }
                else {
                    value.filter = value.filter.and(expression);
                }
                break;
            case 'split':
                if (!this.canHandleHavingFilter(filter))
                    return null;
                value.havingFilter = value.havingFilter.and(expression).simplify();
                break;
            default:
                return null;
        }
        value.delegates = nullMap(value.delegates, function (e) { return e._addFilterExpression(filter); });
        return External.fromValue(value);
    };
    External.prototype._addSelectExpression = function (selectExpression) {
        var mode = this.mode;
        if (mode !== 'raw' && mode !== 'split')
            return null;
        var datasetType = this.getFullType().datasetType;
        var attributes = selectExpression.attributes;
        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
            var attribute = attributes_1[_i];
            if (!datasetType[attribute])
                return null;
        }
        var value = this.valueOf();
        value.suppress = false;
        value.select = selectExpression;
        value.delegates = nullMap(value.delegates, function (e) { return e._addSelectExpression(selectExpression); });
        if (mode === 'split') {
            value.applies = value.applies.filter(function (apply) { return attributes.indexOf(apply.name) !== -1; });
            value.attributes = value.attributes.filter(function (attribute) { return attributes.indexOf(attribute.name) !== -1; });
        }
        return External.fromValue(value);
    };
    External.prototype._addSplitExpression = function (split) {
        if (this.mode !== 'raw')
            return null;
        var splitKeys = split.keys;
        for (var _i = 0, splitKeys_1 = splitKeys; _i < splitKeys_1.length; _i++) {
            var splitKey = splitKeys_1[_i];
            var splitExpression = split.splits[splitKey];
            if (!this.expressionDefined(splitExpression))
                return null;
            if (this.concealBuckets && !this.bucketsConcealed(splitExpression))
                return null;
            if (!this.canHandleSplitExpression(splitExpression))
                return null;
        }
        if (!this.canHandleSplit(split))
            return null;
        var value = this.valueOf();
        value.suppress = false;
        value.mode = 'split';
        value.dataName = split.dataName;
        value.split = split;
        value.rawAttributes = value.attributes;
        value.attributes = split.mapSplits(function (name, expression) { return new AttributeInfo({ name: name, type: unwrapSetType(expression.type) }); });
        value.delegates = nullMap(value.delegates, function (e) { return e._addSplitExpression(split); });
        return External.fromValue(value);
    };
    External.prototype._addApplyExpression = function (apply) {
        var expression = apply.expression;
        if (expression.type === 'DATASET')
            return null;
        if (!expression.resolved())
            return null;
        if (!this.expressionDefined(expression))
            return null;
        if (!this.canHandleApply(apply))
            return null;
        var value;
        if (this.mode === 'raw') {
            value = this.valueOf();
            value.derivedAttributes = immutableAdd(value.derivedAttributes, apply.name, apply.expression);
        }
        else {
            if (this.split && this.split.hasKey(apply.name))
                return null;
            var applyExpression = apply.expression;
            if (applyExpression instanceof ExternalExpression) {
                apply = apply.changeExpression(applyExpression.external.valueExpressionWithinFilter(this.filter));
            }
            value = this.valueOf();
            var added = External.normalizeAndAddApply(value, apply);
            value.applies = added.applies;
            value.attributes = added.attributes;
        }
        value.delegates = nullMap(value.delegates, function (e) { return e._addApplyExpression(apply); });
        return External.fromValue(value);
    };
    External.prototype._addSortExpression = function (sort) {
        if (this.limit)
            return null;
        if (!this.canHandleSort(sort))
            return null;
        var value = this.valueOf();
        value.sort = sort;
        value.delegates = nullMap(value.delegates, function (e) { return e._addSortExpression(sort); });
        return External.fromValue(value);
    };
    External.prototype._addLimitExpression = function (limit) {
        if (!this.canHandleLimit(limit))
            return null;
        var value = this.valueOf();
        value.suppress = false;
        if (!value.limit || limit.value < value.limit.value) {
            value.limit = limit;
        }
        value.delegates = nullMap(value.delegates, function (e) { return e._addLimitExpression(limit); });
        return External.fromValue(value);
    };
    External.prototype._addAggregateExpression = function (aggregate) {
        if (this.mode !== 'raw' || this.limit)
            return null;
        if (aggregate instanceof ChainableExpression) {
            if (aggregate instanceof ChainableUnaryExpression) {
                if (!this.expressionDefined(aggregate.expression))
                    return null;
            }
            var value = this.valueOf();
            value.mode = 'value';
            value.suppress = false;
            value.valueExpression = aggregate.changeOperand($(External.SEGMENT_NAME, 'DATASET'));
            value.rawAttributes = value.attributes;
            value.attributes = null;
            value.delegates = nullMap(value.delegates, function (e) { return e._addAggregateExpression(aggregate); });
            return External.fromValue(value);
        }
        else {
            return null;
        }
    };
    External.prototype._addPostAggregateExpression = function (action) {
        if (this.mode !== 'value')
            throw new Error('must be in value mode to call addPostAggregateExpression');
        if (action instanceof ChainableExpression) {
            if (!action.operand.equals(Expression._))
                return null;
            var commonFilter = this.filter;
            var newValueExpression = void 0;
            if (action instanceof ChainableUnaryExpression) {
                var actionExpression = action.expression;
                if (actionExpression instanceof ExternalExpression) {
                    var otherExternal = actionExpression.external;
                    if (!this.equalBase(otherExternal))
                        return null;
                    commonFilter = getCommonFilter(commonFilter, otherExternal.filter);
                    var newExpression = action.changeExpression(otherExternal.valueExpressionWithinFilter(commonFilter));
                    newValueExpression = this.valueExpressionWithinFilter(commonFilter).performAction(newExpression);
                }
                else if (!actionExpression.hasExternal()) {
                    newValueExpression = this.valueExpression.performAction(action);
                }
                else {
                    return null;
                }
            }
            else {
                newValueExpression = this.valueExpression.performAction(action);
            }
            var value = this.valueOf();
            value.valueExpression = newValueExpression;
            value.filter = commonFilter;
            value.delegates = nullMap(value.delegates, function (e) { return e._addPostAggregateExpression(action); });
            return External.fromValue(value);
        }
        else {
            return null;
        }
    };
    External.prototype.prePush = function (ex) {
        if (this.mode !== 'value')
            return null;
        if (ex.type === 'DATASET')
            return null;
        if (!ex.operand.noRefs() || !ex.expression.equals(Expression._))
            return null;
        var value = this.valueOf();
        value.valueExpression = ex.changeExpression(value.valueExpression);
        value.delegates = nullMap(value.delegates, function (e) { return e.prePush(ex); });
        return External.fromValue(value);
    };
    External.prototype.valueExpressionWithinFilter = function (withinFilter) {
        if (this.mode !== 'value')
            return null;
        var extraFilter = filterDiff(this.filter, withinFilter);
        if (!extraFilter)
            throw new Error('not within the segment');
        return External.addExtraFilter(this.valueExpression, extraFilter);
    };
    External.prototype.toValueApply = function () {
        if (this.mode !== 'value')
            return null;
        return Expression._.apply(External.VALUE_NAME, this.valueExpression);
    };
    External.prototype.sortOnLabel = function () {
        var sort = this.sort;
        if (!sort)
            return false;
        var sortOn = sort.expression.name;
        if (!this.split || !this.split.hasKey(sortOn))
            return false;
        var applies = this.applies;
        for (var _i = 0, applies_7 = applies; _i < applies_7.length; _i++) {
            var apply = applies_7[_i];
            if (apply.name === sortOn)
                return false;
        }
        return true;
    };
    External.prototype.getQuerySplit = function () {
        var _this = this;
        return this.split.transformExpressions(function (ex) {
            return _this.inlineDerivedAttributes(ex);
        });
    };
    External.prototype.getQueryFilter = function () {
        return this.inlineDerivedAttributes(this.filter).simplify();
    };
    External.prototype.inlineDerivedAttributes = function (expression) {
        var derivedAttributes = this.derivedAttributes;
        return expression.substitute(function (refEx) {
            if (refEx instanceof RefExpression) {
                var refName = refEx.name;
                return derivedAttributes[refName] || null;
            }
            else {
                return null;
            }
        });
    };
    External.prototype.getSelectedAttributes = function () {
        var _a = this, select = _a.select, attributes = _a.attributes, derivedAttributes = _a.derivedAttributes;
        attributes = attributes.slice();
        for (var k in derivedAttributes) {
            attributes.push(new AttributeInfo({ name: k, type: derivedAttributes[k].type }));
        }
        if (!select)
            return attributes;
        var selectAttributes = select.attributes;
        return selectAttributes.map(function (s) { return NamedArray.findByName(attributes, s); });
    };
    External.prototype.getValueType = function () {
        var valueExpression = this.valueExpression;
        if (!valueExpression)
            return null;
        return valueExpression.type;
    };
    External.prototype.addNextExternal = function (dataset) {
        var _this = this;
        var _a = this, mode = _a.mode, dataName = _a.dataName, split = _a.split;
        if (mode !== 'split')
            throw new Error('must be in split mode to addNextExternal');
        return dataset.applyFn(dataName, function (d) {
            return _this.getRaw()._addFilterExpression(Expression._.filter(split.filterFromDatum(d)));
        }, 'DATASET');
    };
    External.prototype.getDelegate = function () {
        var _a = this, mode = _a.mode, delegates = _a.delegates;
        if (!delegates || !delegates.length || mode === 'raw')
            return null;
        return delegates[0];
    };
    External.prototype.simulateValue = function (lastNode, simulatedQueries, externalForNext) {
        if (externalForNext === void 0) { externalForNext = null; }
        var mode = this.mode;
        if (!externalForNext)
            externalForNext = this;
        var delegate = this.getDelegate();
        if (delegate) {
            return delegate.simulateValue(lastNode, simulatedQueries, externalForNext);
        }
        simulatedQueries.push(this.getQueryAndPostProcess().query);
        if (mode === 'value') {
            var valueExpression = this.valueExpression;
            return getSampleValue(valueExpression.type, valueExpression);
        }
        var datum = {};
        if (mode === 'raw') {
            var attributes = this.attributes;
            for (var _i = 0, attributes_2 = attributes; _i < attributes_2.length; _i++) {
                var attribute = attributes_2[_i];
                datum[attribute.name] = getSampleValue(attribute.type, null);
            }
        }
        else {
            if (mode === 'split') {
                this.split.mapSplits(function (name, expression) {
                    datum[name] = getSampleValue(unwrapSetType(expression.type), expression);
                });
            }
            var applies = this.applies;
            for (var _a = 0, applies_8 = applies; _a < applies_8.length; _a++) {
                var apply = applies_8[_a];
                datum[apply.name] = getSampleValue(apply.expression.type, apply.expression);
            }
        }
        if (mode === 'total') {
            return new TotalContainer(datum);
        }
        var dataset = new Dataset({ data: [datum] });
        if (!lastNode && mode === 'split')
            dataset = externalForNext.addNextExternal(dataset);
        return dataset;
    };
    External.prototype.getQueryAndPostProcess = function () {
        throw new Error("can not call getQueryAndPostProcess directly");
    };
    External.prototype.queryValue = function (lastNode, externalForNext) {
        if (externalForNext === void 0) { externalForNext = null; }
        var _a = this, mode = _a.mode, requester = _a.requester;
        if (!externalForNext)
            externalForNext = this;
        var delegate = this.getDelegate();
        if (delegate) {
            return delegate.queryValue(lastNode, externalForNext);
        }
        if (!requester) {
            return Q.reject(new Error('must have a requester to make queries'));
        }
        var queryAndPostProcess;
        try {
            queryAndPostProcess = this.getQueryAndPostProcess();
        }
        catch (e) {
            return Q.reject(e);
        }
        var query = queryAndPostProcess.query, postProcess = queryAndPostProcess.postProcess, next = queryAndPostProcess.next;
        if (!query || typeof postProcess !== 'function') {
            return Q.reject(new Error('no query or postProcess'));
        }
        var finalResult;
        if (next) {
            var results_1 = [];
            finalResult = promiseWhile(function () { return query; }, function () {
                return requester({ query: query })
                    .then(function (result) {
                    results_1.push(result);
                    query = next(query, result);
                });
            })
                .then(function () {
                return queryAndPostProcess.postProcess(results_1);
            });
        }
        else {
            finalResult = requester({ query: query })
                .then(queryAndPostProcess.postProcess);
        }
        if (!lastNode && mode === 'split') {
            finalResult = finalResult.then(externalForNext.addNextExternal.bind(externalForNext));
        }
        return finalResult;
    };
    External.prototype.needsIntrospect = function () {
        return !this.rawAttributes.length;
    };
    External.prototype.introspect = function () {
        var _this = this;
        if (!this.requester) {
            return Q.reject(new Error('must have a requester to introspect'));
        }
        if (!this.version) {
            return this.constructor.getVersion(this.requester).then(function (version) {
                version = External.extractVersion(version);
                if (!version)
                    throw new Error('external version not found, please specify explicitly');
                return _this.changeVersion(version).introspect();
            });
        }
        return this.getIntrospectAttributes()
            .then(function (attributes) {
            var value = _this.valueOf();
            if (value.attributeOverrides) {
                attributes = AttributeInfo.override(attributes, value.attributeOverrides);
            }
            if (value.attributes) {
                attributes = AttributeInfo.override(value.attributes, attributes);
            }
            value.attributes = attributes;
            return External.fromValue(value);
        });
    };
    External.prototype.getRawFullType = function (skipDerived) {
        if (skipDerived === void 0) { skipDerived = false; }
        var _a = this, rawAttributes = _a.rawAttributes, derivedAttributes = _a.derivedAttributes;
        if (!rawAttributes.length)
            throw new Error("dataset has not been introspected");
        var myDatasetType = {};
        for (var _i = 0, rawAttributes_1 = rawAttributes; _i < rawAttributes_1.length; _i++) {
            var rawAttribute = rawAttributes_1[_i];
            var attrName = rawAttribute.name;
            myDatasetType[attrName] = {
                type: rawAttribute.type
            };
        }
        if (!skipDerived) {
            for (var name in derivedAttributes) {
                myDatasetType[name] = {
                    type: derivedAttributes[name].type
                };
            }
        }
        return {
            type: 'DATASET',
            datasetType: myDatasetType
        };
    };
    External.prototype.getFullType = function () {
        var _a = this, mode = _a.mode, attributes = _a.attributes;
        if (mode === 'value')
            throw new Error('not supported for value mode yet');
        var myFullType = this.getRawFullType();
        if (mode !== 'raw') {
            var splitDatasetType = {};
            splitDatasetType[this.dataName || External.SEGMENT_NAME] = myFullType;
            for (var _i = 0, attributes_3 = attributes; _i < attributes_3.length; _i++) {
                var attribute = attributes_3[_i];
                var attrName = attribute.name;
                splitDatasetType[attrName] = {
                    type: attribute.type
                };
            }
            myFullType = {
                type: 'DATASET',
                datasetType: splitDatasetType
            };
        }
        return myFullType;
    };
    External.type = 'EXTERNAL';
    External.SEGMENT_NAME = '__SEGMENT__';
    External.VALUE_NAME = '__VALUE__';
    External.classMap = {};
    return External;
}());
var basicExecutorFactory = exports.basicExecutorFactory = function(parameters) {
    var datasets = parameters.datasets;
    return function (ex, env) {
        if (env === void 0) { env = {}; }
        return ex.compute(datasets, env);
    };
}
Expression.expressionParser = require("./expressionParser")(exports, Chronoshift);



