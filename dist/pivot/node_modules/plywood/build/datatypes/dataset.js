import { isDate } from 'chronoshift';
import { generalEqual, SimpleArray, NamedArray } from 'immutable-class';
import { hasOwnProperty } from '../helper/utils';
import { AttributeInfo } from './attributeInfo';
import { NumberRange } from './numberRange';
import { Set } from './set';
import { StringRange } from './stringRange';
import { TimeRange } from './timeRange';
import { valueFromJS, valueToJSInlineType, datumHasExternal } from './common';
import { Expression, ExternalExpression, LiteralExpression } from '../expressions/index';
import { External, TotalContainer } from '../external/baseExternal';
export function fillExpressionExternalAlteration(alteration, filler) {
    for (var k in alteration) {
        var thing = alteration[k];
        if (Array.isArray(thing)) {
            fillDatasetExternalAlterations(thing, filler);
        }
        else {
            thing.result = filler(thing.external, Boolean(thing.terminal));
        }
    }
}
export function fillDatasetExternalAlterations(alterations, filler) {
    for (var _i = 0, alterations_1 = alterations; _i < alterations_1.length; _i++) {
        var alteration = alterations_1[_i];
        if (alteration.external) {
            alteration.result = filler(alteration.external, alteration.terminal);
        }
        else if (alteration.datasetAlterations) {
            fillDatasetExternalAlterations(alteration.datasetAlterations, filler);
        }
        else if (alteration.expressionAlterations) {
            fillExpressionExternalAlteration(alteration.expressionAlterations, filler);
        }
        else {
            throw new Error('fell through');
        }
    }
}
var directionFns = {
    ascending: function (a, b) {
        if (a == null) {
            return b == null ? 0 : -1;
        }
        else {
            if (a.compare)
                return a.compare(b);
            if (b == null)
                return 1;
        }
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    },
    descending: function (a, b) {
        if (b == null) {
            return a == null ? 0 : -1;
        }
        else {
            if (b.compare)
                return b.compare(a);
            if (a == null)
                return 1;
        }
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }
};
function uniqueColumns(columns) {
    var seen = {};
    var uniqueColumns = [];
    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
        var column = columns_1[_i];
        if (!seen[column.name]) {
            uniqueColumns.push(column);
            seen[column.name] = true;
        }
    }
    return uniqueColumns;
}
function flattenColumns(nestedColumns, prefixColumns) {
    var flatColumns = [];
    var i = 0;
    var prefixString = '';
    while (i < nestedColumns.length) {
        var nestedColumn = nestedColumns[i];
        if (nestedColumn.type === 'DATASET') {
            nestedColumns = nestedColumn.columns;
            if (prefixColumns)
                prefixString += nestedColumn.name + '.';
            i = 0;
        }
        else {
            flatColumns.push({
                name: prefixString + nestedColumn.name,
                type: nestedColumn.type
            });
            i++;
        }
    }
    return uniqueColumns(flatColumns);
}
function removeLineBreaks(v) {
    return v.replace(/(?:\r\n|\r|\n)/g, ' ');
}
var escapeFnCSV = function (v) {
    v = removeLineBreaks(v);
    if (v.indexOf('"') === -1 && v.indexOf(",") === -1)
        return v;
    return "\"" + v.replace(/"/g, '""') + "\"";
};
var escapeFnTSV = function (v) {
    return removeLineBreaks(v).replace(/\t/g, "").replace(/"/g, '""');
};
var typeOrder = {
    'NULL': 0,
    'TIME': 1,
    'TIME_RANGE': 2,
    'SET/TIME': 3,
    'SET/TIME_RANGE': 4,
    'STRING': 5,
    'SET/STRING': 6,
    'BOOLEAN': 7,
    'NUMBER': 8,
    'NUMBER_RANGE': 9,
    'SET/NUMBER': 10,
    'SET/NUMBER_RANGE': 11,
    'DATASET': 12
};
var defaultFormatter = {
    'NULL': function (v) { return 'NULL'; },
    'TIME': function (v) { return v.toISOString(); },
    'TIME_RANGE': function (v) { return '' + v; },
    'SET/TIME': function (v) { return '' + v; },
    'SET/TIME_RANGE': function (v) { return '' + v; },
    'STRING': function (v) { return '' + v; },
    'SET/STRING': function (v) { return '' + v; },
    'BOOLEAN': function (v) { return '' + v; },
    'NUMBER': function (v) { return '' + v; },
    'NUMBER_RANGE': function (v) { return '' + v; },
    'SET/NUMBER': function (v) { return '' + v; },
    'SET/NUMBER_RANGE': function (v) { return '' + v; },
    'DATASET': function (v) { return 'DATASET'; }
};
function isBoolean(b) {
    return b === true || b === false;
}
function isNumber(n) {
    return n !== null && !isNaN(Number(n));
}
function isString(str) {
    return typeof str === "string";
}
function getAttributeInfo(name, attributeValue) {
    if (attributeValue == null)
        return null;
    if (isDate(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'TIME' });
    }
    else if (isBoolean(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'BOOLEAN' });
    }
    else if (isNumber(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'NUMBER' });
    }
    else if (isString(attributeValue)) {
        return new AttributeInfo({ name: name, type: 'STRING' });
    }
    else if (attributeValue instanceof NumberRange) {
        return new AttributeInfo({ name: name, type: 'NUMBER_RANGE' });
    }
    else if (attributeValue instanceof StringRange) {
        return new AttributeInfo({ name: name, type: 'STRING_RANGE' });
    }
    else if (attributeValue instanceof TimeRange) {
        return new AttributeInfo({ name: name, type: 'TIME_RANGE' });
    }
    else if (attributeValue instanceof Set) {
        return new AttributeInfo({ name: name, type: attributeValue.getType() });
    }
    else if (attributeValue instanceof Dataset) {
        return new AttributeInfo({ name: name, type: 'DATASET', datasetType: attributeValue.getFullType().datasetType });
    }
    else {
        throw new Error("Could not introspect " + attributeValue);
    }
}
function joinDatums(datumA, datumB) {
    var newDatum = Object.create(null);
    for (var k in datumA) {
        newDatum[k] = datumA[k];
    }
    for (var k in datumB) {
        newDatum[k] = datumB[k];
    }
    return newDatum;
}
function copy(obj) {
    var newObj = {};
    var k;
    for (k in obj) {
        if (hasOwnProperty(obj, k))
            newObj[k] = obj[k];
    }
    return newObj;
}
var check;
export var Dataset = (function () {
    function Dataset(parameters) {
        this.attributes = null;
        this.keys = null;
        if (parameters.suppress === true)
            this.suppress = true;
        if (parameters.keys) {
            this.keys = parameters.keys;
        }
        var data = parameters.data;
        if (!Array.isArray(data)) {
            throw new TypeError("must have a `data` array");
        }
        this.data = data;
        var attributes = parameters.attributes;
        if (!attributes)
            attributes = Dataset.getAttributesFromData(data);
        var attributeOverrides = parameters.attributeOverrides;
        if (attributeOverrides) {
            attributes = AttributeInfo.override(attributes, attributeOverrides);
        }
        this.attributes = attributes;
    }
    Dataset.isDataset = function (candidate) {
        return candidate instanceof Dataset;
    };
    Dataset.datumFromJS = function (js) {
        if (typeof js !== 'object')
            throw new TypeError("datum must be an object");
        var datum = Object.create(null);
        for (var k in js) {
            if (!hasOwnProperty(js, k))
                continue;
            datum[k] = valueFromJS(js[k]);
        }
        return datum;
    };
    Dataset.datumToJS = function (datum) {
        var js = {};
        for (var k in datum) {
            var v = datum[k];
            if (v && v.suppress)
                continue;
            js[k] = valueToJSInlineType(v);
        }
        return js;
    };
    Dataset.getAttributesFromData = function (data) {
        if (!data.length)
            return [];
        var attributeNamesToIntrospect = Object.keys(data[0]);
        var attributes = [];
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var datum = data_1[_i];
            var attributeNamesStillToIntrospect = [];
            for (var _a = 0, attributeNamesToIntrospect_1 = attributeNamesToIntrospect; _a < attributeNamesToIntrospect_1.length; _a++) {
                var attributeNameToIntrospect = attributeNamesToIntrospect_1[_a];
                var attributeInfo = getAttributeInfo(attributeNameToIntrospect, datum[attributeNameToIntrospect]);
                if (attributeInfo) {
                    attributes.push(attributeInfo);
                }
                else {
                    attributeNamesStillToIntrospect.push(attributeNameToIntrospect);
                }
            }
            attributeNamesToIntrospect = attributeNamesStillToIntrospect;
            if (!attributeNamesToIntrospect.length)
                break;
        }
        for (var _b = 0, attributeNamesToIntrospect_2 = attributeNamesToIntrospect; _b < attributeNamesToIntrospect_2.length; _b++) {
            var attributeName = attributeNamesToIntrospect_2[_b];
            attributes.push(new AttributeInfo({ name: attributeName, type: 'STRING' }));
        }
        attributes.sort(function (a, b) {
            var typeDiff = typeOrder[a.type] - typeOrder[b.type];
            if (typeDiff)
                return typeDiff;
            return a.name.localeCompare(b.name);
        });
        return attributes;
    };
    Dataset.parseJSON = function (text) {
        text = text.trim();
        var firstChar = text[0];
        if (firstChar[0] === '[') {
            try {
                return JSON.parse(text);
            }
            catch (e) {
                throw new Error("could not parse");
            }
        }
        else if (firstChar[0] === '{') {
            return text.split(/\r?\n/).map(function (line, i) {
                try {
                    return JSON.parse(line);
                }
                catch (e) {
                    throw new Error("problem in line: " + i + ": '" + line + "'");
                }
            });
        }
        else {
            throw new Error("Unsupported start, starts with '" + firstChar[0] + "'");
        }
    };
    Dataset.fromJS = function (parameters) {
        if (Array.isArray(parameters)) {
            parameters = { data: parameters };
        }
        if (!Array.isArray(parameters.data)) {
            throw new Error('must have data');
        }
        var value = {};
        if (hasOwnProperty(parameters, 'attributes')) {
            value.attributes = AttributeInfo.fromJSs(parameters.attributes);
        }
        else if (hasOwnProperty(parameters, 'attributeOverrides')) {
            value.attributeOverrides = AttributeInfo.fromJSs(parameters.attributeOverrides);
        }
        value.keys = parameters.keys;
        value.data = parameters.data.map(Dataset.datumFromJS);
        return new Dataset(value);
    };
    Dataset.prototype.valueOf = function () {
        var value = {};
        if (this.suppress)
            value.suppress = true;
        if (this.attributes)
            value.attributes = this.attributes;
        if (this.keys)
            value.keys = this.keys;
        value.data = this.data;
        return value;
    };
    Dataset.prototype.toJS = function () {
        return this.data.map(Dataset.datumToJS);
    };
    Dataset.prototype.toString = function () {
        return "Dataset(" + this.data.length + ")";
    };
    Dataset.prototype.toJSON = function () {
        return this.toJS();
    };
    Dataset.prototype.equals = function (other) {
        return other instanceof Dataset &&
            this.data.length === other.data.length;
    };
    Dataset.prototype.hide = function () {
        var value = this.valueOf();
        value.suppress = true;
        return new Dataset(value);
    };
    Dataset.prototype.basis = function () {
        var data = this.data;
        return data.length === 1 && Object.keys(data[0]).length === 0;
    };
    Dataset.prototype.hasExternal = function () {
        if (!this.data.length)
            return false;
        return datumHasExternal(this.data[0]);
    };
    Dataset.prototype.getFullType = function () {
        var attributes = this.attributes;
        if (!attributes)
            throw new Error("dataset has not been introspected");
        var myDatasetType = {};
        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
            var attribute = attributes_1[_i];
            var attrName = attribute.name;
            if (attribute.type === 'DATASET') {
                myDatasetType[attrName] = {
                    type: 'DATASET',
                    datasetType: attribute.datasetType
                };
            }
            else {
                myDatasetType[attrName] = {
                    type: attribute.type
                };
            }
        }
        return {
            type: 'DATASET',
            datasetType: myDatasetType
        };
    };
    Dataset.prototype.select = function (attrs) {
        var attributes = this.attributes;
        var newAttributes = [];
        var attrLookup = Object.create(null);
        for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
            var attr = attrs_1[_i];
            attrLookup[attr] = true;
            var existingAttribute = NamedArray.get(attributes, attr);
            if (existingAttribute)
                newAttributes.push(existingAttribute);
        }
        var data = this.data;
        var n = data.length;
        var newData = new Array(n);
        for (var i = 0; i < n; i++) {
            var datum = data[i];
            var newDatum = Object.create(null);
            for (var key in datum) {
                if (attrLookup[key]) {
                    newDatum[key] = datum[key];
                }
            }
            newData[i] = newDatum;
        }
        var value = this.valueOf();
        value.attributes = newAttributes;
        value.data = newData;
        return new Dataset(value);
    };
    Dataset.prototype.apply = function (name, ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#apply now takes Expressions use Dataset.applyFn instead");
            return this.applyFn(name, ex, arguments[2]);
        }
        return this.applyFn(name, ex.getFn(), ex.type);
    };
    Dataset.prototype.applyFn = function (name, exFn, type) {
        var data = this.data;
        var n = data.length;
        var newData = new Array(n);
        for (var i = 0; i < n; i++) {
            var datum = data[i];
            var newDatum = Object.create(null);
            for (var key in datum)
                newDatum[key] = datum[key];
            newDatum[name] = exFn(datum);
            newData[i] = newDatum;
        }
        var datasetType = null;
        if (type === 'DATASET' && newData[0] && newData[0][name]) {
            var thing = newData[0][name];
            if (thing instanceof Dataset) {
                datasetType = thing.getFullType().datasetType;
            }
            else {
                datasetType = {};
            }
        }
        var value = this.valueOf();
        value.attributes = NamedArray.overrideByName(value.attributes, new AttributeInfo({ name: name, type: type, datasetType: datasetType }));
        value.data = newData;
        return new Dataset(value);
    };
    Dataset.prototype.filter = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#filter now takes Expressions use Dataset.filterFn instead");
            return this.filterFn(ex);
        }
        return this.filterFn(ex.getFn());
    };
    Dataset.prototype.filterFn = function (exFn) {
        var value = this.valueOf();
        value.data = value.data.filter(function (datum) { return exFn(datum); });
        return new Dataset(value);
    };
    Dataset.prototype.sort = function (ex, direction) {
        if (typeof ex === 'function') {
            console.warn("Dataset#sort now takes Expressions use Dataset.sortFn instead");
            return this.sortFn(ex, direction);
        }
        return this.sortFn(ex.getFn(), direction);
    };
    Dataset.prototype.sortFn = function (exFn, direction) {
        var value = this.valueOf();
        var directionFn = directionFns[direction];
        value.data = this.data.slice().sort(function (a, b) {
            return directionFn(exFn(a), exFn(b));
        });
        return new Dataset(value);
    };
    Dataset.prototype.limit = function (limit) {
        var data = this.data;
        if (data.length <= limit)
            return this;
        var value = this.valueOf();
        value.data = data.slice(0, limit);
        return new Dataset(value);
    };
    Dataset.prototype.count = function () {
        return this.data.length;
    };
    Dataset.prototype.sum = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#sum now takes Expressions use Dataset.sumFn instead");
            return this.sumFn(ex);
        }
        return this.sumFn(ex.getFn());
    };
    Dataset.prototype.sumFn = function (exFn) {
        var data = this.data;
        var sum = 0;
        for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
            var datum = data_2[_i];
            sum += exFn(datum);
        }
        return sum;
    };
    Dataset.prototype.average = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#average now takes Expressions use Dataset.averageFn instead");
            return this.averageFn(ex);
        }
        return this.averageFn(ex.getFn());
    };
    Dataset.prototype.averageFn = function (exFn) {
        var count = this.count();
        return count ? (this.sumFn(exFn) / count) : null;
    };
    Dataset.prototype.min = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#min now takes Expressions use Dataset.minFn instead");
            return this.minFn(ex);
        }
        return this.minFn(ex.getFn());
    };
    Dataset.prototype.minFn = function (exFn) {
        var data = this.data;
        var min = Infinity;
        for (var _i = 0, data_3 = data; _i < data_3.length; _i++) {
            var datum = data_3[_i];
            var v = exFn(datum);
            if (v < min)
                min = v;
        }
        return min;
    };
    Dataset.prototype.max = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#max now takes Expressions use Dataset.maxFn instead");
            return this.maxFn(ex);
        }
        return this.maxFn(ex.getFn());
    };
    Dataset.prototype.maxFn = function (exFn) {
        var data = this.data;
        var max = -Infinity;
        for (var _i = 0, data_4 = data; _i < data_4.length; _i++) {
            var datum = data_4[_i];
            var v = exFn(datum);
            if (max < v)
                max = v;
        }
        return max;
    };
    Dataset.prototype.countDistinct = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#countDistinct now takes Expressions use Dataset.countDistinctFn instead");
            return this.countDistinctFn(ex);
        }
        return this.countDistinctFn(ex.getFn());
    };
    Dataset.prototype.countDistinctFn = function (exFn) {
        var data = this.data;
        var seen = Object.create(null);
        var count = 0;
        for (var _i = 0, data_5 = data; _i < data_5.length; _i++) {
            var datum = data_5[_i];
            var v = exFn(datum);
            if (!seen[v]) {
                seen[v] = 1;
                ++count;
            }
        }
        return count;
    };
    Dataset.prototype.quantile = function (ex, quantile) {
        if (typeof ex === 'function') {
            console.warn("Dataset#quantile now takes Expressions use Dataset.quantileFn instead");
            return this.quantileFn(ex, quantile);
        }
        return this.quantileFn(ex.getFn(), quantile);
    };
    Dataset.prototype.quantileFn = function (exFn, quantile) {
        var data = this.data;
        var vs = [];
        for (var _i = 0, data_6 = data; _i < data_6.length; _i++) {
            var datum = data_6[_i];
            var v = exFn(datum);
            if (v != null)
                vs.push(v);
        }
        vs.sort(function (a, b) { return a - b; });
        var n = vs.length;
        if (quantile === 0)
            return vs[0];
        if (quantile === 1)
            return vs[n - 1];
        var rank = n * quantile - 1;
        if (rank === Math.floor(rank)) {
            return (vs[rank] + vs[rank + 1]) / 2;
        }
        else {
            return vs[Math.ceil(rank)];
        }
    };
    Dataset.prototype.collect = function (ex) {
        if (typeof ex === 'function') {
            console.warn("Dataset#collect now takes Expressions use Dataset.collectFn instead");
            return this.collectFn(ex);
        }
        return this.collectFn(ex.getFn());
    };
    Dataset.prototype.collectFn = function (exFn) {
        return Set.fromJS(this.data.map(exFn));
    };
    Dataset.prototype.split = function (splits, datasetName) {
        var splitFns = {};
        for (var k in splits) {
            var ex = splits[k];
            if (typeof ex === 'function') {
                console.warn("Dataset#collect now takes Expressions use Dataset.collectFn instead");
                return this.split(splits, datasetName);
            }
            splitFns[k] = ex.getFn();
        }
        return this.splitFn(splitFns, datasetName);
    };
    Dataset.prototype.splitFn = function (splitFns, datasetName) {
        var _a = this, data = _a.data, attributes = _a.attributes;
        var keys = Object.keys(splitFns);
        var numberOfKeys = keys.length;
        var splitFnList = keys.map(function (k) { return splitFns[k]; });
        var splits = {};
        var datumGroups = {};
        var finalData = [];
        var finalDataset = [];
        function addDatum(datum, valueList) {
            var key = valueList.join(';_PLYw00d_;');
            if (hasOwnProperty(datumGroups, key)) {
                datumGroups[key].push(datum);
            }
            else {
                var newDatum = Object.create(null);
                for (var i = 0; i < numberOfKeys; i++) {
                    newDatum[keys[i]] = valueList[i];
                }
                finalDataset.push(datumGroups[key] = [datum]);
                splits[key] = newDatum;
                finalData.push(newDatum);
            }
        }
        var _loop_1 = function(datum) {
            var valueList = splitFnList.map(function (splitFn) { return splitFn(datum); });
            var setIndex = -1;
            for (var i = 0; i < valueList.length; i++) {
                if (Set.isSet(valueList[i])) {
                    if (setIndex !== -1)
                        throw new Error("only one SET value is supported in native split for now");
                    setIndex = i;
                }
            }
            if (setIndex !== -1) {
                var elements = valueList[setIndex].elements;
                var atomicValueList = valueList.slice();
                for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                    var element = elements_1[_i];
                    atomicValueList[setIndex] = element;
                    addDatum(datum, atomicValueList);
                }
            }
            else {
                addDatum(datum, valueList);
            }
        };
        for (var _b = 0, data_7 = data; _b < data_7.length; _b++) {
            var datum = data_7[_b];
            _loop_1(datum);
        }
        for (var i = 0; i < finalData.length; i++) {
            finalData[i][datasetName] = new Dataset({
                suppress: true,
                attributes: attributes,
                data: finalDataset[i]
            });
        }
        return new Dataset({
            keys: keys,
            data: finalData
        });
    };
    Dataset.prototype.introspect = function () {
        console.error('introspection is always done, `.introspect()` method never needs to be called');
    };
    Dataset.prototype.getReadyExternals = function () {
        var externalAlterations = [];
        var _a = this, data = _a.data, attributes = _a.attributes;
        for (var i = 0; i < data.length; i++) {
            var datum = data[i];
            var normalExternalAlterations = [];
            var valueExternalAlterations = [];
            for (var _i = 0, attributes_2 = attributes; _i < attributes_2.length; _i++) {
                var attribute = attributes_2[_i];
                var value = datum[attribute.name];
                if (value instanceof Expression) {
                    var subExpressionAlterations = value.getReadyExternals();
                    if (Object.keys(subExpressionAlterations).length) {
                        normalExternalAlterations.push({
                            index: i,
                            key: attribute.name,
                            expressionAlterations: subExpressionAlterations
                        });
                    }
                }
                else if (value instanceof Dataset) {
                    var subDatasetAlterations = value.getReadyExternals();
                    if (subDatasetAlterations.length) {
                        normalExternalAlterations.push({
                            index: i,
                            key: attribute.name,
                            datasetAlterations: subDatasetAlterations
                        });
                    }
                }
                else if (value instanceof External) {
                    if (!value.suppress) {
                        var externalAlteration = {
                            index: i,
                            key: attribute.name,
                            external: value,
                            terminal: true
                        };
                        if (value.mode === 'value') {
                            valueExternalAlterations.push(externalAlteration);
                        }
                        else {
                            normalExternalAlterations.push(externalAlteration);
                        }
                    }
                }
            }
            if (valueExternalAlterations.length) {
                if (valueExternalAlterations.length === 1) {
                    externalAlterations.push(valueExternalAlterations[0]);
                }
                else {
                    externalAlterations.push({
                        index: i,
                        key: '',
                        external: External.uniteValueExternalsIntoTotal(valueExternalAlterations)
                    });
                }
            }
            if (normalExternalAlterations.length) {
                Array.prototype.push.apply(externalAlterations, normalExternalAlterations);
            }
        }
        return externalAlterations;
    };
    Dataset.prototype.applyReadyExternals = function (alterations) {
        var data = this.data;
        for (var _i = 0, alterations_2 = alterations; _i < alterations_2.length; _i++) {
            var alteration = alterations_2[_i];
            var datum = data[alteration.index];
            var key = alteration.key;
            if (alteration.external) {
                var result = alteration.result;
                if (result instanceof TotalContainer) {
                    var resultDatum = result.datum;
                    for (var k in resultDatum) {
                        datum[k] = resultDatum[k];
                    }
                }
                else {
                    datum[key] = result;
                }
            }
            else if (alteration.datasetAlterations) {
                datum[key] = datum[key].applyReadyExternals(alteration.datasetAlterations);
            }
            else if (alteration.expressionAlterations) {
                var exAlt = datum[key].applyReadyExternals(alteration.expressionAlterations);
                if (exAlt instanceof ExternalExpression) {
                    datum[key] = exAlt.external;
                }
                else if (exAlt instanceof LiteralExpression) {
                    datum[key] = exAlt.getLiteralValue();
                }
                else {
                    datum[key] = exAlt;
                }
            }
            else {
                throw new Error('fell through');
            }
        }
        for (var _a = 0, data_8 = data; _a < data_8.length; _a++) {
            var datum = data_8[_a];
            for (var key in datum) {
                var v = datum[key];
                if (v instanceof Expression) {
                    var simp = v.resolve(datum).simplify();
                    datum[key] = simp instanceof ExternalExpression ? simp.external : simp;
                }
            }
        }
        var value = this.valueOf();
        value.data = data;
        return new Dataset(value);
    };
    Dataset.prototype.join = function (other) {
        if (!other)
            return this;
        var thisKey = this.keys[0];
        if (!thisKey)
            throw new Error('join lhs must have a key (be a product of a split)');
        var otherKey = other.keys[0];
        if (!otherKey)
            throw new Error('join rhs must have a key (be a product of a split)');
        var thisData = this.data;
        var otherData = other.data;
        var k;
        var mapping = Object.create(null);
        for (var i = 0; i < thisData.length; i++) {
            var datum = thisData[i];
            k = String(thisKey ? datum[thisKey] : i);
            mapping[k] = [datum];
        }
        for (var i = 0; i < otherData.length; i++) {
            var datum = otherData[i];
            k = String(otherKey ? datum[otherKey] : i);
            if (!mapping[k])
                mapping[k] = [];
            mapping[k].push(datum);
        }
        var newData = [];
        for (var j in mapping) {
            var datums = mapping[j];
            if (datums.length === 1) {
                newData.push(datums[0]);
            }
            else {
                newData.push(joinDatums(datums[0], datums[1]));
            }
        }
        return new Dataset({ data: newData });
    };
    Dataset.prototype.findDatumByAttribute = function (attribute, value) {
        return SimpleArray.find(this.data, function (d) { return generalEqual(d[attribute], value); });
    };
    Dataset.prototype.getNestedColumns = function () {
        var nestedColumns = [];
        var attributes = this.attributes;
        var subDatasetAdded = false;
        for (var _i = 0, attributes_3 = attributes; _i < attributes_3.length; _i++) {
            var attribute = attributes_3[_i];
            var column = {
                name: attribute.name,
                type: attribute.type
            };
            if (attribute.type === 'DATASET') {
                var subDataset = this.data[0][attribute.name];
                if (!subDatasetAdded && subDataset instanceof Dataset) {
                    subDatasetAdded = true;
                    column.columns = subDataset.getNestedColumns();
                    nestedColumns.push(column);
                }
            }
            else {
                nestedColumns.push(column);
            }
        }
        return nestedColumns;
    };
    Dataset.prototype.getColumns = function (options) {
        if (options === void 0) { options = {}; }
        var prefixColumns = options.prefixColumns;
        return flattenColumns(this.getNestedColumns(), prefixColumns);
    };
    Dataset.prototype._flattenHelper = function (nestedColumns, prefix, order, nestingName, parentName, nesting, context, flat) {
        var nestedColumnsLength = nestedColumns.length;
        if (!nestedColumnsLength)
            return;
        var data = this.data;
        var datasetColumn = nestedColumns.filter(function (nestedColumn) { return nestedColumn.type === 'DATASET'; })[0];
        for (var _i = 0, data_9 = data; _i < data_9.length; _i++) {
            var datum = data_9[_i];
            var flatDatum = context ? copy(context) : {};
            if (nestingName)
                flatDatum[nestingName] = nesting;
            if (parentName)
                flatDatum[parentName] = context;
            for (var _a = 0, nestedColumns_1 = nestedColumns; _a < nestedColumns_1.length; _a++) {
                var flattenedColumn = nestedColumns_1[_a];
                if (flattenedColumn.type === 'DATASET')
                    continue;
                var flatName = (prefix !== null ? prefix : '') + flattenedColumn.name;
                flatDatum[flatName] = datum[flattenedColumn.name];
            }
            if (datasetColumn) {
                var nextPrefix = null;
                if (prefix !== null)
                    nextPrefix = prefix + datasetColumn.name + '.';
                if (order === 'preorder')
                    flat.push(flatDatum);
                datum[datasetColumn.name]._flattenHelper(datasetColumn.columns, nextPrefix, order, nestingName, parentName, nesting + 1, flatDatum, flat);
                if (order === 'postorder')
                    flat.push(flatDatum);
            }
            if (!datasetColumn)
                flat.push(flatDatum);
        }
    };
    Dataset.prototype.flatten = function (options) {
        if (options === void 0) { options = {}; }
        var prefixColumns = options.prefixColumns;
        var order = options.order;
        var nestingName = options.nestingName;
        var parentName = options.parentName;
        var nestedColumns = this.getNestedColumns();
        var flatData = [];
        if (nestedColumns.length) {
            this._flattenHelper(nestedColumns, (prefixColumns ? '' : null), order, nestingName, parentName, 0, null, flatData);
        }
        return flatData;
    };
    Dataset.prototype.toTabular = function (tabulatorOptions) {
        var formatter = tabulatorOptions.formatter || {};
        var finalizer = tabulatorOptions.finalizer;
        var data = this.flatten(tabulatorOptions);
        var columns = this.getColumns(tabulatorOptions);
        var lines = [];
        lines.push(columns.map(function (c) { return c.name; }).join(tabulatorOptions.separator || ','));
        var _loop_2 = function(i) {
            var datum = data[i];
            lines.push(columns.map(function (c) {
                var value = datum[c.name];
                var formatted = String((formatter[c.type] || defaultFormatter[c.type])(value));
                var finalized = formatted && finalizer ? finalizer(formatted) : formatted;
                return finalized;
            }).join(tabulatorOptions.separator || ','));
        };
        for (var i = 0; i < data.length; i++) {
            _loop_2(i);
        }
        var lineBreak = tabulatorOptions.lineBreak || '\n';
        return lines.join(lineBreak) + (tabulatorOptions.finalLineBreak === 'include' && lines.length > 0 ? lineBreak : '');
    };
    Dataset.prototype.toCSV = function (tabulatorOptions) {
        if (tabulatorOptions === void 0) { tabulatorOptions = {}; }
        tabulatorOptions.finalizer = escapeFnCSV;
        tabulatorOptions.separator = tabulatorOptions.separator || ',';
        tabulatorOptions.lineBreak = tabulatorOptions.lineBreak || '\r\n';
        tabulatorOptions.finalLineBreak = tabulatorOptions.finalLineBreak || 'suppress';
        return this.toTabular(tabulatorOptions);
    };
    Dataset.prototype.toTSV = function (tabulatorOptions) {
        if (tabulatorOptions === void 0) { tabulatorOptions = {}; }
        tabulatorOptions.finalizer = escapeFnTSV;
        tabulatorOptions.separator = tabulatorOptions.separator || '\t';
        tabulatorOptions.lineBreak = tabulatorOptions.lineBreak || '\r\n';
        tabulatorOptions.finalLineBreak = tabulatorOptions.finalLineBreak || 'suppress';
        return this.toTabular(tabulatorOptions);
    };
    Dataset.type = 'DATASET';
    return Dataset;
}());
check = Dataset;
