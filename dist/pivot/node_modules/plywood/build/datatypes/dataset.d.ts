import { Instance } from 'immutable-class';
import { PlyType, DatasetFullType } from '../types';
import { Attributes, AttributeJSs } from './attributeInfo';
import { NumberRange } from './numberRange';
import { Set } from './set';
import { StringRange } from './stringRange';
import { TimeRange } from './timeRange';
import { Expression, ExpressionExternalAlteration, Direction } from '../expressions/index';
import { External } from '../external/baseExternal';
export interface ComputeFn {
    (d: Datum): any;
}
export interface DirectionFn {
    (a: any, b: any): number;
}
export declare type PlywoodValue = null | boolean | number | string | Date | NumberRange | TimeRange | StringRange | Set | Dataset | External;
export interface PseudoDatum {
    [attribute: string]: any;
}
export interface Datum {
    [attribute: string]: PlywoodValue | Expression;
}
export interface DatasetExternalAlteration {
    index: number;
    key: string;
    external?: External;
    terminal?: boolean;
    result?: any;
    datasetAlterations?: DatasetExternalAlterations;
    expressionAlterations?: ExpressionExternalAlteration;
}
export declare type DatasetExternalAlterations = DatasetExternalAlteration[];
export interface AlterationFiller {
    (external: External, terminal: boolean): any;
}
export declare function fillExpressionExternalAlteration(alteration: ExpressionExternalAlteration, filler: AlterationFiller): void;
export declare function fillDatasetExternalAlterations(alterations: DatasetExternalAlterations, filler: AlterationFiller): void;
export interface Column {
    name: string;
    type: string;
    columns?: Column[];
}
export interface Formatter extends Lookup<Function | undefined> {
    'NULL'?: (v: any) => string;
    'TIME'?: (v: Date) => string;
    'TIME_RANGE'?: (v: TimeRange) => string;
    'SET/TIME'?: (v: Set) => string;
    'SET/TIME_RANGE'?: (v: Set) => string;
    'STRING'?: (v: string) => string;
    'SET/STRING'?: (v: Set) => string;
    'BOOLEAN'?: (v: boolean) => string;
    'NUMBER'?: (v: number) => string;
    'NUMBER_RANGE'?: (v: NumberRange) => string;
    'SET/NUMBER'?: (v: Set) => string;
    'SET/NUMBER_RANGE'?: (v: Set) => string;
    'DATASET'?: (v: Dataset) => string;
}
export interface FlattenOptions {
    prefixColumns?: boolean;
    order?: string;
    nestingName?: string;
    parentName?: string;
}
export declare type FinalLineBreak = 'include' | 'suppress';
export interface TabulatorOptions extends FlattenOptions {
    separator?: string;
    lineBreak?: string;
    finalLineBreak?: FinalLineBreak;
    formatter?: Formatter;
    finalizer?: (v: string) => string;
}
export interface DatasetValue {
    attributeOverrides?: Attributes;
    attributes?: Attributes;
    keys?: string[];
    data?: Datum[];
    suppress?: boolean;
}
export interface DatasetJS {
    attributes?: AttributeJSs;
    keys?: string[];
    data?: Datum[];
}
export declare class Dataset implements Instance<DatasetValue, any> {
    static type: string;
    static isDataset(candidate: any): candidate is Dataset;
    static datumFromJS(js: Datum): Datum;
    static datumToJS(datum: Datum): Datum;
    static getAttributesFromData(data: Datum[]): Attributes;
    static parseJSON(text: string): any[];
    static fromJS(parameters: any): Dataset;
    suppress: boolean;
    attributes: Attributes;
    keys: string[];
    data: Datum[];
    constructor(parameters: DatasetValue);
    valueOf(): DatasetValue;
    toJS(): any;
    toString(): string;
    toJSON(): any;
    equals(other: Dataset): boolean;
    hide(): Dataset;
    basis(): boolean;
    hasExternal(): boolean;
    getFullType(): DatasetFullType;
    select(attrs: string[]): Dataset;
    apply(name: string, ex: Expression): Dataset;
    applyFn(name: string, exFn: ComputeFn, type: PlyType): Dataset;
    filter(ex: Expression): Dataset;
    filterFn(exFn: ComputeFn): Dataset;
    sort(ex: Expression, direction: Direction): Dataset;
    sortFn(exFn: ComputeFn, direction: Direction): Dataset;
    limit(limit: number): Dataset;
    count(): int;
    sum(ex: Expression): number;
    sumFn(exFn: ComputeFn): number;
    average(ex: Expression): number;
    averageFn(exFn: ComputeFn): number;
    min(ex: Expression): number;
    minFn(exFn: ComputeFn): number;
    max(ex: Expression): number;
    maxFn(exFn: ComputeFn): number;
    countDistinct(ex: Expression): number;
    countDistinctFn(exFn: ComputeFn): number;
    quantile(ex: Expression, quantile: number): number;
    quantileFn(exFn: ComputeFn, quantile: number): number;
    collect(ex: Expression): Set;
    collectFn(exFn: ComputeFn): Set;
    split(splits: Lookup<Expression>, datasetName: string): Dataset;
    splitFn(splitFns: Lookup<ComputeFn>, datasetName: string): Dataset;
    introspect(): void;
    getReadyExternals(): DatasetExternalAlterations;
    applyReadyExternals(alterations: DatasetExternalAlterations): Dataset;
    join(other: Dataset): Dataset;
    findDatumByAttribute(attribute: string, value: any): Datum;
    getNestedColumns(): Column[];
    getColumns(options?: FlattenOptions): Column[];
    private _flattenHelper(nestedColumns, prefix, order, nestingName, parentName, nesting, context, flat);
    flatten(options?: FlattenOptions): PseudoDatum[];
    toTabular(tabulatorOptions: TabulatorOptions): string;
    toCSV(tabulatorOptions?: TabulatorOptions): string;
    toTSV(tabulatorOptions?: TabulatorOptions): string;
}
