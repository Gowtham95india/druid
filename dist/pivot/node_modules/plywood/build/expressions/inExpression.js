var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { r, Expression, ChainableUnaryExpression } from './baseExpression';
import { LiteralExpression } from './literalExpression';
import { IndexOfExpression } from './indexOfExpression';
import { NumberRange } from '../datatypes/numberRange';
import { Set } from '../datatypes/set';
import { isSetType, wrapSetType } from '../datatypes/common';
export var InExpression = (function (_super) {
    __extends(InExpression, _super);
    function InExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("in");
        var operandType = this.operand.type;
        var expression = this.expression;
        if (operandType) {
            if (!((!isSetType(operandType) && expression.canHaveType('SET')) ||
                (operandType === 'NUMBER' && expression.canHaveType('NUMBER_RANGE')) ||
                (operandType === 'STRING' && expression.canHaveType('STRING_RANGE')) ||
                (operandType === 'TIME' && expression.canHaveType('TIME_RANGE')))) {
                throw new TypeError("in expression " + this + " has a bad type combination " + operandType + " IN " + (expression.type || '*'));
            }
        }
        else {
            if (!(expression.canHaveType('NUMBER_RANGE') || expression.canHaveType('STRING_RANGE') || expression.canHaveType('TIME_RANGE') || expression.canHaveType('SET'))) {
                throw new TypeError("in expression has invalid expression type " + expression.type);
            }
        }
        this.type = 'BOOLEAN';
    }
    InExpression.fromJS = function (parameters) {
        return new InExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    InExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        if (!expressionValue)
            return null;
        return expressionValue.contains(operandValue);
    };
    InExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        var expression = this.expression;
        if (expression instanceof LiteralExpression) {
            switch (expression.type) {
                case 'NUMBER_RANGE':
                case 'STRING_RANGE':
                case 'TIME_RANGE':
                    var range = expression.value;
                    var r0 = range.start;
                    var r1 = range.end;
                    var bounds = range.bounds;
                    var cmpStrings = [];
                    if (r0 != null) {
                        cmpStrings.push(JSON.stringify(r0) + " " + (bounds[0] === '(' ? '<' : '<=') + " _");
                    }
                    if (r1 != null) {
                        cmpStrings.push("_ " + (bounds[1] === ')' ? '<' : '<=') + " " + JSON.stringify(r1));
                    }
                    return "(_=" + operandJS + ", " + cmpStrings.join(' && ') + ")";
                case 'SET/STRING':
                    var valueSet = expression.value;
                    return JSON.stringify(valueSet.elements) + ".indexOf(" + operandJS + ")>-1";
                default:
                    throw new Error("can not convert " + this + " to JS function, unsupported type " + expression.type);
            }
        }
        throw new Error("can not convert " + this + " to JS function");
    };
    InExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        var expression = this.expression;
        var expressionType = expression.type;
        switch (expressionType) {
            case 'NUMBER_RANGE':
            case 'TIME_RANGE':
                if (expression instanceof LiteralExpression) {
                    var range = expression.value;
                    return dialect.inExpression(operandSQL, dialect.numberOrTimeToSQL(range.start), dialect.numberOrTimeToSQL(range.end), range.bounds);
                }
                throw new Error("can not convert action to SQL " + this);
            case 'STRING_RANGE':
                if (expression instanceof LiteralExpression) {
                    var stringRange = expression.value;
                    return dialect.inExpression(operandSQL, dialect.escapeLiteral(stringRange.start), dialect.escapeLiteral(stringRange.end), stringRange.bounds);
                }
                throw new Error("can not convert action to SQL " + this);
            case 'SET/STRING':
            case 'SET/NUMBER':
                return operandSQL + " IN " + expressionSQL;
            case 'SET/NUMBER_RANGE':
            case 'SET/TIME_RANGE':
                if (expression instanceof LiteralExpression) {
                    var setOfRange = expression.value;
                    return setOfRange.elements.map(function (range) {
                        return dialect.inExpression(operandSQL, dialect.numberOrTimeToSQL(range.start), dialect.numberOrTimeToSQL(range.end), range.bounds);
                    }).join(' OR ');
                }
                throw new Error("can not convert action to SQL " + this);
            default:
                throw new Error("can not convert action to SQL " + this);
        }
    };
    InExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        var literalValue = expression.getLiteralValue();
        if (literalValue instanceof Set) {
            if (literalValue.empty())
                return Expression.FALSE;
            if (literalValue && !literalValue.isNullSet()) {
                if (literalValue.size() === 1) {
                    if (wrapSetType(operand.type) === expression.type) {
                        return operand.is(r(literalValue.elements[0]));
                    }
                    else if (wrapSetType((operand.type + '_RANGE')) === expression.type) {
                        return operand.in(r(literalValue.elements[0]));
                    }
                    else {
                        return this;
                    }
                }
                var unifiedSetValue = literalValue.unifyElements();
                if (!literalValue.equals(unifiedSetValue)) {
                    return operand.in(r(unifiedSetValue));
                }
            }
        }
        if (operand instanceof IndexOfExpression && literalValue instanceof NumberRange) {
            var x = operand.operand, y = operand.expression;
            var start = literalValue.start, end = literalValue.end, bounds = literalValue.bounds;
            if ((start < 0 && end === null) || (start === 0 && end === null && bounds[0] === '[')) {
                return x.contains(y);
            }
        }
        return this;
    };
    InExpression.op = "In";
    return InExpression;
}(ChainableUnaryExpression));
Expression.register(InExpression);
