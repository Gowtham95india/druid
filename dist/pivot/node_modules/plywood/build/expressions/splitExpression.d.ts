import { ExpressionJS, ExpressionValue, Expression, ChainableExpression, Splits, SubstitutionFn, Indexer, ExpressionTypeContext } from './baseExpression';
import { DatasetFullType } from '../types';
import { Aggregate } from './mixins/aggregate';
import { SQLDialect } from '../dialect/baseDialect';
import { Datum, PlywoodValue } from '../datatypes/dataset';
export declare class SplitExpression extends ChainableExpression implements Aggregate {
    static op: string;
    static fromJS(parameters: ExpressionJS): SplitExpression;
    keys: string[];
    splits: Splits;
    dataName: string;
    constructor(parameters: ExpressionValue);
    valueOf(): ExpressionValue;
    toJS(): ExpressionJS;
    equals(other: SplitExpression): boolean;
    changeSplits(splits: Splits): SplitExpression;
    numSplits(): number;
    isMultiSplit(): boolean;
    protected _toStringParameters(indent?: int): string[];
    updateTypeContext(typeContext: DatasetFullType): DatasetFullType;
    firstSplitName(): string;
    firstSplitExpression(): Expression;
    getArgumentExpressions(): Expression[];
    mapSplits<T>(fn: (name: string, expression?: Expression) => T): T[];
    mapSplitExpressions<T>(fn: (expression: Expression, name?: string) => T): Lookup<T>;
    calc(datum: Datum): PlywoodValue;
    getSQL(dialect: SQLDialect): string;
    getSelectSQL(dialect: SQLDialect): string[];
    getShortGroupBySQL(): string;
    fullyDefined(): boolean;
    simplify(): Expression;
    _substituteHelper(substitutionFn: SubstitutionFn, indexer: Indexer, depth: int, nestDiff: int, typeContext: DatasetFullType): ExpressionTypeContext;
    transformExpressions(fn: (expression: Expression, name?: string) => Expression): SplitExpression;
    filterFromDatum(datum: Datum): Expression;
    hasKey(key: string): boolean;
    isLinear(): boolean;
    maxBucketNumber(): number;
}
