var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { Expression, ChainableUnaryExpression } from './baseExpression';
import { Set } from '../datatypes/set';
var IS_OR_IN = {
    'is': true,
    'in': true
};
export var OrExpression = (function (_super) {
    __extends(OrExpression, _super);
    function OrExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureOp("or");
        this._checkOperandTypes('BOOLEAN');
        this._checkExpressionTypes('BOOLEAN');
        this.type = 'BOOLEAN';
    }
    OrExpression.fromJS = function (parameters) {
        return new OrExpression(ChainableUnaryExpression.jsToValue(parameters));
    };
    OrExpression.merge = function (ex1, ex2) {
        if (ex1.equals(ex2))
            return ex1;
        if (!IS_OR_IN[ex1.op] || !IS_OR_IN[ex2.op])
            return null;
        var _a = ex1, lhs1 = _a.operand, rhs1 = _a.expression;
        var _b = ex2, lhs2 = _b.operand, rhs2 = _b.expression;
        if (!lhs1.equals(lhs2) || !rhs1.isOp('literal') || !rhs2.isOp('literal'))
            return null;
        var union = Set.generalUnion(rhs1.getLiteralValue(), rhs2.getLiteralValue());
        if (union === null)
            return null;
        return Expression.inOrIs(lhs1, union);
    };
    OrExpression.prototype._calcChainableUnaryHelper = function (operandValue, expressionValue) {
        return operandValue || expressionValue;
    };
    OrExpression.prototype._getJSChainableUnaryHelper = function (operandJS, expressionJS) {
        return "(" + operandJS + "||" + expressionJS + ")";
    };
    OrExpression.prototype._getSQLChainableUnaryHelper = function (dialect, operandSQL, expressionSQL) {
        return "(" + operandSQL + " OR " + expressionSQL + ")";
    };
    OrExpression.prototype.isCommutative = function () {
        return true;
    };
    OrExpression.prototype.isAssociative = function () {
        return true;
    };
    OrExpression.prototype.specialSimplify = function () {
        var _a = this, operand = _a.operand, expression = _a.expression;
        if (expression.equals(Expression.TRUE))
            return Expression.TRUE;
        if (expression.equals(Expression.FALSE))
            return operand;
        if (operand instanceof OrExpression) {
            var orExpressions = operand.getExpressionList();
            for (var i = 0; i < orExpressions.length; i++) {
                var orExpression = orExpressions[i];
                var mergedExpression = OrExpression.merge(orExpression, expression);
                if (mergedExpression) {
                    orExpressions[i] = mergedExpression;
                    return Expression.or(orExpressions).simplify();
                }
            }
        }
        else {
            var mergedExpression = OrExpression.merge(operand, expression);
            if (mergedExpression)
                return mergedExpression;
        }
        return this;
    };
    OrExpression.op = "Or";
    return OrExpression;
}(ChainableUnaryExpression));
Expression.register(OrExpression);
