var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { immutableEqual } from 'immutable-class';
import { Timezone, Duration } from 'chronoshift';
import { Expression, ChainableExpression } from './baseExpression';
import { HasTimezone } from './mixins/hasTimezone';
import { TimeRange } from '../datatypes/timeRange';
export var TimeRangeExpression = (function (_super) {
    __extends(TimeRangeExpression, _super);
    function TimeRangeExpression(parameters) {
        _super.call(this, parameters, dummyObject);
        this.duration = parameters.duration;
        this.step = parameters.step || TimeRangeExpression.DEFAULT_STEP;
        this.timezone = parameters.timezone;
        this._ensureOp("timeRange");
        this._checkOperandTypes('TIME');
        if (!Duration.isDuration(this.duration)) {
            throw new Error("`duration` must be a Duration");
        }
        this.type = 'TIME_RANGE';
    }
    TimeRangeExpression.fromJS = function (parameters) {
        var value = ChainableExpression.jsToValue(parameters);
        value.duration = Duration.fromJS(parameters.duration);
        value.step = parameters.step;
        if (parameters.timezone)
            value.timezone = Timezone.fromJS(parameters.timezone);
        return new TimeRangeExpression(value);
    };
    TimeRangeExpression.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.duration = this.duration;
        value.step = this.step;
        if (this.timezone)
            value.timezone = this.timezone;
        return value;
    };
    TimeRangeExpression.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        js.duration = this.duration.toJS();
        js.step = this.step;
        if (this.timezone)
            js.timezone = this.timezone.toJS();
        return js;
    };
    TimeRangeExpression.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.duration.equals(other.duration) &&
            this.step === other.step &&
            immutableEqual(this.timezone, other.timezone);
    };
    TimeRangeExpression.prototype._toStringParameters = function (indent) {
        var ret = [this.duration.toString(), this.step.toString()];
        if (this.timezone)
            ret.push(this.timezone.toString());
        return ret;
    };
    TimeRangeExpression.prototype._calcChainableHelper = function (operandValue) {
        var duration = this.duration;
        var step = this.step;
        var timezone = this.getTimezone();
        if (operandValue === null)
            return null;
        var other = duration.shift(operandValue, timezone, step);
        if (step > 0) {
            return new TimeRange({ start: operandValue, end: other });
        }
        else {
            return new TimeRange({ start: other, end: operandValue });
        }
    };
    TimeRangeExpression.prototype._getJSChainableHelper = function (operandJS) {
        throw new Error("implement me");
    };
    TimeRangeExpression.prototype._getSQLChainableHelper = function (dialect, operandSQL) {
        throw new Error("implement me");
    };
    TimeRangeExpression.DEFAULT_STEP = 1;
    TimeRangeExpression.op = "TimeRange";
    return TimeRangeExpression;
}(ChainableExpression));
Expression.applyMixins(TimeRangeExpression, [HasTimezone]);
Expression.register(TimeRangeExpression);
