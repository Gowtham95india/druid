import * as Q from 'q';
import * as Druid from 'druid.d.ts';
import { ExtendableError } from '../helper/utils';
import { Expression, ApplyExpression, FilterExpression, LimitExpression, SortExpression, SplitExpression } from '../expressions/index';
import { AttributeInfo, Attributes, Dataset, Datum, PlywoodValue } from '../datatypes/index';
import { External, ExternalJS, ExternalValue, Inflater, NextFn, PostProcess, QueryAndPostProcess } from './baseExternal';
import { CustomDruidAggregations, CustomDruidTransforms } from './utils/druidTypes';
export declare class InvalidResultError extends ExtendableError {
    result: any;
    constructor(message: string, result: any);
}
export interface Normalizer {
    (result: any): Datum[];
}
export interface GranularityInflater {
    granularity: Druid.Granularity;
    inflater: Inflater;
}
export interface DimensionInflater {
    dimension: Druid.DimensionSpec;
    inflater?: Inflater;
}
export interface DimensionInflaterHaving extends DimensionInflater {
    having?: Expression;
}
export interface DruidSplit {
    queryType: string;
    timestampLabel?: string;
    granularity: Druid.Granularity | string;
    dimension?: Druid.DimensionSpec;
    dimensions?: Druid.DimensionSpec[];
    leftoverHavingFilter?: Expression;
    postProcess: PostProcess;
}
export interface IntrospectPostProcess {
    (result: any): Attributes;
}
export declare class DruidExternal extends External {
    static engine: string;
    static type: string;
    static DUMMY_NAME: string;
    static TIME_ATTRIBUTE: string;
    static VALID_INTROSPECTION_STRATEGIES: string[];
    static DEFAULT_INTROSPECTION_STRATEGY: string;
    static SELECT_INIT_LIMIT: number;
    static SELECT_MAX_LIMIT: number;
    static fromJS(parameters: ExternalJS, requester: Requester.PlywoodRequester<any>): DruidExternal;
    static getSourceList(requester: Requester.PlywoodRequester<any>): Q.Promise<string[]>;
    static getVersion(requester: Requester.PlywoodRequester<any>): Q.Promise<string>;
    static cleanDatumInPlace(datum: Datum): void;
    static correctTimeBoundaryResult(result: Druid.TimeBoundaryResults): boolean;
    static correctTimeseriesResult(result: Druid.TimeseriesResults): boolean;
    static correctTopNResult(result: Druid.DruidResults): boolean;
    static correctGroupByResult(result: Druid.GroupByResults): boolean;
    static correctSelectResult(result: Druid.SelectResults): boolean;
    static correctStatusResult(result: Druid.StatusResult): boolean;
    static timeBoundaryPostProcessFactory(applies?: ApplyExpression[]): PostProcess;
    static valuePostProcess(res: Druid.TimeseriesResults): PlywoodValue;
    static totalPostProcessFactory(applies: ApplyExpression[]): PostProcess;
    static timeseriesNormalizerFactory(timestampLabel?: string): Normalizer;
    static topNNormalizer(res: Druid.DruidResults): Datum[];
    static groupByNormalizerFactory(timestampLabel?: string): Normalizer;
    static selectNormalizerFactory(timestampLabel: string): Normalizer;
    static postProcessFactory(normalizer: Normalizer, inflaters: Inflater[], attributes: Attributes): (res: any) => Dataset;
    static selectNextFactory(limit: number, descending: boolean): NextFn<Druid.Query, Druid.SelectResults>;
    static generateMaker(aggregation: Druid.Aggregation): Expression;
    static segmentMetadataPostProcessFactory(timeAttribute: string): IntrospectPostProcess;
    static introspectPostProcessFactory(timeAttribute: string): IntrospectPostProcess;
    static movePagingIdentifiers(pagingIdentifiers: Druid.PagingIdentifiers, increment: number): Druid.PagingIdentifiers;
    timeAttribute: string;
    customAggregations: CustomDruidAggregations;
    customTransforms: CustomDruidTransforms;
    allowEternity: boolean;
    allowSelectQueries: boolean;
    introspectionStrategy: string;
    exactResultsOnly: boolean;
    context: Lookup<any>;
    constructor(parameters: ExternalValue);
    valueOf(): ExternalValue;
    toJS(): ExternalJS;
    equals(other: DruidExternal): boolean;
    canHandleTotal(): boolean;
    canHandleFilter(filter: FilterExpression): boolean;
    canHandleSplit(split: SplitExpression): boolean;
    canHandleSplitExpression(ex: Expression): boolean;
    canHandleApply(apply: ApplyExpression): boolean;
    canHandleSort(sort: SortExpression): boolean;
    canHandleLimit(limit: LimitExpression): boolean;
    canHandleHavingFilter(havingFilter: FilterExpression): boolean;
    isTimeseries(): boolean;
    getDruidDataSource(): Druid.DataSource;
    getDimensionNameForAttributeInfo(attributeInfo: AttributeInfo): string;
    isTimeRef(ex: Expression): boolean;
    splitExpressionToGranularityInflater(splitExpression: Expression, label: string): GranularityInflater;
    expressionToDimensionInflater(expression: Expression, label: string): DimensionInflater;
    expressionToDimensionInflaterHaving(expression: Expression, label: string, havingFilter: Expression): DimensionInflaterHaving;
    splitToDruid(split: SplitExpression): DruidSplit;
    isMinMaxTimeExpression(applyExpression: Expression): boolean;
    getTimeBoundaryQueryAndPostProcess(): QueryAndPostProcess<Druid.Query>;
    getQueryAndPostProcess(): QueryAndPostProcess<Druid.Query>;
    protected getIntrospectAttributesWithSegmentMetadata(): Q.Promise<Attributes>;
    protected getIntrospectAttributesWithGet(): Q.Promise<Attributes>;
    protected getIntrospectAttributes(): Q.Promise<Attributes>;
}
