import { hasOwnProperty } from '../../helper/utils';
import { NamedArray } from 'immutable-class';
import { $, LiteralExpression, RefExpression, ChainableUnaryExpression, AbsoluteExpression, AddExpression, CastExpression, CountExpression, CountDistinctExpression, CustomAggregateExpression, DivideExpression, FallbackExpression, FilterExpression, IndexOfExpression, MaxExpression, MinExpression, MultiplyExpression, PowerExpression, QuantileExpression, SubtractExpression, SumExpression, TransformCaseExpression } from '../../expressions/index';
import { UniqueAttributeInfo, ThetaAttributeInfo } from '../../datatypes/index';
import { External } from '../baseExternal';
import { DruidFilterBuilder } from './druidFilterBuilder';
export var DruidAggregationBuilder = (function () {
    function DruidAggregationBuilder(options) {
        this.version = options.version;
        this.rawAttributes = options.rawAttributes;
        this.timeAttribute = options.timeAttribute;
        this.derivedAttributes = options.derivedAttributes;
        this.customAggregations = options.customAggregations;
        this.customTransforms = options.customTransforms;
        this.rollup = options.rollup;
        this.exactResultsOnly = options.exactResultsOnly;
        this.allowEternity = options.allowEternity;
    }
    DruidAggregationBuilder.prototype.makeAggregationsAndPostAggregations = function (applies) {
        var _this = this;
        var _a = External.segregationAggregateApplies(applies.map(function (apply) {
            var expression = apply.expression;
            expression = _this.switchToRollupCount(_this.inlineDerivedAttributesInAggregate(expression).decomposeAverage()).distribute();
            return apply.changeExpression(expression);
        })), aggregateApplies = _a.aggregateApplies, postAggregateApplies = _a.postAggregateApplies;
        var aggregations = [];
        var postAggregations = [];
        for (var _i = 0, aggregateApplies_1 = aggregateApplies; _i < aggregateApplies_1.length; _i++) {
            var aggregateApply = aggregateApplies_1[_i];
            this.applyToAggregation(aggregateApply, aggregations, postAggregations);
        }
        for (var _b = 0, postAggregateApplies_1 = postAggregateApplies; _b < postAggregateApplies_1.length; _b++) {
            var postAggregateApply = postAggregateApplies_1[_b];
            this.applyToPostAggregation(postAggregateApply, aggregations, postAggregations);
        }
        return {
            aggregations: aggregations,
            postAggregations: postAggregations
        };
    };
    DruidAggregationBuilder.prototype.applyToAggregation = function (action, aggregations, postAggregations) {
        var name = action.name, expression = action.expression;
        aggregations.push(this.expressionToAggregation(name, expression, postAggregations));
    };
    DruidAggregationBuilder.prototype.applyToPostAggregation = function (apply, aggregations, postAggregations) {
        var postAgg = this.expressionToPostAggregation(apply.expression, aggregations, postAggregations);
        postAgg.name = apply.name;
        postAggregations.push(postAgg);
    };
    DruidAggregationBuilder.prototype.filterAggregateIfNeeded = function (datasetExpression, aggregator) {
        if (datasetExpression instanceof FilterExpression) {
            return {
                type: "filtered",
                name: aggregator.name,
                filter: new DruidFilterBuilder(this).timelessFilterToFilter(datasetExpression.expression, true),
                aggregator: aggregator
            };
        }
        else if (datasetExpression instanceof RefExpression) {
            return aggregator;
        }
        else {
            throw new Error("could not construct aggregate on " + datasetExpression);
        }
    };
    DruidAggregationBuilder.prototype.expressionToAggregation = function (name, expression, postAggregations) {
        if (expression instanceof CountExpression) {
            return this.countToAggregation(name, expression);
        }
        else if (expression instanceof SumExpression || expression instanceof MinExpression || expression instanceof MaxExpression) {
            return this.sumMinMaxToAggregation(name, expression);
        }
        else if (expression instanceof CountDistinctExpression) {
            return this.countDistinctToAggregation(name, expression, postAggregations);
        }
        else if (expression instanceof QuantileExpression) {
            return this.quantileToAggregation(name, expression, postAggregations);
        }
        else if (expression instanceof CustomAggregateExpression) {
            return this.customAggregateToAggregation(name, expression);
        }
        else {
            throw new Error("unsupported aggregate action " + expression + " (as " + name + ")");
        }
    };
    DruidAggregationBuilder.prototype.countToAggregation = function (name, expression) {
        return this.filterAggregateIfNeeded(expression.operand, {
            name: name,
            type: 'count'
        });
    };
    DruidAggregationBuilder.prototype.sumMinMaxToAggregation = function (name, expression) {
        var aggregation = {
            name: name,
            type: DruidAggregationBuilder.AGGREGATE_TO_DRUID[expression.op]
        };
        var aggregateExpression = expression.expression;
        if (aggregateExpression instanceof RefExpression) {
            var refName = aggregateExpression.name;
            var attributeInfo = this.getAttributesInfo(refName);
            if (attributeInfo.unsplitable) {
                aggregation.fieldName = refName;
            }
            else {
                aggregation = this.makeJavaScriptAggregation(name, expression);
            }
        }
        else {
            aggregation = this.makeJavaScriptAggregation(name, expression);
        }
        return this.filterAggregateIfNeeded(expression.operand, aggregation);
    };
    DruidAggregationBuilder.prototype.countDistinctToAggregation = function (name, expression, postAggregations) {
        if (this.exactResultsOnly) {
            throw new Error("approximate query not allowed");
        }
        var attribute = expression.expression;
        var attributeName;
        if (attribute instanceof RefExpression) {
            attributeName = attribute.name;
        }
        else {
            throw new Error("can not compute countDistinct on derived attribute: " + attribute);
        }
        var attributeInfo = this.getAttributesInfo(attributeName);
        var aggregation;
        if (attributeInfo instanceof UniqueAttributeInfo) {
            aggregation = {
                name: name,
                type: "hyperUnique",
                fieldName: attributeName
            };
        }
        else if (attributeInfo instanceof ThetaAttributeInfo) {
            var tempName = '!Theta_' + name;
            postAggregations.push({
                type: "thetaSketchEstimate",
                name: name,
                field: { type: 'fieldAccess', fieldName: tempName }
            });
            aggregation = {
                name: tempName,
                type: "thetaSketch",
                fieldName: attributeName
            };
        }
        else {
            aggregation = {
                name: name,
                type: "cardinality",
                fieldNames: [attributeName]
            };
        }
        return this.filterAggregateIfNeeded(expression.operand, aggregation);
    };
    DruidAggregationBuilder.prototype.customAggregateToAggregation = function (name, expression) {
        var customAggregationName = expression.custom;
        var customAggregation = this.customAggregations[customAggregationName];
        if (!customAggregation)
            throw new Error("could not find '" + customAggregationName + "'");
        var aggregationObj = customAggregation.aggregation;
        if (typeof aggregationObj.type !== 'string')
            throw new Error("must have type in custom aggregation '" + customAggregationName + "'");
        try {
            aggregationObj = JSON.parse(JSON.stringify(aggregationObj));
        }
        catch (e) {
            throw new Error("must have JSON custom aggregation '" + customAggregationName + "'");
        }
        aggregationObj.name = name;
        return aggregationObj;
    };
    DruidAggregationBuilder.prototype.quantileToAggregation = function (name, expression, postAggregations) {
        if (this.exactResultsOnly) {
            throw new Error("approximate query not allowed");
        }
        var attribute = expression.expression;
        var attributeName;
        if (attribute instanceof RefExpression) {
            attributeName = attribute.name;
        }
        else {
            throw new Error("can not compute countDistinct on derived attribute: " + attribute);
        }
        var histogramAggregationName = "!H_" + name;
        var aggregation = {
            name: histogramAggregationName,
            type: "approxHistogramFold",
            fieldName: attributeName
        };
        postAggregations.push({
            name: name,
            type: "quantile",
            fieldName: histogramAggregationName,
            probability: expression.value
        });
        return aggregation;
    };
    DruidAggregationBuilder.prototype.makeJavaScriptAggregation = function (name, aggregate) {
        if (aggregate instanceof ChainableUnaryExpression) {
            var aggregateType = aggregate.op;
            var aggregateExpression = aggregate.expression;
            var aggregateFunction = DruidAggregationBuilder.AGGREGATE_TO_FUNCTION[aggregateType];
            if (!aggregateFunction)
                throw new Error("Can not convert " + aggregateType + " to JS");
            var zero = DruidAggregationBuilder.AGGREGATE_TO_ZERO[aggregateType];
            var fieldNames = aggregateExpression.getFreeReferences();
            var simpleFieldNames = fieldNames.map(RefExpression.toJavaScriptSafeName);
            return {
                name: name,
                type: "javascript",
                fieldNames: fieldNames,
                fnAggregate: "function($$," + simpleFieldNames.join(',') + ") { return " + aggregateFunction('$$', aggregateExpression.getJS(null)) + "; }",
                fnCombine: "function(a,b) { return " + aggregateFunction('a', 'b') + "; }",
                fnReset: "function() { return " + zero + "; }"
            };
        }
        else {
            throw new Error("Can not convert " + aggregate + " to JS aggregate");
        }
    };
    DruidAggregationBuilder.prototype.getAccessTypeForAggregation = function (aggregationType) {
        if (aggregationType === 'hyperUnique' || aggregationType === 'cardinality')
            return 'hyperUniqueCardinality';
        var customAggregations = this.customAggregations;
        for (var customName in customAggregations) {
            if (!hasOwnProperty(customAggregations, customName))
                continue;
            var customAggregation = customAggregations[customName];
            if (customAggregation.aggregation.type === aggregationType) {
                return customAggregation.accessType || 'fieldAccess';
            }
        }
        return 'fieldAccess';
    };
    DruidAggregationBuilder.prototype.getAccessType = function (aggregations, aggregationName) {
        for (var _i = 0, aggregations_1 = aggregations; _i < aggregations_1.length; _i++) {
            var aggregation = aggregations_1[_i];
            if (aggregation.name === aggregationName) {
                var aggregationType = aggregation.type;
                if (aggregationType === 'filtered')
                    aggregationType = aggregation.aggregator.type;
                return this.getAccessTypeForAggregation(aggregationType);
            }
        }
        return 'fieldAccess';
    };
    DruidAggregationBuilder.prototype.expressionToPostAggregation = function (ex, aggregations, postAggregations) {
        var _this = this;
        if (ex instanceof RefExpression) {
            var refName = ex.name;
            return {
                type: this.getAccessType(aggregations, refName),
                fieldName: refName
            };
        }
        else if (ex instanceof LiteralExpression) {
            if (ex.type !== 'NUMBER')
                throw new Error("must be a NUMBER type");
            return {
                type: 'constant',
                value: ex.value
            };
        }
        else if (ex instanceof AbsoluteExpression ||
            ex instanceof PowerExpression ||
            ex instanceof FallbackExpression ||
            ex instanceof CastExpression ||
            ex instanceof IndexOfExpression ||
            ex instanceof TransformCaseExpression) {
            var fieldNameRefs = ex.getFreeReferences();
            var fieldNames = fieldNameRefs.map(function (fieldNameRef) {
                var accessType = _this.getAccessType(aggregations, fieldNameRef);
                if (accessType === 'fieldAccess')
                    return fieldNameRef;
                var fieldNameRefTemp = '!F_' + fieldNameRef;
                postAggregations.push({
                    name: fieldNameRefTemp,
                    type: accessType,
                    fieldName: fieldNameRef
                });
                return fieldNameRefTemp;
            });
            return {
                type: 'javascript',
                fieldNames: fieldNames,
                'function': "function(" + fieldNameRefs.map(RefExpression.toJavaScriptSafeName) + ") { return " + ex.getJS(null) + "; }"
            };
        }
        else if (ex instanceof AddExpression) {
            return {
                type: 'arithmetic',
                fn: '+',
                fields: ex.getExpressionList().map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
            };
        }
        else if (ex instanceof SubtractExpression) {
            return {
                type: 'arithmetic',
                fn: '-',
                fields: ex.getExpressionList().map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
            };
        }
        else if (ex instanceof MultiplyExpression) {
            return {
                type: 'arithmetic',
                fn: '*',
                fields: ex.getExpressionList().map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
            };
        }
        else if (ex instanceof DivideExpression) {
            return {
                type: 'arithmetic',
                fn: '/',
                fields: ex.getExpressionList().map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
            };
        }
        else {
            throw new Error("can not convert expression to post agg: " + ex);
        }
    };
    DruidAggregationBuilder.prototype.switchToRollupCount = function (expression) {
        var _this = this;
        if (!this.rollup)
            return expression;
        var countRef = null;
        return expression.substitute(function (ex) {
            if (ex instanceof CountExpression) {
                if (!countRef)
                    countRef = $(_this.getRollupCountName(), 'NUMBER');
                return ex.operand.sum(countRef);
            }
            return null;
        });
    };
    DruidAggregationBuilder.prototype.getRollupCountName = function () {
        var rawAttributes = this.rawAttributes;
        for (var _i = 0, rawAttributes_1 = rawAttributes; _i < rawAttributes_1.length; _i++) {
            var attribute = rawAttributes_1[_i];
            var maker = attribute.maker;
            if (maker && maker.op === 'count')
                return attribute.name;
        }
        throw new Error("could not find rollup count");
    };
    DruidAggregationBuilder.prototype.inlineDerivedAttributes = function (expression) {
        var derivedAttributes = this.derivedAttributes;
        return expression.substitute(function (refEx) {
            if (refEx instanceof RefExpression) {
                return derivedAttributes[refEx.name] || null;
            }
            else {
                return null;
            }
        });
    };
    DruidAggregationBuilder.prototype.inlineDerivedAttributesInAggregate = function (expression) {
        var _this = this;
        return expression.substitute(function (ex) {
            if (ex.isAggregate()) {
                return _this.inlineDerivedAttributes(ex);
            }
            return null;
        });
    };
    DruidAggregationBuilder.prototype.getAttributesInfo = function (attributeName) {
        return NamedArray.get(this.rawAttributes, attributeName);
    };
    DruidAggregationBuilder.AGGREGATE_TO_DRUID = {
        sum: "doubleSum",
        min: "doubleMin",
        max: "doubleMax"
    };
    DruidAggregationBuilder.AGGREGATE_TO_FUNCTION = {
        sum: function (a, b) { return (a + "+" + b); },
        min: function (a, b) { return ("Math.min(" + a + "," + b + ")"); },
        max: function (a, b) { return ("Math.max(" + a + "," + b + ")"); }
    };
    DruidAggregationBuilder.AGGREGATE_TO_ZERO = {
        sum: "0",
        min: "Infinity",
        max: "-Infinity"
    };
    return DruidAggregationBuilder;
}());
