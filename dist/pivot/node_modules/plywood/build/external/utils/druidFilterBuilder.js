import { isDate } from 'chronoshift';
import { NamedArray } from 'immutable-class';
import { Expression, LiteralExpression, RefExpression, ChainableUnaryExpression, AndExpression, ContainsExpression, InExpression, IsExpression, IndexOfExpression, MatchExpression, NotExpression, OrExpression, OverlapExpression } from '../../expressions/index';
import { NumberRange, Range, TimeRange } from '../../datatypes/index';
import { External } from '../baseExternal';
import { DruidExtractionFnBuilder } from './druidExtractionFnBuilder';
export var DruidFilterBuilder = (function () {
    function DruidFilterBuilder(options) {
        this.version = options.version;
        this.rawAttributes = options.rawAttributes;
        this.timeAttribute = options.timeAttribute;
        this.allowEternity = options.allowEternity;
        this.customTransforms = options.customTransforms;
    }
    DruidFilterBuilder.prototype.filterToDruid = function (filter) {
        var _this = this;
        if (filter.type !== 'BOOLEAN')
            throw new Error("must be a BOOLEAN filter");
        if (filter.equals(Expression.FALSE)) {
            return {
                intervals: DruidFilterBuilder.FALSE_INTERVAL,
                filter: null
            };
        }
        else {
            var _a = filter.extractFromAnd(function (ex) {
                if (ex instanceof ChainableUnaryExpression) {
                    var op = ex.op, lhs = ex.operand, rhs = ex.expression;
                    if (_this.isTimeRef(lhs) && rhs instanceof LiteralExpression) {
                        return op === 'is' || op === 'in';
                    }
                }
                return false;
            }), extract = _a.extract, rest = _a.rest;
            return {
                intervals: this.timeFilterToIntervals(extract),
                filter: this.timelessFilterToFilter(rest, false)
            };
        }
    };
    DruidFilterBuilder.prototype.timeFilterToIntervals = function (filter) {
        if (filter.type !== 'BOOLEAN')
            throw new Error("must be a BOOLEAN filter");
        if (filter instanceof LiteralExpression) {
            if (!filter.value)
                return DruidFilterBuilder.FALSE_INTERVAL;
            if (!this.allowEternity)
                throw new Error('must filter on time unless the allowEternity flag is set');
            return DruidFilterBuilder.TRUE_INTERVAL;
        }
        else if (filter instanceof IsExpression) {
            var lhs = filter.operand, rhs = filter.expression;
            if (lhs instanceof RefExpression && rhs instanceof LiteralExpression) {
                return TimeRange.intervalFromDate(rhs.value);
            }
            else {
                throw new Error("can not convert " + filter + " to Druid interval");
            }
        }
        else if (filter instanceof InExpression) {
            var lhs = filter.operand, rhs = filter.expression;
            if (lhs instanceof RefExpression && rhs instanceof LiteralExpression) {
                var timeRanges = void 0;
                var rhsType = rhs.type;
                if (rhsType === 'SET/TIME_RANGE') {
                    timeRanges = rhs.value.elements;
                }
                else if (rhsType === 'TIME_RANGE') {
                    timeRanges = [rhs.value];
                }
                else {
                    throw new Error("not supported " + rhsType + " for time filtering");
                }
                var intervals = timeRanges.map(function (timeRange) { return timeRange.toInterval(); });
                return intervals.length === 1 ? intervals[0] : intervals;
            }
            else {
                throw new Error("can not convert " + filter + " to Druid interval");
            }
        }
        else {
            throw new Error("can not convert " + filter + " to Druid interval");
        }
    };
    DruidFilterBuilder.prototype.timelessFilterToFilter = function (filter, aggregatorFilter) {
        var _this = this;
        if (filter.type !== 'BOOLEAN')
            throw new Error("must be a BOOLEAN filter");
        if (filter instanceof RefExpression) {
            filter = filter.is(true);
        }
        if (filter instanceof LiteralExpression) {
            if (filter.value === true) {
                return null;
            }
            else {
                throw new Error("should never get here");
            }
        }
        else if (filter instanceof NotExpression) {
            return {
                type: 'not',
                field: this.timelessFilterToFilter(filter.operand, aggregatorFilter)
            };
        }
        else if (filter instanceof AndExpression) {
            return {
                type: 'and',
                fields: filter.getExpressionList().map(function (p) { return _this.timelessFilterToFilter(p, aggregatorFilter); })
            };
        }
        else if (filter instanceof OrExpression) {
            return {
                type: 'or',
                fields: filter.getExpressionList().map(function (p) { return _this.timelessFilterToFilter(p, aggregatorFilter); })
            };
        }
        else if (filter instanceof IsExpression) {
            var lhs = filter.operand, rhs = filter.expression;
            if (rhs instanceof LiteralExpression) {
                return this.makeSelectorFilter(lhs, rhs.value);
            }
            else {
                throw new Error("can not convert " + filter + " to Druid filter");
            }
        }
        else if (aggregatorFilter && this.versionBefore('0.9.1')) {
            if (this.versionBefore('0.8.2'))
                throw new Error("can not express aggregate filter " + filter + " in druid < 0.8.2");
            return this.makeExtractionFilter(filter);
        }
        else if (filter instanceof InExpression || filter instanceof OverlapExpression) {
            var lhs_1 = filter.operand, rhs = filter.expression;
            if (filter instanceof InExpression && lhs_1 instanceof LiteralExpression) {
                return this.makeSelectorFilter(rhs, lhs_1.value);
            }
            else if (rhs instanceof LiteralExpression) {
                var rhsType = rhs.type;
                if (rhsType === 'SET/STRING' || rhsType === 'SET/NUMBER' || rhsType === 'SET/NULL') {
                    return this.makeInFilter(lhs_1, rhs.value);
                }
                else if (rhsType === 'NUMBER_RANGE' || rhsType === 'TIME_RANGE' || rhsType === 'STRING_RANGE') {
                    return this.makeBoundFilter(lhs_1, rhs.value);
                }
                else if (rhsType === 'SET/NUMBER_RANGE' || rhsType === 'SET/TIME_RANGE') {
                    var elements = rhs.value.elements;
                    var fields = elements.map(function (range) {
                        return _this.makeBoundFilter(lhs_1, range);
                    });
                    return fields.length === 1 ? fields[0] : { type: "or", fields: fields };
                }
                else {
                    throw new Error("not supported IN rhs type " + rhsType);
                }
            }
            else {
                throw new Error("can not convert " + filter + " to Druid filter");
            }
        }
        else if (filter instanceof MatchExpression) {
            return this.makeRegexFilter(filter.operand, filter.regexp);
        }
        else if (filter instanceof ContainsExpression) {
            var lhs = filter.operand, rhs = filter.expression, compare = filter.compare;
            return this.makeContainsFilter(lhs, rhs, compare);
        }
        else {
            throw new Error("could not convert filter " + filter + " to Druid filter");
        }
    };
    DruidFilterBuilder.prototype.checkFilterExtractability = function (attributeInfo) {
        if (this.versionBefore('0.9.2') && attributeInfo.name === this.timeAttribute) {
            throw new Error('can not do secondary filtering on primary time dimension (https://github.com/druid-io/druid/issues/2816)');
        }
    };
    DruidFilterBuilder.prototype.makeJavaScriptFilter = function (ex) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        this.checkFilterExtractability(attributeInfo);
        return {
            type: "javascript",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            "function": ex.getJSFn('d')
        };
    };
    DruidFilterBuilder.prototype.makeExtractionFilter = function (ex) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        return {
            type: "extraction",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            extractionFn: extractionFn,
            value: "true"
        };
    };
    DruidFilterBuilder.prototype.makeSelectorFilter = function (ex, value) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        if (attributeInfo.unsplitable) {
            throw new Error("can not convert " + ex + " = " + value + " to filter because it references an un-filterable metric '" + attributeInfo.name + "' which is most likely rolled up.");
        }
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        if (value instanceof Range)
            value = value.start;
        var druidFilter = {
            type: "selector",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            value: attributeInfo.serialize(value)
        };
        if (extractionFn) {
            druidFilter.extractionFn = extractionFn;
            if (this.versionBefore('0.9.1'))
                druidFilter.type = "extraction";
            if (this.versionBefore('0.9.0') && druidFilter.value === null)
                druidFilter.value = '';
        }
        return druidFilter;
    };
    DruidFilterBuilder.prototype.makeInFilter = function (ex, valueSet) {
        var _this = this;
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        var elements = valueSet.elements;
        if (elements.length < 2 ||
            (this.versionBefore('0.9.1') && extractionFn) ||
            this.versionBefore('0.9.0')) {
            var fields = elements.map(function (value) {
                return _this.makeSelectorFilter(ex, value);
            });
            return fields.length === 1 ? fields[0] : { type: "or", fields: fields };
        }
        var inFilter = {
            type: 'in',
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            values: elements.map(function (value) { return attributeInfo.serialize(value); })
        };
        if (extractionFn)
            inFilter.extractionFn = extractionFn;
        return inFilter;
    };
    DruidFilterBuilder.prototype.makeBoundFilter = function (ex, range) {
        var r0 = range.start;
        var r1 = range.end;
        var bounds = range.bounds;
        if (this.versionBefore('0.9.0') || r0 < 0 || r1 < 0) {
            return this.makeJavaScriptFilter(ex.in(range));
        }
        if (ex instanceof IndexOfExpression) {
            return this.makeJavaScriptFilter(ex.in(range));
        }
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (this.versionBefore('0.9.1') && extractionFn) {
            return this.makeJavaScriptFilter(ex.in(range));
        }
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        var boundFilter = {
            type: "bound",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo)
        };
        if (extractionFn)
            boundFilter.extractionFn = extractionFn;
        if (range instanceof NumberRange)
            boundFilter.alphaNumeric = true;
        if (r0 != null) {
            boundFilter.lower = isDate(r0) ? r0.toISOString() : r0;
            if (bounds[0] === '(')
                boundFilter.lowerStrict = true;
        }
        if (r1 != null) {
            boundFilter.upper = isDate(r1) ? r1.toISOString() : r1;
            if (bounds[1] === ')')
                boundFilter.upperStrict = true;
        }
        return boundFilter;
    };
    DruidFilterBuilder.prototype.makeRegexFilter = function (ex, regex) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (this.versionBefore('0.9.1') && extractionFn) {
            return this.makeExtractionFilter(ex.match(regex));
        }
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        var regexFilter = {
            type: "regex",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            pattern: regex
        };
        if (extractionFn)
            regexFilter.extractionFn = extractionFn;
        return regexFilter;
    };
    DruidFilterBuilder.prototype.makeContainsFilter = function (lhs, rhs, compare) {
        if (rhs instanceof LiteralExpression) {
            var attributeInfo = this.getSingleReferenceAttributeInfo(lhs);
            var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(lhs);
            if (extractionFn)
                this.checkFilterExtractability(attributeInfo);
            if (this.versionBefore('0.9.0')) {
                if (compare === ContainsExpression.IGNORE_CASE) {
                    return {
                        type: "search",
                        dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
                        query: {
                            type: "insensitive_contains",
                            value: rhs.value
                        }
                    };
                }
                else {
                    return this.makeJavaScriptFilter(lhs.contains(rhs, compare));
                }
            }
            if (this.versionBefore('0.9.1') && extractionFn) {
                return this.makeExtractionFilter(lhs.contains(rhs, compare));
            }
            var searchFilter = {
                type: "search",
                dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
                query: {
                    type: "contains",
                    value: rhs.value,
                    caseSensitive: compare === ContainsExpression.NORMAL
                }
            };
            if (extractionFn)
                searchFilter.extractionFn = extractionFn;
            return searchFilter;
        }
        else {
            return this.makeJavaScriptFilter(lhs.contains(rhs, compare));
        }
    };
    DruidFilterBuilder.prototype.getSingleReferenceAttributeInfo = function (ex) {
        var freeReferences = ex.getFreeReferences();
        if (freeReferences.length !== 1)
            throw new Error("can not translate multi reference expression " + ex + " to Druid");
        var referenceName = freeReferences[0];
        return this.getAttributesInfo(referenceName);
    };
    DruidFilterBuilder.prototype.getDimensionNameForAttributeInfo = function (attributeInfo) {
        return attributeInfo.name === this.timeAttribute ? DruidFilterBuilder.TIME_ATTRIBUTE : attributeInfo.name;
    };
    DruidFilterBuilder.prototype.versionBefore = function (neededVersion) {
        var version = this.version;
        return version && External.versionLessThan(version, neededVersion);
    };
    DruidFilterBuilder.prototype.getAttributesInfo = function (attributeName) {
        return NamedArray.get(this.rawAttributes, attributeName);
    };
    DruidFilterBuilder.prototype.isTimeRef = function (ex) {
        return ex instanceof RefExpression && ex.name === this.timeAttribute;
    };
    DruidFilterBuilder.TIME_ATTRIBUTE = '__time';
    DruidFilterBuilder.TRUE_INTERVAL = "1000/3000";
    DruidFilterBuilder.FALSE_INTERVAL = "1000/1001";
    return DruidFilterBuilder;
}());
