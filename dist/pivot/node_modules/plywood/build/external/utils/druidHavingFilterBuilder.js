import { LiteralExpression, RefExpression, AndExpression, InExpression, IsExpression, NotExpression, OrExpression } from '../../expressions/index';
export var DruidHavingFilterBuilder = (function () {
    function DruidHavingFilterBuilder(options) {
        this.version = options.version;
    }
    DruidHavingFilterBuilder.prototype.filterToHavingFilter = function (filter) {
        var _this = this;
        if (filter instanceof LiteralExpression) {
            if (filter.value === true) {
                return null;
            }
            else {
                throw new Error("should never get here");
            }
        }
        else if (filter instanceof NotExpression) {
            return {
                type: 'not',
                havingSpec: this.filterToHavingFilter(filter.operand)
            };
        }
        else if (filter instanceof AndExpression) {
            return {
                type: 'and',
                havingSpecs: filter.getExpressionList().map(this.filterToHavingFilter, this)
            };
        }
        else if (filter instanceof OrExpression) {
            return {
                type: 'or',
                havingSpecs: filter.getExpressionList().map(this.filterToHavingFilter, this)
            };
        }
        else if (filter instanceof IsExpression) {
            var lhs = filter.operand, rhs = filter.expression;
            if (lhs instanceof RefExpression && rhs instanceof LiteralExpression) {
                return {
                    type: "equalTo",
                    aggregation: lhs.name,
                    value: rhs.value
                };
            }
            else {
                throw new Error("can not convert " + filter + " to Druid having filter");
            }
        }
        else if (filter instanceof InExpression) {
            var lhs_1 = filter.operand, rhs = filter.expression;
            if (lhs_1 instanceof RefExpression && rhs instanceof LiteralExpression) {
                var rhsType = rhs.type;
                if (rhsType === 'SET/STRING') {
                    return {
                        type: "or",
                        havingSpecs: rhs.value.elements.map(function (value) {
                            return {
                                type: "equalTo",
                                aggregation: lhs_1.name,
                                value: value
                            };
                        })
                    };
                }
                else if (rhsType === 'SET/NUMBER_RANGE') {
                    return {
                        type: "or",
                        havingSpecs: rhs.value.elements.map(function (value) {
                            return _this.inToHavingFilter(lhs_1.name, value);
                        }, this)
                    };
                }
                else if (rhsType === 'NUMBER_RANGE') {
                    return this.inToHavingFilter(lhs_1.name, rhs.value);
                }
                else if (rhsType === 'TIME_RANGE') {
                    throw new Error("can not compute having filter on time");
                }
                else {
                    throw new Error("not supported " + rhsType);
                }
            }
            else {
                throw new Error("can not convert " + filter + " to Druid having filter");
            }
        }
        throw new Error("could not convert filter " + filter + " to Druid having filter");
    };
    DruidHavingFilterBuilder.prototype.makeHavingComparison = function (agg, op, value) {
        switch (op) {
            case '<':
                return { type: "lessThan", aggregation: agg, value: value };
            case '>':
                return { type: "greaterThan", aggregation: agg, value: value };
            case '<=':
                return { type: 'not', havingSpec: { type: "greaterThan", aggregation: agg, value: value } };
            case '>=':
                return { type: 'not', havingSpec: { type: "lessThan", aggregation: agg, value: value } };
            default:
                throw new Error("unknown op: " + op);
        }
    };
    DruidHavingFilterBuilder.prototype.inToHavingFilter = function (agg, range) {
        var havingSpecs = [];
        if (range.start !== null) {
            havingSpecs.push(this.makeHavingComparison(agg, (range.bounds[0] === '[' ? '>=' : '>'), range.start));
        }
        if (range.end !== null) {
            havingSpecs.push(this.makeHavingComparison(agg, (range.bounds[1] === ']' ? '<=' : '<'), range.end));
        }
        return havingSpecs.length === 1 ? havingSpecs[0] : { type: 'and', havingSpecs: havingSpecs };
    };
    return DruidHavingFilterBuilder;
}());
