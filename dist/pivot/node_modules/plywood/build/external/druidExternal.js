var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { hasOwnProperty, dictEqual, nonEmptyLookup, shallowCopy, ExtendableError } from '../helper/utils';
import { $, Expression, RefExpression, ChainableExpression, CardinalityExpression, InExpression, IsExpression, MatchExpression, MaxExpression, MinExpression, NumberBucketExpression, TimeBucketExpression, TimeFloorExpression, TimePartExpression } from '../expressions/index';
import { AttributeInfo, UniqueAttributeInfo, HistogramAttributeInfo, ThetaAttributeInfo, Dataset } from '../datatypes/index';
import { External, TotalContainer } from './baseExternal';
import { DruidExtractionFnBuilder } from './utils/druidExtractionFnBuilder';
import { DruidFilterBuilder } from './utils/druidFilterBuilder';
import { DruidHavingFilterBuilder } from './utils/druidHavingFilterBuilder';
import { DruidAggregationBuilder } from './utils/druidAggregationBuilder';
import { unwrapSetType } from '../datatypes/common';
export var InvalidResultError = (function (_super) {
    __extends(InvalidResultError, _super);
    function InvalidResultError(message, result) {
        _super.call(this, message);
        this.result = result;
    }
    return InvalidResultError;
}(ExtendableError));
function expressionNeedsAlphaNumericSort(ex) {
    var type = ex.type;
    return (type === 'NUMBER' || type === 'NUMBER_RANGE');
}
function simpleJSONEqual(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
}
export var DruidExternal = (function (_super) {
    __extends(DruidExternal, _super);
    function DruidExternal(parameters) {
        _super.call(this, parameters, dummyObject);
        this._ensureEngine("druid");
        this._ensureMinVersion("0.8.0");
        this.timeAttribute = parameters.timeAttribute || DruidExternal.TIME_ATTRIBUTE;
        this.customAggregations = parameters.customAggregations;
        this.customTransforms = parameters.customTransforms;
        this.allowEternity = parameters.allowEternity;
        this.allowSelectQueries = parameters.allowSelectQueries;
        var introspectionStrategy = parameters.introspectionStrategy || DruidExternal.DEFAULT_INTROSPECTION_STRATEGY;
        if (DruidExternal.VALID_INTROSPECTION_STRATEGIES.indexOf(introspectionStrategy) === -1) {
            throw new Error("invalid introspectionStrategy '" + introspectionStrategy + "'");
        }
        this.introspectionStrategy = introspectionStrategy;
        this.exactResultsOnly = parameters.exactResultsOnly;
        this.context = parameters.context;
    }
    DruidExternal.fromJS = function (parameters, requester) {
        if (typeof parameters.druidVersion === 'string') {
            parameters.version = parameters.druidVersion;
            console.warn("'druidVersion' parameter is deprecated, use 'version: " + parameters.version + "' instead");
        }
        var value = External.jsToValue(parameters, requester);
        value.timeAttribute = parameters.timeAttribute;
        value.customAggregations = parameters.customAggregations || {};
        value.customTransforms = parameters.customTransforms || {};
        value.allowEternity = Boolean(parameters.allowEternity);
        value.allowSelectQueries = Boolean(parameters.allowSelectQueries);
        value.introspectionStrategy = parameters.introspectionStrategy;
        value.exactResultsOnly = Boolean(parameters.exactResultsOnly);
        value.context = parameters.context;
        return new DruidExternal(value);
    };
    DruidExternal.getSourceList = function (requester) {
        return requester({ query: { queryType: 'sourceList' } })
            .then(function (sources) {
            if (!Array.isArray(sources))
                throw new InvalidResultError('invalid sources response', sources);
            return sources.sort();
        });
    };
    DruidExternal.getVersion = function (requester) {
        return requester({
            query: {
                queryType: 'status'
            }
        })
            .then(function (res) {
            if (!DruidExternal.correctStatusResult(res))
                throw new InvalidResultError('unexpected result from /status', res);
            return res.version;
        });
    };
    DruidExternal.cleanDatumInPlace = function (datum) {
        for (var k in datum) {
            if (k[0] === '!')
                delete datum[k];
        }
    };
    DruidExternal.correctTimeBoundaryResult = function (result) {
        return Array.isArray(result) && result.length === 1 && typeof result[0].result === 'object';
    };
    DruidExternal.correctTimeseriesResult = function (result) {
        return Array.isArray(result) && (result.length === 0 || typeof result[0].result === 'object');
    };
    DruidExternal.correctTopNResult = function (result) {
        return Array.isArray(result) && (result.length === 0 || Array.isArray(result[0].result));
    };
    DruidExternal.correctGroupByResult = function (result) {
        return Array.isArray(result) && (result.length === 0 || typeof result[0].event === 'object');
    };
    DruidExternal.correctSelectResult = function (result) {
        return Array.isArray(result) && (result.length === 0 || typeof result[0].result === 'object');
    };
    DruidExternal.correctStatusResult = function (result) {
        return result && typeof result.version === 'string';
    };
    DruidExternal.timeBoundaryPostProcessFactory = function (applies) {
        return function (res) {
            if (!DruidExternal.correctTimeBoundaryResult(res))
                throw new InvalidResultError("unexpected result from Druid (timeBoundary)", res);
            var result = res[0].result;
            if (applies) {
                var datum = {};
                for (var _i = 0, applies_1 = applies; _i < applies_1.length; _i++) {
                    var apply = applies_1[_i];
                    var name = apply.name;
                    if (typeof result === 'string') {
                        datum[name] = new Date(result);
                    }
                    else {
                        if (apply.expression.op === 'max') {
                            datum[name] = new Date((result['maxIngestedEventTime'] || result['maxTime']));
                        }
                        else {
                            datum[name] = new Date(result['minTime']);
                        }
                    }
                }
                return new TotalContainer(datum);
            }
            else {
                return new Date((result['maxIngestedEventTime'] || result['maxTime'] || result['minTime']));
            }
        };
    };
    DruidExternal.valuePostProcess = function (res) {
        if (!DruidExternal.correctTimeseriesResult(res))
            throw new InvalidResultError("unexpected result from Druid (all / value)", res);
        if (!res.length)
            return 0;
        return res[0].result[External.VALUE_NAME];
    };
    DruidExternal.totalPostProcessFactory = function (applies) {
        return function (res) {
            if (!DruidExternal.correctTimeseriesResult(res))
                throw new InvalidResultError("unexpected result from Druid (all)", res);
            if (!res.length)
                return new TotalContainer(External.makeZeroDatum(applies));
            var datum = res[0].result;
            DruidExternal.cleanDatumInPlace(datum);
            return new TotalContainer(datum);
        };
    };
    DruidExternal.timeseriesNormalizerFactory = function (timestampLabel) {
        if (timestampLabel === void 0) { timestampLabel = null; }
        return function (res) {
            if (!DruidExternal.correctTimeseriesResult(res))
                throw new InvalidResultError("unexpected result from Druid (timeseries)", res);
            return res.map(function (r) {
                var datum = r.result;
                DruidExternal.cleanDatumInPlace(datum);
                if (timestampLabel)
                    datum[timestampLabel] = r.timestamp;
                return datum;
            });
        };
    };
    DruidExternal.topNNormalizer = function (res) {
        if (!DruidExternal.correctTopNResult(res))
            throw new InvalidResultError("unexpected result from Druid (topN)", res);
        var data = res.length ? res[0].result : [];
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var d = data_1[_i];
            DruidExternal.cleanDatumInPlace(d);
        }
        return data;
    };
    DruidExternal.groupByNormalizerFactory = function (timestampLabel) {
        if (timestampLabel === void 0) { timestampLabel = null; }
        return function (res) {
            if (!DruidExternal.correctGroupByResult(res))
                throw new InvalidResultError("unexpected result from Druid (groupBy)", res);
            return res.map(function (r) {
                var datum = r.event;
                DruidExternal.cleanDatumInPlace(datum);
                if (timestampLabel)
                    datum[timestampLabel] = r.timestamp;
                return datum;
            });
        };
    };
    DruidExternal.selectNormalizerFactory = function (timestampLabel) {
        return function (results) {
            var data = [];
            for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
                var result = results_1[_i];
                if (!DruidExternal.correctSelectResult(result))
                    throw new InvalidResultError("unexpected result from Druid (select)", result);
                if (result.length === 0)
                    continue;
                var events = result[0].result.events;
                for (var _a = 0, events_1 = events; _a < events_1.length; _a++) {
                    var event = events_1[_a];
                    var datum = event.event;
                    if (timestampLabel != null) {
                        datum[timestampLabel] = datum['timestamp'];
                    }
                    delete datum['timestamp'];
                    DruidExternal.cleanDatumInPlace(datum);
                    data.push(datum);
                }
            }
            return data;
        };
    };
    DruidExternal.postProcessFactory = function (normalizer, inflaters, attributes) {
        return function (res) {
            var data = normalizer(res);
            var n = data.length;
            for (var _i = 0, inflaters_1 = inflaters; _i < inflaters_1.length; _i++) {
                var inflater = inflaters_1[_i];
                for (var i = 0; i < n; i++) {
                    inflater(data[i], i, data);
                }
            }
            return new Dataset({ data: data, attributes: attributes });
        };
    };
    DruidExternal.selectNextFactory = function (limit, descending) {
        var resultsSoFar = 0;
        return function (prevQuery, prevResult) {
            if (!DruidExternal.correctSelectResult(prevResult))
                throw new InvalidResultError("unexpected result from Druid (select / partial)", prevResult);
            if (prevResult.length === 0)
                return null;
            var _a = prevResult[0].result, pagingIdentifiers = _a.pagingIdentifiers, events = _a.events;
            if (events.length < prevQuery.pagingSpec.threshold)
                return null;
            resultsSoFar += events.length;
            if (resultsSoFar >= limit)
                return null;
            pagingIdentifiers = DruidExternal.movePagingIdentifiers(pagingIdentifiers, descending ? -1 : 1);
            prevQuery.pagingSpec.pagingIdentifiers = pagingIdentifiers;
            prevQuery.pagingSpec.threshold = Math.min(limit - resultsSoFar, DruidExternal.SELECT_MAX_LIMIT);
            return prevQuery;
        };
    };
    DruidExternal.generateMaker = function (aggregation) {
        if (!aggregation)
            return null;
        var type = aggregation.type, fieldName = aggregation.fieldName;
        if (type === 'longSum' && fieldName === 'count') {
            return Expression._.count();
        }
        if (!fieldName) {
            var fieldNames = aggregation.fieldNames;
            if (!Array.isArray(fieldNames) || fieldNames.length !== 1)
                return null;
            fieldName = fieldNames[0];
        }
        var expression = $(fieldName);
        switch (type) {
            case "count":
                return Expression._.count();
            case "doubleSum":
            case "longSum":
                return Expression._.sum(expression);
            case "javascript":
                var fnAggregate = aggregation.fnAggregate, fnCombine = aggregation.fnCombine;
                if (fnAggregate !== fnCombine || fnCombine.indexOf('+') === -1)
                    return null;
                return Expression._.sum(expression);
            case "doubleMin":
            case "longMin":
                return Expression._.min(expression);
            case "doubleMax":
            case "longMax":
                return Expression._.max(expression);
            default:
                return null;
        }
    };
    DruidExternal.segmentMetadataPostProcessFactory = function (timeAttribute) {
        return function (res) {
            var res0 = res[0];
            if (!res0 || !res0.columns)
                throw new InvalidResultError('malformed segmentMetadata response', res);
            var columns = res0.columns;
            var aggregators = res0.aggregators || {};
            var foundTime = false;
            var attributes = [];
            for (var name in columns) {
                if (!hasOwnProperty(columns, name))
                    continue;
                var columnData = columns[name];
                if (columnData.errorMessage || columnData.size < 0)
                    continue;
                if (name === DruidExternal.TIME_ATTRIBUTE) {
                    attributes.push(new AttributeInfo({ name: timeAttribute, type: 'TIME' }));
                    foundTime = true;
                }
                else {
                    if (name === timeAttribute)
                        continue;
                    switch (columnData.type) {
                        case 'FLOAT':
                        case 'LONG':
                            attributes.push(new AttributeInfo({
                                name: name,
                                type: 'NUMBER',
                                unsplitable: true,
                                maker: DruidExternal.generateMaker(aggregators[name])
                            }));
                            break;
                        case 'STRING':
                            attributes.push(new AttributeInfo({
                                name: name,
                                type: columnData.hasMultipleValues ? 'SET/STRING' : 'STRING'
                            }));
                            break;
                        case 'hyperUnique':
                            attributes.push(new UniqueAttributeInfo({ name: name }));
                            break;
                        case 'approximateHistogram':
                            attributes.push(new HistogramAttributeInfo({ name: name }));
                            break;
                        case 'thetaSketch':
                            attributes.push(new ThetaAttributeInfo({ name: name }));
                            break;
                    }
                }
            }
            if (!foundTime)
                throw new Error("no valid " + DruidExternal.TIME_ATTRIBUTE + " in segmentMetadata response");
            return attributes;
        };
    };
    DruidExternal.introspectPostProcessFactory = function (timeAttribute) {
        return function (res) {
            if (!Array.isArray(res.dimensions) || !Array.isArray(res.metrics)) {
                throw new InvalidResultError('malformed GET introspect response', res);
            }
            var attributes = [
                new AttributeInfo({ name: timeAttribute, type: 'TIME' })
            ];
            res.dimensions.forEach(function (dimension) {
                if (dimension === timeAttribute)
                    return;
                attributes.push(new AttributeInfo({ name: dimension, type: 'STRING' }));
            });
            res.metrics.forEach(function (metric) {
                if (metric === timeAttribute)
                    return;
                attributes.push(new AttributeInfo({ name: metric, type: 'NUMBER', unsplitable: true }));
            });
            return attributes;
        };
    };
    DruidExternal.movePagingIdentifiers = function (pagingIdentifiers, increment) {
        var newPagingIdentifiers = {};
        for (var key in pagingIdentifiers) {
            if (!hasOwnProperty(pagingIdentifiers, key))
                continue;
            newPagingIdentifiers[key] = pagingIdentifiers[key] + increment;
        }
        return newPagingIdentifiers;
    };
    DruidExternal.prototype.valueOf = function () {
        var value = _super.prototype.valueOf.call(this);
        value.timeAttribute = this.timeAttribute;
        value.customAggregations = this.customAggregations;
        value.customTransforms = this.customTransforms;
        value.allowEternity = this.allowEternity;
        value.allowSelectQueries = this.allowSelectQueries;
        value.introspectionStrategy = this.introspectionStrategy;
        value.exactResultsOnly = this.exactResultsOnly;
        value.context = this.context;
        return value;
    };
    DruidExternal.prototype.toJS = function () {
        var js = _super.prototype.toJS.call(this);
        if (this.timeAttribute !== DruidExternal.TIME_ATTRIBUTE)
            js.timeAttribute = this.timeAttribute;
        if (nonEmptyLookup(this.customAggregations))
            js.customAggregations = this.customAggregations;
        if (nonEmptyLookup(this.customTransforms))
            js.customTransforms = this.customTransforms;
        if (this.allowEternity)
            js.allowEternity = true;
        if (this.allowSelectQueries)
            js.allowSelectQueries = true;
        if (this.introspectionStrategy !== DruidExternal.DEFAULT_INTROSPECTION_STRATEGY)
            js.introspectionStrategy = this.introspectionStrategy;
        if (this.exactResultsOnly)
            js.exactResultsOnly = true;
        if (this.context)
            js.context = this.context;
        return js;
    };
    DruidExternal.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other) &&
            this.timeAttribute === other.timeAttribute &&
            simpleJSONEqual(this.customAggregations, other.customAggregations) &&
            simpleJSONEqual(this.customTransforms, other.customTransforms) &&
            this.allowEternity === other.allowEternity &&
            this.allowSelectQueries === other.allowSelectQueries &&
            this.introspectionStrategy === other.introspectionStrategy &&
            this.exactResultsOnly === other.exactResultsOnly &&
            dictEqual(this.context, other.context);
    };
    DruidExternal.prototype.canHandleTotal = function () {
        return true;
    };
    DruidExternal.prototype.canHandleFilter = function (filter) {
        return !filter.expression.some(function (ex) { return ex.isOp('cardinality') ? true : null; });
    };
    DruidExternal.prototype.canHandleSplit = function (split) {
        return true;
    };
    DruidExternal.prototype.canHandleSplitExpression = function (ex) {
        return true;
    };
    DruidExternal.prototype.canHandleApply = function (apply) {
        return true;
    };
    DruidExternal.prototype.canHandleSort = function (sort) {
        if (this.isTimeseries()) {
            if (sort.direction !== 'ascending')
                return false;
            return sort.refName() === this.split.firstSplitName();
        }
        else if (this.mode === 'raw') {
            if (sort.refName() !== this.timeAttribute)
                return false;
            if (this.versionBefore('0.9.0'))
                return sort.direction === 'ascending';
            return true;
        }
        else {
            return true;
        }
    };
    DruidExternal.prototype.canHandleLimit = function (limit) {
        return !this.isTimeseries();
    };
    DruidExternal.prototype.canHandleHavingFilter = function (havingFilter) {
        return !this.limit;
    };
    DruidExternal.prototype.isTimeseries = function () {
        var split = this.split;
        if (!split || split.isMultiSplit())
            return false;
        var splitExpression = split.firstSplitExpression();
        if (this.isTimeRef(splitExpression))
            return true;
        var op = splitExpression.op;
        return op === 'timeBucket' || op === 'timeFloor';
    };
    DruidExternal.prototype.getDruidDataSource = function () {
        var source = this.source;
        if (Array.isArray(source)) {
            return {
                type: "union",
                dataSources: source
            };
        }
        else {
            return source;
        }
    };
    DruidExternal.prototype.getDimensionNameForAttributeInfo = function (attributeInfo) {
        return attributeInfo.name === this.timeAttribute ? DruidExternal.TIME_ATTRIBUTE : attributeInfo.name;
    };
    DruidExternal.prototype.isTimeRef = function (ex) {
        return ex instanceof RefExpression && ex.name === this.timeAttribute;
    };
    DruidExternal.prototype.splitExpressionToGranularityInflater = function (splitExpression, label) {
        if (this.isTimeRef(splitExpression)) {
            return {
                granularity: 'none',
                inflater: External.timeInflaterFactory(label)
            };
        }
        else if (splitExpression instanceof TimeBucketExpression || splitExpression instanceof TimeFloorExpression) {
            var op = splitExpression.op, operand = splitExpression.operand, duration = splitExpression.duration;
            var timezone = splitExpression.getTimezone();
            if (this.isTimeRef(operand)) {
                return {
                    granularity: {
                        type: "period",
                        period: duration.toString(),
                        timeZone: timezone.toString()
                    },
                    inflater: op === 'timeBucket' ?
                        External.timeRangeInflaterFactory(label, duration, timezone) :
                        External.timeInflaterFactory(label)
                };
            }
        }
        return null;
    };
    DruidExternal.prototype.expressionToDimensionInflater = function (expression, label) {
        var freeReferences = expression.getFreeReferences();
        if (freeReferences.length !== 1) {
            throw new Error("must have 1 reference (has " + freeReferences.length + "): " + expression);
        }
        var referenceName = freeReferences[0];
        var attributeInfo = this.getAttributesInfo(referenceName);
        if (attributeInfo.unsplitable) {
            throw new Error("can not convert " + expression + " to split because it references an un-splitable metric '" + referenceName + "' which is most likely rolled up.");
        }
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(expression);
        var simpleInflater = External.getSimpleInflater(expression, label);
        var dimension = {
            type: "default",
            dimension: attributeInfo.name === this.timeAttribute ? DruidExternal.TIME_ATTRIBUTE : attributeInfo.name,
            outputName: label
        };
        if (extractionFn) {
            dimension.type = "extraction";
            dimension.extractionFn = extractionFn;
        }
        if (expression instanceof RefExpression) {
            return {
                dimension: dimension,
                inflater: simpleInflater
            };
        }
        if (expression instanceof TimeBucketExpression) {
            return {
                dimension: dimension,
                inflater: External.timeRangeInflaterFactory(label, expression.duration, expression.getTimezone())
            };
        }
        if (expression instanceof TimePartExpression) {
            return {
                dimension: dimension,
                inflater: simpleInflater
            };
        }
        if (expression instanceof NumberBucketExpression) {
            return {
                dimension: dimension,
                inflater: External.numberRangeInflaterFactory(label, expression.size)
            };
        }
        if (expression instanceof CardinalityExpression) {
            return {
                dimension: dimension,
                inflater: External.setCardinalityInflaterFactory(label)
            };
        }
        var effectiveType = unwrapSetType(expression.type);
        if (simpleInflater || effectiveType === 'STRING') {
            return {
                dimension: dimension,
                inflater: simpleInflater
            };
        }
        throw new Error("could not convert " + expression + " to a Druid dimension");
    };
    DruidExternal.prototype.expressionToDimensionInflaterHaving = function (expression, label, havingFilter) {
        var dimensionInflater = this.expressionToDimensionInflater(expression, label);
        dimensionInflater.having = havingFilter;
        if (expression.type !== 'SET/STRING')
            return dimensionInflater;
        var _a = havingFilter.extractFromAnd(function (hf) {
            if (hf instanceof ChainableExpression) {
                var hfOp = hf.op;
                var hfOperand = hf.operand;
                if (hfOperand instanceof RefExpression && hfOperand.name === label) {
                    if (hfOp === 'match')
                        return true;
                    if (hfOp === 'is' || hfOp === 'in')
                        return hf.expression.isOp('literal');
                }
            }
            return false;
        }), extract = _a.extract, rest = _a.rest;
        if (extract.equals(Expression.TRUE))
            return dimensionInflater;
        if (extract instanceof MatchExpression) {
            return {
                dimension: {
                    type: "regexFiltered",
                    delegate: dimensionInflater.dimension,
                    pattern: extract.regexp
                },
                inflater: dimensionInflater.inflater,
                having: rest
            };
        }
        else if (extract instanceof IsExpression) {
            return {
                dimension: {
                    type: "listFiltered",
                    delegate: dimensionInflater.dimension,
                    values: [extract.expression.getLiteralValue()]
                },
                inflater: dimensionInflater.inflater,
                having: rest
            };
        }
        else if (extract instanceof InExpression) {
            return {
                dimension: {
                    type: "listFiltered",
                    delegate: dimensionInflater.dimension,
                    values: extract.expression.getLiteralValue().elements
                },
                inflater: dimensionInflater.inflater,
                having: rest
            };
        }
        return dimensionInflater;
    };
    DruidExternal.prototype.splitToDruid = function (split) {
        var _this = this;
        var leftoverHavingFilter = this.havingFilter;
        var selectedAttributes = this.getSelectedAttributes();
        if (split.isMultiSplit()) {
            var timestampLabel_1 = null;
            var granularity_1 = null;
            var dimensions_1 = [];
            var inflaters_2 = [];
            split.mapSplits(function (name, expression) {
                if (!granularity_1 && !_this.limit && !_this.sort) {
                    var granularityInflater_1 = _this.splitExpressionToGranularityInflater(expression, name);
                    if (granularityInflater_1) {
                        timestampLabel_1 = name;
                        granularity_1 = granularityInflater_1.granularity;
                        inflaters_2.push(granularityInflater_1.inflater);
                        return;
                    }
                }
                var _a = _this.expressionToDimensionInflaterHaving(expression, name, leftoverHavingFilter), dimension = _a.dimension, inflater = _a.inflater, having = _a.having;
                leftoverHavingFilter = having;
                dimensions_1.push(dimension);
                if (inflater) {
                    inflaters_2.push(inflater);
                }
            });
            return {
                queryType: 'groupBy',
                dimensions: dimensions_1,
                timestampLabel: timestampLabel_1,
                granularity: granularity_1 || 'all',
                leftoverHavingFilter: leftoverHavingFilter,
                postProcess: DruidExternal.postProcessFactory(DruidExternal.groupByNormalizerFactory(timestampLabel_1), inflaters_2, selectedAttributes)
            };
        }
        var splitExpression = split.firstSplitExpression();
        var label = split.firstSplitName();
        var granularityInflater = this.splitExpressionToGranularityInflater(splitExpression, label);
        if (granularityInflater) {
            return {
                queryType: 'timeseries',
                granularity: granularityInflater.granularity,
                leftoverHavingFilter: leftoverHavingFilter,
                postProcess: DruidExternal.postProcessFactory(DruidExternal.timeseriesNormalizerFactory(label), [granularityInflater.inflater], selectedAttributes)
            };
        }
        var dimensionInflater = this.expressionToDimensionInflaterHaving(splitExpression, label, leftoverHavingFilter);
        leftoverHavingFilter = dimensionInflater.having;
        var inflaters = [dimensionInflater.inflater].filter(Boolean);
        if (leftoverHavingFilter.equals(Expression.TRUE) &&
            (this.limit || split.maxBucketNumber() < 1000) &&
            !this.exactResultsOnly) {
            return {
                queryType: 'topN',
                dimension: dimensionInflater.dimension,
                granularity: 'all',
                leftoverHavingFilter: leftoverHavingFilter,
                postProcess: DruidExternal.postProcessFactory(DruidExternal.topNNormalizer, inflaters, selectedAttributes)
            };
        }
        return {
            queryType: 'groupBy',
            dimensions: [dimensionInflater.dimension],
            granularity: 'all',
            leftoverHavingFilter: leftoverHavingFilter,
            postProcess: DruidExternal.postProcessFactory(DruidExternal.groupByNormalizerFactory(), inflaters, selectedAttributes)
        };
    };
    DruidExternal.prototype.isMinMaxTimeExpression = function (applyExpression) {
        if (applyExpression instanceof MinExpression || applyExpression instanceof MaxExpression) {
            return this.isTimeRef(applyExpression.expression);
        }
        else {
            return false;
        }
    };
    DruidExternal.prototype.getTimeBoundaryQueryAndPostProcess = function () {
        var _a = this, mode = _a.mode, context = _a.context;
        var druidQuery = {
            queryType: "timeBoundary",
            dataSource: this.getDruidDataSource()
        };
        if (context) {
            druidQuery.context = context;
        }
        var applies = null;
        if (mode === 'total') {
            applies = this.applies;
            if (applies.length === 1) {
                var loneApplyExpression = applies[0].expression;
                druidQuery.bound = loneApplyExpression.op + "Time";
            }
        }
        else if (mode === 'value') {
            var valueExpression = this.valueExpression;
            druidQuery.bound = valueExpression.op + "Time";
        }
        else {
            throw new Error("invalid mode '" + mode + "' for timeBoundary");
        }
        return {
            query: druidQuery,
            postProcess: DruidExternal.timeBoundaryPostProcessFactory(applies)
        };
    };
    DruidExternal.prototype.getQueryAndPostProcess = function () {
        var _this = this;
        var _a = this, mode = _a.mode, applies = _a.applies, sort = _a.sort, limit = _a.limit, context = _a.context;
        if (mode === 'total' && applies && applies.length && applies.every(function (apply) { return _this.isMinMaxTimeExpression(apply.expression); })) {
            return this.getTimeBoundaryQueryAndPostProcess();
        }
        else if (mode === 'value' && this.isMinMaxTimeExpression(this.valueExpression)) {
            return this.getTimeBoundaryQueryAndPostProcess();
        }
        var druidQuery = {
            queryType: 'timeseries',
            dataSource: this.getDruidDataSource(),
            intervals: null,
            granularity: 'all'
        };
        if (context) {
            druidQuery.context = shallowCopy(context);
        }
        var filterAndIntervals = new DruidFilterBuilder(this).filterToDruid(this.getQueryFilter());
        druidQuery.intervals = filterAndIntervals.intervals;
        if (filterAndIntervals.filter) {
            druidQuery.filter = filterAndIntervals.filter;
        }
        var aggregationsAndPostAggregations;
        switch (mode) {
            case 'raw':
                if (!this.allowSelectQueries) {
                    throw new Error("to issues 'select' queries allowSelectQueries flag must be set");
                }
                var selectDimensions_1 = [];
                var selectMetrics_1 = [];
                var inflaters_3 = [];
                var timeAttribute_1 = this.timeAttribute;
                var derivedAttributes_1 = this.derivedAttributes;
                var selectedTimeAttribute_1 = null;
                var selectedAttributes = this.getSelectedAttributes();
                selectedAttributes.forEach(function (attribute) {
                    var name = attribute.name, type = attribute.type, unsplitable = attribute.unsplitable;
                    if (name === timeAttribute_1) {
                        selectedTimeAttribute_1 = name;
                    }
                    else {
                        if (unsplitable) {
                            selectMetrics_1.push(name);
                        }
                        else {
                            var derivedAttribute = derivedAttributes_1[name];
                            if (derivedAttribute) {
                                if (_this.versionBefore('0.9.1')) {
                                    throw new Error("can not have derived attributes in Druid select in " + _this.version + ", upgrade to 0.9.1");
                                }
                                var dimensionInflater = _this.expressionToDimensionInflater(derivedAttribute, name);
                                selectDimensions_1.push(dimensionInflater.dimension);
                                if (dimensionInflater.inflater)
                                    inflaters_3.push(dimensionInflater.inflater);
                                return;
                            }
                            else {
                                selectDimensions_1.push(name);
                            }
                        }
                    }
                    switch (type) {
                        case 'BOOLEAN':
                            inflaters_3.push(External.booleanInflaterFactory(name));
                            break;
                        case 'NUMBER':
                            inflaters_3.push(External.numberInflaterFactory(name));
                            break;
                        case 'TIME':
                            inflaters_3.push(External.timeInflaterFactory(name));
                            break;
                        case 'SET/STRING':
                            inflaters_3.push(External.setStringInflaterFactory(name));
                            break;
                    }
                });
                if (!selectDimensions_1.length)
                    selectDimensions_1.push(DruidExternal.DUMMY_NAME);
                if (!selectMetrics_1.length)
                    selectMetrics_1.push(DruidExternal.DUMMY_NAME);
                var resultLimit = limit ? limit.value : Infinity;
                druidQuery.queryType = 'select';
                druidQuery.dimensions = selectDimensions_1;
                druidQuery.metrics = selectMetrics_1;
                druidQuery.pagingSpec = {
                    "pagingIdentifiers": {},
                    "threshold": Math.min(resultLimit, DruidExternal.SELECT_INIT_LIMIT)
                };
                var descending = sort && sort.direction === 'descending';
                if (descending) {
                    druidQuery.descending = true;
                }
                return {
                    query: druidQuery,
                    postProcess: DruidExternal.postProcessFactory(DruidExternal.selectNormalizerFactory(selectedTimeAttribute_1), inflaters_3, selectedAttributes),
                    next: DruidExternal.selectNextFactory(resultLimit, descending)
                };
            case 'value':
                aggregationsAndPostAggregations = new DruidAggregationBuilder(this).makeAggregationsAndPostAggregations([this.toValueApply()]);
                if (aggregationsAndPostAggregations.aggregations.length) {
                    druidQuery.aggregations = aggregationsAndPostAggregations.aggregations;
                }
                if (aggregationsAndPostAggregations.postAggregations.length) {
                    druidQuery.postAggregations = aggregationsAndPostAggregations.postAggregations;
                }
                return {
                    query: druidQuery,
                    postProcess: DruidExternal.valuePostProcess
                };
            case 'total':
                aggregationsAndPostAggregations = new DruidAggregationBuilder(this).makeAggregationsAndPostAggregations(this.applies);
                if (aggregationsAndPostAggregations.aggregations.length) {
                    druidQuery.aggregations = aggregationsAndPostAggregations.aggregations;
                }
                if (aggregationsAndPostAggregations.postAggregations.length) {
                    druidQuery.postAggregations = aggregationsAndPostAggregations.postAggregations;
                }
                return {
                    query: druidQuery,
                    postProcess: DruidExternal.totalPostProcessFactory(applies)
                };
            case 'split':
                var split = this.getQuerySplit();
                var splitSpec = this.splitToDruid(split);
                druidQuery.queryType = splitSpec.queryType;
                druidQuery.granularity = splitSpec.granularity;
                if (splitSpec.dimension)
                    druidQuery.dimension = splitSpec.dimension;
                if (splitSpec.dimensions)
                    druidQuery.dimensions = splitSpec.dimensions;
                var leftoverHavingFilter = splitSpec.leftoverHavingFilter;
                var postProcess = splitSpec.postProcess;
                aggregationsAndPostAggregations = new DruidAggregationBuilder(this).makeAggregationsAndPostAggregations(applies);
                if (aggregationsAndPostAggregations.aggregations.length) {
                    druidQuery.aggregations = aggregationsAndPostAggregations.aggregations;
                }
                else {
                    druidQuery.aggregations = [{ name: DruidExternal.DUMMY_NAME, type: "count" }];
                }
                if (aggregationsAndPostAggregations.postAggregations.length) {
                    druidQuery.postAggregations = aggregationsAndPostAggregations.postAggregations;
                }
                switch (druidQuery.queryType) {
                    case 'timeseries':
                        if (sort && (sort.direction !== 'ascending' || !split.hasKey(sort.refName()))) {
                            throw new Error('can not sort within timeseries query');
                        }
                        if (limit) {
                            throw new Error('can not limit within timeseries query');
                        }
                        if (!druidQuery.context || !hasOwnProperty(druidQuery.context, 'skipEmptyBuckets')) {
                            druidQuery.context = druidQuery.context || {};
                            druidQuery.context.skipEmptyBuckets = "true";
                        }
                        break;
                    case 'topN':
                        var metric = void 0;
                        if (sort) {
                            var inverted = void 0;
                            if (this.sortOnLabel()) {
                                if (expressionNeedsAlphaNumericSort(split.firstSplitExpression())) {
                                    metric = { type: 'alphaNumeric' };
                                }
                                else {
                                    metric = { type: 'lexicographic' };
                                }
                                inverted = sort.direction === 'descending';
                            }
                            else {
                                metric = sort.refName();
                                inverted = sort.direction === 'ascending';
                            }
                            if (inverted) {
                                metric = { type: "inverted", metric: metric };
                            }
                        }
                        else {
                            metric = { type: 'lexicographic' };
                        }
                        druidQuery.metric = metric;
                        druidQuery.threshold = limit ? limit.value : 1000;
                        break;
                    case 'groupBy':
                        var orderByColumn = null;
                        if (sort) {
                            var col = sort.refName();
                            orderByColumn = {
                                dimension: col,
                                direction: sort.direction
                            };
                            if (this.sortOnLabel()) {
                                if (expressionNeedsAlphaNumericSort(split.splits[col])) {
                                    orderByColumn.dimensionOrder = 'alphanumeric';
                                }
                            }
                        }
                        else {
                            var timestampLabel_2 = splitSpec.timestampLabel;
                            var splitKeys = split.keys.filter(function (k) { return k !== timestampLabel_2; });
                            if (!splitKeys.length)
                                throw new Error('could not find order by column for group by');
                            var splitKey = splitKeys[0];
                            var keyExpression = split.splits[splitKey];
                            orderByColumn = {
                                dimension: splitKey
                            };
                            if (expressionNeedsAlphaNumericSort(keyExpression)) {
                                orderByColumn.dimensionOrder = 'alphanumeric';
                            }
                        }
                        druidQuery.limitSpec = {
                            type: "default",
                            columns: [orderByColumn || split.firstSplitName()]
                        };
                        if (limit) {
                            druidQuery.limitSpec.limit = limit.value;
                        }
                        if (!leftoverHavingFilter.equals(Expression.TRUE)) {
                            druidQuery.having = new DruidHavingFilterBuilder(this).filterToHavingFilter(leftoverHavingFilter);
                        }
                        break;
                }
                return {
                    query: druidQuery,
                    postProcess: postProcess
                };
            default:
                throw new Error("can not get query for: " + this.mode);
        }
    };
    DruidExternal.prototype.getIntrospectAttributesWithSegmentMetadata = function () {
        var _a = this, requester = _a.requester, timeAttribute = _a.timeAttribute, context = _a.context;
        var query = {
            queryType: 'segmentMetadata',
            dataSource: this.getDruidDataSource(),
            merge: true,
            analysisTypes: ['aggregators'],
            lenientAggregatorMerge: true
        };
        if (context) {
            query.context = context;
        }
        if (this.versionBefore('0.9.0')) {
            query.analysisTypes = [];
            delete query.lenientAggregatorMerge;
        }
        if (this.versionBefore('0.9.2') && query.dataSource.type === 'union') {
            query.dataSource = query.dataSource.dataSources[0];
        }
        return requester({ query: query }).then(DruidExternal.segmentMetadataPostProcessFactory(timeAttribute));
    };
    DruidExternal.prototype.getIntrospectAttributesWithGet = function () {
        var _a = this, requester = _a.requester, timeAttribute = _a.timeAttribute;
        return requester({
            query: {
                queryType: 'introspect',
                dataSource: this.getDruidDataSource()
            }
        })
            .then(DruidExternal.introspectPostProcessFactory(timeAttribute));
    };
    DruidExternal.prototype.getIntrospectAttributes = function () {
        var _this = this;
        switch (this.introspectionStrategy) {
            case 'segment-metadata-fallback':
                return this.getIntrospectAttributesWithSegmentMetadata()
                    .catch(function (err) {
                    if (err.message.indexOf("querySegmentSpec can't be null") === -1)
                        throw err;
                    return _this.getIntrospectAttributesWithGet();
                });
            case 'segment-metadata-only':
                return this.getIntrospectAttributesWithSegmentMetadata();
            case 'datasource-get':
                return this.getIntrospectAttributesWithGet();
            default:
                throw new Error('invalid introspectionStrategy');
        }
    };
    DruidExternal.engine = 'druid';
    DruidExternal.type = 'DATASET';
    DruidExternal.DUMMY_NAME = '!DUMMY';
    DruidExternal.TIME_ATTRIBUTE = '__time';
    DruidExternal.VALID_INTROSPECTION_STRATEGIES = ['segment-metadata-fallback', 'segment-metadata-only', 'datasource-get'];
    DruidExternal.DEFAULT_INTROSPECTION_STRATEGY = 'segment-metadata-fallback';
    DruidExternal.SELECT_INIT_LIMIT = 50;
    DruidExternal.SELECT_MAX_LIMIT = 10000;
    return DruidExternal;
}(External));
External.register(DruidExternal);
