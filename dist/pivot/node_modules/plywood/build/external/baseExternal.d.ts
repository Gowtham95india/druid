import * as Q from 'q';
import { Timezone, Duration } from 'chronoshift';
import { DatasetFullType, PlyTypeSimple } from '../types';
import { Expression, ChainableUnaryExpression, ApplyExpression, FilterExpression, LimitExpression, SelectExpression, SortExpression, SplitExpression } from '../expressions/index';
import { PlywoodValue, Datum, Dataset } from '../datatypes/dataset';
import { Attributes, AttributeInfo, AttributeJSs } from '../datatypes/attributeInfo';
import { CustomDruidAggregations, CustomDruidTransforms } from './utils/druidTypes';
import { ExpressionJS } from '../expressions/baseExpression';
export declare class TotalContainer {
    datum: Datum;
    constructor(d: Datum);
    toJS(): any;
}
export interface PostProcess {
    (result: any): PlywoodValue | TotalContainer;
}
export interface NextFn<Q, R> {
    (prevQuery: Q, prevResult: R): Q;
}
export interface QueryAndPostProcess<T> {
    query: T;
    postProcess: PostProcess;
    next?: NextFn<T, any>;
}
export interface Inflater {
    (d: Datum, i: number, data: Datum[]): void;
}
export declare type QueryMode = "raw" | "value" | "total" | "split";
export interface ExternalValue {
    engine?: string;
    version?: string;
    suppress?: boolean;
    source?: string | string[];
    rollup?: boolean;
    attributes?: Attributes;
    attributeOverrides?: Attributes;
    derivedAttributes?: Lookup<Expression>;
    delegates?: External[];
    concealBuckets?: boolean;
    mode?: QueryMode;
    dataName?: string;
    rawAttributes?: Attributes;
    filter?: Expression;
    valueExpression?: Expression;
    select?: SelectExpression;
    split?: SplitExpression;
    applies?: ApplyExpression[];
    sort?: SortExpression;
    limit?: LimitExpression;
    havingFilter?: Expression;
    timeAttribute?: string;
    customAggregations?: CustomDruidAggregations;
    customTransforms?: CustomDruidTransforms;
    allowEternity?: boolean;
    allowSelectQueries?: boolean;
    introspectionStrategy?: string;
    exactResultsOnly?: boolean;
    context?: Lookup<any>;
    requester?: Requester.PlywoodRequester<any>;
}
export interface ExternalJS {
    engine: string;
    version?: string;
    source?: string | string[];
    rollup?: boolean;
    attributes?: AttributeJSs;
    attributeOverrides?: AttributeJSs;
    derivedAttributes?: Lookup<ExpressionJS>;
    filter?: ExpressionJS;
    rawAttributes?: AttributeJSs;
    concealBuckets?: boolean;
    timeAttribute?: string;
    customAggregations?: CustomDruidAggregations;
    customTransforms?: CustomDruidTransforms;
    allowEternity?: boolean;
    allowSelectQueries?: boolean;
    introspectionStrategy?: string;
    exactResultsOnly?: boolean;
    context?: Lookup<any>;
}
export interface ApplySegregation {
    aggregateApplies: ApplyExpression[];
    postAggregateApplies: ApplyExpression[];
}
export interface AttributesAndApplies {
    attributes?: Attributes;
    applies?: ApplyExpression[];
}
export declare abstract class External {
    static type: string;
    static SEGMENT_NAME: string;
    static VALUE_NAME: string;
    static isExternal(candidate: any): candidate is External;
    static extractVersion(v: string): string;
    static versionLessThan(va: string, vb: string): boolean;
    static deduplicateExternals(externals: External[]): External[];
    static addExtraFilter(ex: Expression, extraFilter: Expression): Expression;
    static makeZeroDatum(applies: ApplyExpression[]): Datum;
    static normalizeAndAddApply(attributesAndApplies: AttributesAndApplies, apply: ApplyExpression): AttributesAndApplies;
    static segregationAggregateApplies(applies: ApplyExpression[]): ApplySegregation;
    static getCommonFilterFromExternals(externals: External[]): Expression;
    static getMergedDerivedAttributesFromExternals(externals: External[]): Lookup<Expression>;
    static getSimpleInflater(splitExpression: Expression, label: string): Inflater;
    static booleanInflaterFactory(label: string): Inflater;
    static timeRangeInflaterFactory(label: string, duration: Duration, timezone: Timezone): Inflater;
    static numberRangeInflaterFactory(label: string, rangeSize: number): Inflater;
    static numberInflaterFactory(label: string): Inflater;
    static timeInflaterFactory(label: string): Inflater;
    static setStringInflaterFactory(label: string): Inflater;
    static setCardinalityInflaterFactory(label: string): Inflater;
    static typeCheckDerivedAttributes(derivedAttributes: Lookup<Expression>, typeContext: DatasetFullType): Lookup<Expression>;
    static jsToValue(parameters: ExternalJS, requester: Requester.PlywoodRequester<any>): ExternalValue;
    static classMap: Lookup<typeof External>;
    static register(ex: typeof External): void;
    static getConstructorFor(engine: string): typeof External;
    static uniteValueExternalsIntoTotal(keyExternals: {
        key: string;
        external?: External;
    }[]): External;
    static fromJS(parameters: ExternalJS, requester?: Requester.PlywoodRequester<any>): External;
    static fromValue(parameters: ExternalValue): External;
    engine: string;
    version: string;
    source: string | string[];
    suppress: boolean;
    rollup: boolean;
    attributes: Attributes;
    attributeOverrides: Attributes;
    derivedAttributes: Lookup<Expression>;
    delegates: External[];
    concealBuckets: boolean;
    rawAttributes: Attributes;
    requester: Requester.PlywoodRequester<any>;
    mode: QueryMode;
    filter: Expression;
    valueExpression: Expression;
    select: SelectExpression;
    split: SplitExpression;
    dataName: string;
    applies: ApplyExpression[];
    sort: SortExpression;
    limit: LimitExpression;
    havingFilter: Expression;
    constructor(parameters: ExternalValue, dummy?: any);
    protected _ensureEngine(engine: string): void;
    protected _ensureMinVersion(minVersion: string): void;
    valueOf(): ExternalValue;
    toJS(): ExternalJS;
    toJSON(): ExternalJS;
    toString(): string;
    equals(other: External): boolean;
    equalBaseAndFilter(other: External): boolean;
    equalBase(other: External): boolean;
    changeVersion(version: string): External;
    attachRequester(requester: Requester.PlywoodRequester<any>): External;
    versionBefore(neededVersion: string): boolean;
    getAttributesInfo(attributeName: string): AttributeInfo;
    updateAttribute(newAttribute: AttributeInfo): External;
    show(): External;
    hasAttribute(name: string): boolean;
    expressionDefined(ex: Expression): boolean;
    bucketsConcealed(ex: Expression): boolean;
    abstract canHandleTotal(): boolean;
    abstract canHandleFilter(filter: FilterExpression): boolean;
    abstract canHandleSplit(split: SplitExpression): boolean;
    abstract canHandleSplitExpression(ex: Expression): boolean;
    abstract canHandleApply(apply: ApplyExpression): boolean;
    abstract canHandleSort(sort: SortExpression): boolean;
    abstract canHandleLimit(limit: LimitExpression): boolean;
    abstract canHandleHavingFilter(havingFilter: FilterExpression): boolean;
    addDelegate(delegate: External): External;
    getBase(): External;
    getRaw(): External;
    makeTotal(applies: ApplyExpression[]): External;
    addExpression(ex: Expression): External;
    private _addFilterExpression(filter);
    private _addSelectExpression(selectExpression);
    private _addSplitExpression(split);
    private _addApplyExpression(apply);
    private _addSortExpression(sort);
    private _addLimitExpression(limit);
    private _addAggregateExpression(aggregate);
    private _addPostAggregateExpression(action);
    prePush(ex: ChainableUnaryExpression): External;
    valueExpressionWithinFilter(withinFilter: Expression): Expression;
    toValueApply(): ApplyExpression;
    sortOnLabel(): boolean;
    getQuerySplit(): SplitExpression;
    getQueryFilter(): Expression;
    inlineDerivedAttributes(expression: Expression): Expression;
    getSelectedAttributes(): Attributes;
    getValueType(): PlyTypeSimple;
    addNextExternal(dataset: Dataset): Dataset;
    getDelegate(): External;
    simulateValue(lastNode: boolean, simulatedQueries: any[], externalForNext?: External): PlywoodValue | TotalContainer;
    getQueryAndPostProcess(): QueryAndPostProcess<any>;
    queryValue(lastNode: boolean, externalForNext?: External): Q.Promise<PlywoodValue | TotalContainer>;
    needsIntrospect(): boolean;
    protected abstract getIntrospectAttributes(): Q.Promise<Attributes>;
    introspect(): Q.Promise<External>;
    getRawFullType(skipDerived?: boolean): DatasetFullType;
    getFullType(): DatasetFullType;
}
